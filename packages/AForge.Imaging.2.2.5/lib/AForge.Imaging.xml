<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AForge.Imaging</name>
    </assembly>
    <members>
        <member name="T:AForge.Imaging.ICornersDetector">
            <summary>
            Corners detector's interface.
            </summary>
            
            <remarks><para>The interface specifies set of methods, which should be implemented by different
            corners detection algorithms.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.ICornersDetector.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="image">Source image to process.</param>
            
            <returns>Returns list of found corners (X-Y coordinates).</returns>
            
        </member>
        <member name="M:AForge.Imaging.ICornersDetector.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            
            <returns>Returns list of found corners (X-Y coordinates).</returns>
            
        </member>
        <member name="M:AForge.Imaging.ICornersDetector.ProcessImage(AForge.Imaging.UnmanagedImage)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="image">Unmanaged source image to process.</param>
            
            <returns>Returns list of found corners (X-Y coordinates).</returns>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Shrink">
            <summary>
            Shrink an image by removing specified color from its boundaries.
            </summary>
            
            <remarks><para>Removes pixels with specified color from image boundaries making
            the image smaller in size.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Shrink filter = new Shrink( Color.Black );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample2.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="img/imaging/shrink.jpg" width="295" height="226" />
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BaseTransformationFilter">
            <summary>
            Base class for filters, which may produce new image of different size as a
            result of image processing.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which
            do image processing creating new image of the size, which may differ from the
            size of source image. Filters based on this class cannot be applied directly
            to the source image, which is kept unchanged.</para>
            
            <para>The base class itself does not define supported pixel formats of source
            image and resulting pixel formats of destination image. Filters inheriting from
            this base class, should specify supported pixel formats and their transformations
            overriding abstract <see cref="P:AForge.Imaging.Filters.BaseTransformationFilter.FormatTranslations"/> property.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.IFilter">
            <summary>
            Image processing filter interface.
            </summary>
            
            <remarks>The interface defines the set of methods, which should be
            provided by all image processing filters. Methods of this interface
            keep the source image unchanged and returt the result of image processing
            filter as new image.</remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.IInPlaceFilter"/>
            <seealso cref="T:AForge.Imaging.Filters.IInPlacePartialFilter"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks> 
            
        </member>
        <member name="M:AForge.Imaging.Filters.IFilter.Apply(System.Drawing.Imaging.BitmapData)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="imageData">Source image to apply filter to.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The filter accepts bitmap data as input and returns the result
            of image processing filter as new image. The source image data are kept
            unchanged.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IFilter.Apply(AForge.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image in unmanaged memory.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The method keeps the source image unchanged and returns
            the result of image processing filter as new image.</remarks> 
            
        </member>
        <member name="M:AForge.Imaging.Filters.IFilter.Apply(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="sourceImage">Source image to be processed.</param>
            <param name="destinationImage">Destination image to store filter's result.</param>
            
            <remarks><para>The method keeps the source image unchanged and puts the
            the result of image processing filter into destination image.</para>
            
            <para><note>The destination image must have the size, which is expected by
            the filter.</note></para>
            </remarks>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">In the case if destination image has incorrect
            size.</exception>
            
        </member>
        <member name="T:AForge.Imaging.Filters.IFilterInformation">
            <summary>
            Interface which provides information about image processing filter.
            </summary>
            
            <remarks><para>The interface defines set of properties, which provide different type
            of information about image processing filters implementing <see cref="T:AForge.Imaging.Filters.IFilter"/> interface
            or another filter's interface.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>The dictionary defines, which pixel formats are supported for
            source images and which pixel format will be used for resulting image.
            </para>
            
            <para>Keys of this dictionary defines all pixel formats which are supported for source
            images, but corresponding values define what will be resulting pixel format. For
            example, if value <see cref="T:System.Drawing.Imaging.PixelFormat">Format16bppGrayScale</see>
            is put into the dictionary with the
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format48bppRgb</see> key, then it means
            that the filter accepts color 48 bpp image and produces 16 bpp grayscale image as a result
            of image processing.</para>
            
            <para>The information provided by this property is mostly actual for filters, which can not
            be applied directly to the source image, but provide new image a result. Since usually all
            filters implement <see cref="T:AForge.Imaging.Filters.IFilter"/> interface, the information provided by this property
            (if filter also implements <see cref="T:AForge.Imaging.Filters.IFilterInformation"/> interface) may be useful to
            user to resolve filter's capabilities.</para>
            
            <para>Sample usage:</para>
            <code>
            // get filter's IFilterInformation interface
            IFilterInformation info = (IFilterInformation) filter;
            // check if the filter supports our image's format
            if ( info.FormatTranslations.ContainsKey( image.PixelFormat )
            {
                // format is supported, check what will be result of image processing
                PixelFormat resultingFormat = info.FormatTranslations[image.PixelFormat];
            }
            /// </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseTransformationFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseTransformationFilter.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseTransformationFilter.Apply(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseTransformationFilter.Apply(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:AForge.Imaging.Filters.BaseTransformationFilter.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseTransformationFilter.CalculateNewImageSize(AForge.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseTransformationFilter.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseTransformationFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Shrink.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Shrink"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Shrink.#ctor(System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Shrink"/> class.
            </summary>
            
            <param name="colorToRemove">Color to remove from boundaries.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Shrink.CalculateNewImageSize(AForge.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Shrink.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Shrink.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.Shrink.ColorToRemove">
            <summary>
            Color to remove from boundaries.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Filters.RotateNearestNeighbor">
             <summary>
             Rotate image using nearest neighbor algorithm.
             </summary>
             
             <remarks><para>The class implements image rotation filter using nearest
             neighbor algorithm, which does not assume any interpolation.</para>
             
             <para><note>Rotation is performed in counterclockwise direction.</note></para>
             
             <para>The filter accepts 8/16 bpp grayscale images and 24/48 bpp color image
             for processing.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter - rotate for 30 degrees keeping original image size
             RotateNearestNeighbor filter = new RotateNearestNeighbor( 30, true );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample9.png" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/rotate_nearest.png" width="320" height="240"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.RotateBilinear"/>
             <seealso cref="T:AForge.Imaging.Filters.RotateBicubic"/>
             
        </member>
        <member name="T:AForge.Imaging.Filters.BaseRotateFilter">
            <summary>
            Base class for image rotation filters.
            </summary>
            
            <remarks>The abstract class is the base class for all filters,
            which implement rotating algorithms.</remarks>
            
        </member>
        <member name="F:AForge.Imaging.Filters.BaseRotateFilter.angle">
            <summary>
            Rotation angle.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.BaseRotateFilter.keepSize">
            <summary>
            Keep image size or not.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.BaseRotateFilter.fillColor">
            <summary>
            Fill color.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.BaseRotateFilter.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BaseRotateFilter"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            
            <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.BaseRotateFilter.KeepSize"/> property to <b>false</b>.
            </para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseRotateFilter.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BaseRotateFilter"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            <param name="keepSize">Keep image size or not.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseRotateFilter.CalculateNewImageSize(AForge.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseRotateFilter.Angle">
            <summary>
            Rotation angle, [0, 360].
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.BaseRotateFilter.KeepSize">
            <summary>
            Keep image size or not.
            </summary>
            
            <remarks><para>The property determines if source image's size will be kept
            as it is or not. If the value is set to <b>false</b>, then the new image will have
            new dimension according to rotation angle. If the valus is set to
            <b>true</b>, then the new image will have the same size, which means that some parts
            of the image may be clipped because of rotation.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseRotateFilter.FillColor">
            <summary>
            Fill color.
            </summary>
            
            <remarks><para>The fill color is used to fill areas of destination image,
            which don't have corresponsing pixels in source image.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.RotateNearestNeighbor.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.RotateNearestNeighbor"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            
            <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.BaseRotateFilter.KeepSize"/> property to
            <see langword="false"/>.
            </para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.RotateNearestNeighbor.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.RotateNearestNeighbor"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            <param name="keepSize">Keep image size or not.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.RotateNearestNeighbor.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.RotateNearestNeighbor.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.ConservativeSmoothing">
            <summary>
            Conservative smoothing.
            </summary>
            
            <remarks><para>The filter implements conservative smoothing, which is a noise reduction
            technique that derives its name from the fact that it employs a simple, fast filtering
            algorithm that sacrifices noise suppression power in order to preserve the high spatial
            frequency detail (e.g. sharp edges) in an image. It is explicitly designed to remove noise
            spikes - <b>isolated</b> pixels of exceptionally low or high pixel intensity
            (<see cref="T:AForge.Imaging.Filters.SaltAndPepperNoise">salt and pepper noise</see>).</para>
            
            <para>If the filter finds a pixel which has minimum/maximum value compared to its surrounding
            pixel, then its value is replaced by minimum/maximum value of those surrounding pixel.
            For example, lets suppose the filter uses <see cref="P:AForge.Imaging.Filters.ConservativeSmoothing.KernelSize">kernel size</see> of 3x3,
            which means each pixel has 8 surrounding pixel. If pixel's value is smaller than any value
            of surrounding pixels, then the value of the pixel is replaced by minimum value of those surrounding
            pixels.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ConservativeSmoothing filter = new ConservativeSmoothing( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample13.png" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/conservative_smoothing.png" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BaseUsingCopyPartialFilter">
             <summary>
             Base class for filters, which require source image backup to make them applicable to
             source image (or its part) directly.
             </summary>
             
             <remarks><para>The base class is used for filters, which can not do
             direct manipulations with source image. To make effect of in-place filtering,
             these filters create a background copy of the original image (done by this
             base class) and then do manipulations with it putting result back to the original
             source image.</para>
             
             <para><note>The background copy of the source image is created only in the case of in-place
             filtering. Otherwise background copy is not created - source image is processed and result is
             put to destination image.</note></para>
             
             <para>The base class is for those filters, which support as filtering entire image, as
             partial filtering of specified rectangle only.</para>
             </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.IInPlaceFilter">
            <summary>
            In-place filter interface.
            </summary>
            
            <remarks>The interface defines the set of methods, which should be
            implemented by filters, which are capable to do image processing
            directly on the source image. Not all image processing filters
            can be applied directly to the source image - only filters, which do not
            change image's dimension and pixel format, can be applied directly to the
            source image.</remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.IFilter"/>
            <seealso cref="T:AForge.Imaging.Filters.IInPlacePartialFilter"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IInPlaceFilter.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies filter directly to the provided image data.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IInPlaceFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="imageData">Image to apply filter to.</param>
            
            <remarks>The method applies filter directly to the provided image data.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IInPlaceFilter.ApplyInPlace(AForge.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image in unmanaged memory.
            </summary>
            
            <param name="image">Image in unmanaged memory.</param>
            
            <remarks>The method applies filter directly to the provided image data.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.IInPlacePartialFilter">
            <summary>
            In-place partial filter interface.
            </summary>
            
            <remarks><para>The interface defines the set of methods, which should be
            implemented by filters, which are capable to do image processing
            directly on the source image. Not all image processing filters
            can be applied directly to the source image - only filters, which do not
            change image dimension and pixel format, can be applied directly to the
            source image.</para>
            
            <para>The interface also supports partial image filtering, allowing to specify
            image rectangle, which should be filtered.</para>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.IFilter"/>
            <seealso cref="T:AForge.Imaging.Filters.IInPlaceFilter"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IInPlacePartialFilter.ApplyInPlace(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by filter.</param>
            
            <remarks>The method applies filter directly to the provided image data.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IInPlacePartialFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="imageData">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by filter.</param>
            
            <remarks>The method applies filter directly to the provided image data.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IInPlacePartialFilter.ApplyInPlace(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image in unmanaged memory.
            </summary>
            
            <param name="image">Image in unmanaged memory.</param>
            <param name="rect">Image rectangle for processing by filter.</param>
            
            <remarks>The method applies filter directly to the provided image.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.Apply(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.Apply(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an unmanaged image.
             </summary>
             
             <param name="image">Unmanaged image to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source unmanaged image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
             <summary>
             Apply filter to an image or its part.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an unmanaged image or its part.
            </summary>
            
            <param name="image">Unmanaged image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseUsingCopyPartialFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ConservativeSmoothing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ConservativeSmoothing"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ConservativeSmoothing.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ConservativeSmoothing"/> class.
            </summary>
            
            <param name="size">Kernel size.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ConservativeSmoothing.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ConservativeSmoothing.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ConservativeSmoothing.KernelSize">
            <summary>
            Kernel size, [3, 25].
            </summary>
            
            <remarks><para>Determines the size of pixel's square used for smoothing.</para>
            
            <para>Default value is set to <b>3</b>.</para>
            
            <para><note>The value should be odd.</note></para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.RotateChannels">
            <summary>
            Rotate RGB channels.
            </summary>
            
            <remarks><para>The filter rotates RGB channels: red channel is replaced with green,
            green channel is replaced with blue, blue channel is replaced with red.</para>
            
            <para>The filter accepts 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            RotateChannels filter = new RotateChannels( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="img/imaging/rotate_channels.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BaseInPlacePartialFilter">
            <summary>
            Base class for filters, which may be applied directly to the source image or its part.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which can
            be applied to an image producing new image as a result of image processing or
            applied directly to the source image (or its part) without changing its size and
            pixel format.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlacePartialFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlacePartialFilter.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlacePartialFilter.Apply(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlacePartialFilter.Apply(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:AForge.Imaging.Filters.BaseInPlacePartialFilter.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an unmanaged image.
             </summary>
             
             <param name="image">Unmanaged image to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source unmanaged image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
             <summary>
             Apply filter to an image or its part.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an unmanaged image or its part.
            </summary>
            
            <param name="image">Unmanaged image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlacePartialFilter.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseInPlacePartialFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.RotateChannels.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.RotateChannels"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.RotateChannels.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.RotateChannels.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.GammaCorrection">
            <summary>
            Gamma correction filter.
            </summary>
            
            <remarks><para>The filter performs <a href="http://en.wikipedia.org/wiki/Gamma_correction">gamma correction</a>
            of specified image in RGB color space. Each pixels' value is converted using the V<sub>out</sub>=V<sub>in</sub><sup>g</sup>
            equation, where <b>g</b> is <see cref="P:AForge.Imaging.Filters.GammaCorrection.Gamma">gamma value</see>.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            GammaCorrection filter = new GammaCorrection( 0.5 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/gamma.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GammaCorrection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GammaCorrection"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.GammaCorrection.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GammaCorrection"/> class.
            </summary>
            
            <param name="gamma">Gamma value.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GammaCorrection.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.GammaCorrection.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.GammaCorrection.Gamma">
            <summary>
            Gamma value, [0.1, 5.0].
            </summary>
            
            <remarks>Default value is set to <b>2.2</b>.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BrightnessCorrection">
            <summary>
            Brightness adjusting in RGB color space.
            </summary>
            
            <remarks><para>The filter operates in <b>RGB</b> color space and adjusts
            pixels' brightness by increasing every pixel's RGB values by the specified
            <see cref="P:AForge.Imaging.Filters.BrightnessCorrection.AdjustValue">adjust value</see>. The filter is based on <see cref="T:AForge.Imaging.Filters.LevelsLinear"/>
            filter and simply sets all input ranges to (0, 255-<see cref="P:AForge.Imaging.Filters.BrightnessCorrection.AdjustValue"/>) and
            all output range to (<see cref="P:AForge.Imaging.Filters.BrightnessCorrection.AdjustValue"/>, 255) in the case if the adjust value is positive.
            If the adjust value is negative, then all input ranges are set to
            (-<see cref="P:AForge.Imaging.Filters.BrightnessCorrection.AdjustValue"/>, 255 ) and all output ranges are set to
            ( 0, 255+<see cref="P:AForge.Imaging.Filters.BrightnessCorrection.AdjustValue"/>).</para>
            
            <para>See <see cref="T:AForge.Imaging.Filters.LevelsLinear"/> documentation for more information about the base filter.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            BrightnessCorrection filter = new BrightnessCorrection( -50 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/brightness_correction.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.LevelsLinear"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BrightnessCorrection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BrightnessCorrection"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BrightnessCorrection.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BrightnessCorrection"/> class.
            </summary>
            
            <param name="adjustValue">Brightness <see cref="P:AForge.Imaging.Filters.BrightnessCorrection.AdjustValue">adjust value</see>.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BrightnessCorrection.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BrightnessCorrection.AdjustValue">
             <summary>
             Brightness adjust value, [-255, 255].
             </summary>
             
             <remarks>Default value is set to <b>10</b>, which corresponds to increasing
             RGB values of each pixel by 10.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BrightnessCorrection.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
             documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.StuckiDithering">
             <summary>
             Dithering using Stucki error diffusion.
             </summary>
             
             <remarks><para>The filter represents binarization filter, which is based on
             error diffusion dithering with Stucki coefficients. Error is diffused
             on 12 neighbor pixels with next coefficients:</para>
             <code lang="none">
                     | * | 8 | 4 |
             | 2 | 4 | 8 | 4 | 2 |
             | 1 | 2 | 4 | 2 | 1 |
             
             / 42
             </code>
             
             <para>The filter accepts 8 bpp grayscale images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             StuckiDithering filter = new StuckiDithering( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/grayscale.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/stucki.jpg" width="480" height="361"/>
             </remarks>
            
             <seealso cref="T:AForge.Imaging.Filters.BurkesDithering"/>
             <seealso cref="T:AForge.Imaging.Filters.FloydSteinbergDithering"/>
             <seealso cref="T:AForge.Imaging.Filters.JarvisJudiceNinkeDithering"/>
             <seealso cref="T:AForge.Imaging.Filters.SierraDithering"/>
             
        </member>
        <member name="T:AForge.Imaging.Filters.ErrorDiffusionToAdjacentNeighbors">
            <summary>
            Base class for error diffusion dithering, where error is diffused to 
            adjacent neighbor pixels.
            </summary>
            
            <remarks><para>The class does error diffusion to adjacent neighbor pixels
            using specified set of coefficients. These coefficients are represented by
            2 dimensional jugged array, where first array of coefficients is for
            right-standing pixels, but the rest of arrays are for bottom-standing pixels.
            All arrays except the first one should have odd number of coefficients.</para>
            
            <para>Suppose that error diffusion coefficients are represented by the next
            jugged array:</para>
            
            <code>
            int[][] coefficients = new int[2][] {
                new int[1] { 7 },
                new int[3] { 3, 5, 1 }
            };
            </code>
            
            <para>The above coefficients are used to diffuse error over the next neighbor
            pixels (<b>*</b> marks current pixel, coefficients are placed to corresponding
            neighbor pixels):</para>
            <code lang="none">
                | * | 7 |
            | 3 | 5 | 1 |
            
            / 16
            </code>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ErrorDiffusionToAdjacentNeighbors filter = new ErrorDiffusionToAdjacentNeighbors(
                new int[3][] {
                    new int[2] { 5, 3 },
                    new int[5] { 2, 4, 5, 4, 2 },
                    new int[3] { 2, 3, 2 }
                } );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ErrorDiffusionDithering">
            <summary>
            Base class for error diffusion dithering.
            </summary>
            
            <remarks><para>The class is the base class for binarization algorithms based on
            <a href="http://en.wikipedia.org/wiki/Error_diffusion">error diffusion</a>.</para>
            
            <para>Binarization with error diffusion in its idea is similar to binarization based on thresholding
            of pixels' cumulative value (see <see cref="T:AForge.Imaging.Filters.ThresholdWithCarry"/>). Each pixel is binarized based not only
            on its own value, but on values of some surrounding pixels. During pixel's binarization, its <b>binarization
            error</b> is distributed (diffused) to some neighbor pixels with some coefficients. This error diffusion
            updates neighbor pixels changing their values, what affects their upcoming binarization. Error diffuses
            only on unprocessed yet neighbor pixels, which are right and bottom pixels usually (in the case if image
            processing is done from upper left corner to bottom right corner). <b>Binarization error</b> equals
            to processing pixel value, if it is below threshold value, or pixel value minus 255 otherwise.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            </remarks>
            
        </member>
        <member name="F:AForge.Imaging.Filters.ErrorDiffusionDithering.x">
            <summary>
            Current processing X coordinate.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.ErrorDiffusionDithering.y">
            <summary>
            Current processing Y coordinate.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.ErrorDiffusionDithering.startX">
            <summary>
            Processing X start position.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.ErrorDiffusionDithering.startY">
            <summary>
            Processing Y start position.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.ErrorDiffusionDithering.stopX">
            <summary>
            Processing X stop position.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.ErrorDiffusionDithering.stopY">
            <summary>
            Processing Y stop position.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.ErrorDiffusionDithering.stride">
            <summary>
            Processing image's stride (line size).
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.ErrorDiffusionDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ErrorDiffusionDithering"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ErrorDiffusionDithering.Diffuse(System.Int32,System.Byte*)">
            <summary>
            Do error diffusion.
            </summary>
            
            <param name="error">Current error value.</param>
            <param name="ptr">Pointer to current processing pixel.</param>
            
            <remarks>All parameters of the image and current processing pixel's coordinates
            are initialized in protected members.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ErrorDiffusionDithering.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ErrorDiffusionDithering.ThresholdValue">
            <summary>
            Threshold value.
            </summary>
            
            <remarks>Default value is 128.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ErrorDiffusionDithering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.ErrorDiffusionToAdjacentNeighbors.#ctor(System.Int32[][])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ErrorDiffusionToAdjacentNeighbors"/> class.
            </summary>
            
            <param name="coefficients">Diffusion coefficients.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ErrorDiffusionToAdjacentNeighbors.Diffuse(System.Int32,System.Byte*)">
            <summary>
            Do error diffusion.
            </summary>
            
            <param name="error">Current error value.</param>
            <param name="ptr">Pointer to current processing pixel.</param>
            
            <remarks>All parameters of the image and current processing pixel's coordinates
            are initialized by base class.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ErrorDiffusionToAdjacentNeighbors.Coefficients">
            <summary>
            Diffusion coefficients.
            </summary>
            
            <remarks>Set of coefficients, which are used for error diffusion to
            pixel's neighbors.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.StuckiDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.StuckiDithering"/> class.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Interpolation">
            <summary>
            Interpolation routines.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Interpolation.BiCubicKernel(System.Double)">
            <summary>
            Bicubic kernel.
            </summary>
            
            <param name="x">X value.</param>
            
            <returns>Bicubic cooefficient.</returns>
            
            <remarks><para>The function implements bicubic kernel W(x) as described on
            <a href="http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm">Wikipedia</a>
            (coefficient <b>a</b> is set to <b>-0.5</b>).</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BinaryErosion3x3">
            <summary>
            Binary erosion operator from Mathematical Morphology with 3x3 structuring element.
            </summary>
            
            <remarks><para>The filter represents an optimized version of <see cref="T:AForge.Imaging.Filters.Erosion"/>
            filter, which is aimed for binary images (containing black and white pixels) processed
            with 3x3 structuring element. This makes this filter ideal for removing noise in binary
            images – it removes all white pixels, which are neighbouring with at least one blank pixel.
            </para>
            
            <para>See <see cref="T:AForge.Imaging.Filters.Erosion"/> filter, which represents generic version of
            erosion filter supporting custom structuring elements and wider range of image formats.</para>
            
            <para>The filter accepts 8 bpp grayscale (binary) images for processing.</para>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Erosion"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BinaryErosion3x3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BinaryErosion3x3"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BinaryErosion3x3.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Processing rectangle mast be at least 3x3 in size.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BinaryErosion3x3.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.FilterIterator">
            <summary>
            Filter iterator.
            </summary>
            
            <remarks><para>Filter iterator performs specified amount of filter's iterations.
            The filter take the specified <see cref="P:AForge.Imaging.Filters.FilterIterator.BaseFilter">base filter</see> and applies it
            to source image <see cref="P:AForge.Imaging.Filters.FilterIterator.Iterations">specified amount of times</see>.</para>
            
            <para><note>The filter itself does not have any restrictions to pixel format of source
            image. This is set by <see cref="P:AForge.Imaging.Filters.FilterIterator.BaseFilter">base filter</see>.</note></para>
            
            <para><note>The filter does image processing using only <see cref="T:AForge.Imaging.Filters.IFilter"/>
            interface of the specified <see cref="P:AForge.Imaging.Filters.FilterIterator.BaseFilter">base filter</see>. This means
            that this filter may not utilize all potential features of the base filter, like
            in-place processing (see <see cref="T:AForge.Imaging.Filters.IInPlaceFilter"/>) and region based processing
            (see <see cref="T:AForge.Imaging.Filters.IInPlacePartialFilter"/>). To utilize those features, it is required to
            do filter's iteration manually.</note></para>
            
            <para>Sample usage (morphological thinning):</para>
            <code>
            // create filter sequence
            FiltersSequence filterSequence = new FiltersSequence( );
            // add 8 thinning filters with different structuring elements
            filterSequence.Add( new HitAndMiss(
                new short [,] { { 0, 0, 0 }, { -1, 1, -1 }, { 1, 1, 1 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { -1, 0, 0 }, { 1, 1, 0 }, { -1, 1, -1 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { 1, -1, 0 }, { 1, 1, 0 }, { 1, -1, 0 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { -1, 1, -1 }, { 1, 1, 0 }, { -1, 0, 0 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { 1, 1, 1 }, { -1, 1, -1 }, { 0, 0, 0 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { -1, 1, -1 }, { 0, 1, 1 }, { 0, 0, -1 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { 0, -1, 1 }, { 0, 1, 1 }, { 0, -1, 1 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { 0, 0, -1 }, { 0, 1, 1 }, { -1, 1, -1 } },
                HitAndMiss.Modes.Thinning ) );
            // create filter iterator for 10 iterations
            FilterIterator filter = new FilterIterator( filterSequence, 10 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample14.png" width="150" height="150"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/thinning.png" width="150" height="150"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FilterIterator.#ctor(AForge.Imaging.Filters.IFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.FilterIterator"/> class.
            </summary>
            
            <param name="baseFilter">Filter to iterate.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FilterIterator.#ctor(AForge.Imaging.Filters.IFilter,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.FilterIterator"/> class.
            </summary>
            
            <param name="baseFilter">Filter to iterate.</param>
            <param name="iterations">Iterations amount.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FilterIterator.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks> 
            
        </member>
        <member name="M:AForge.Imaging.Filters.FilterIterator.Apply(System.Drawing.Imaging.BitmapData)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="imageData">Source image to apply filter to.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The filter accepts bitmap data as input and returns the result
            of image processing filter as new image. The source image data are kept
            unchanged.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FilterIterator.Apply(AForge.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image in unmanaged memory.
            </summary>
            
            <param name="image">Source image in unmanaged memory to apply filter to.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The method keeps the source image unchanged and returns
            the result of image processing filter as new image.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FilterIterator.Apply(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image in unmanaged memory.
            </summary>
            
            <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
            <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
            
            <remarks><para>The method keeps the source image unchanged and puts result of image processing
            into destination image.</para>
            
            <para><note>The destination image must have the same width and height as source image. Also
            destination image must have pixel format, which is expected by particular filter (see
            <see cref="P:AForge.Imaging.Filters.FilterIterator.FormatTranslations"/> property for information about pixel format conversions).</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.FilterIterator.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para>
            
            <para><note>The filter provides format translation dictionary taken from
            <see cref="P:AForge.Imaging.Filters.FilterIterator.BaseFilter"/> filter.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.FilterIterator.BaseFilter">
            <summary>
            Base filter.
            </summary>
            
            <remarks><para>The base filter is the filter to be applied specified amount of iterations to
            a specified image.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.FilterIterator.Iterations">
            <summary>
            Iterations amount, [1, 255].
            </summary>
            
            <remarks><para>The amount of times to apply specified filter to a specified image.</para>
            
            <para>Default value is set to <b>1</b>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Threshold">
            <summary>
            Threshold binarization.
            </summary>
            
            <remarks><para>The filter does image binarization using specified threshold value. All pixels
            with intensities equal or higher than threshold value are converted to white pixels. All other
            pixels with intensities below threshold value are converted to black pixels.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images for processing.</para>
            
            <para><note>Since the filter can be applied as to 8 bpp and to 16 bpp images,
            the <see cref="P:AForge.Imaging.Filters.Threshold.ThresholdValue"/> value should be set appropriately to the pixel format.
            In the case of 8 bpp images the threshold value is in the [0, 255] range, but in the case
            of 16 bpp images the threshold value is in the [0, 65535] range.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Threshold filter = new Threshold( 100 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/grayscale.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/threshold.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="F:AForge.Imaging.Filters.Threshold.threshold">
            <summary>
            Threshold value.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Threshold.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Threshold"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Threshold.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Threshold"/> class.
            </summary>
            
            <param name="threshold">Threshold value.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Threshold.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Threshold.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.Threshold.ThresholdValue">
            <summary>
            Threshold value.
            </summary>
            
            <remarks>Default value is set to <b>128</b>.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BaseInPlaceFilter">
            <summary>
            Base class for filters, which may be applied directly to the source image.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which can
            be applied to an image producing new image as a result of image processing or
            applied directly to the source image without changing its size and pixel format.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter.Apply(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter.Apply(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:AForge.Imaging.Filters.BaseInPlaceFilter.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter.ApplyInPlace(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an unmanaged image.
             </summary>
             
             <param name="image">Unmanaged image to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source unmanaged image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseInPlaceFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Add">
            <summary>
            Add fillter - add pixel values of two images.
            </summary>
            
            <remarks><para>The add filter takes two images (source and overlay images)
            of the same size and pixel format and produces an image, where each pixel equals
            to the sum value of corresponding pixels from provided images (if sum is greater
            than maximum allowed value, 255 or 65535, then it is truncated to that maximum).</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Add filter = new Add( overlayImage );
            // apply the filter
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="img/imaging/sample6.png" width="320" height="240"/>
            <para><b>Overlay image:</b></para>
            <img src="img/imaging/sample7.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/add.png" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Merge"/>
            <seealso cref="T:AForge.Imaging.Filters.Intersect"/>
            <seealso cref="T:AForge.Imaging.Filters.Subtract"/>
            <seealso cref="T:AForge.Imaging.Filters.Difference"/>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BaseInPlaceFilter2">
            <summary>
            Base class for filters, which operate with two images of the same size and format and
            may be applied directly to the source image.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which can
            be applied to an image producing new image as a result of image processing or
            applied directly to the source image without changing its size and pixel format.</para>
            
            <para>The base class is aimed for such type of filters, which require additional image
            to process the source image. The additional image is set by <see cref="P:AForge.Imaging.Filters.BaseInPlaceFilter2.OverlayImage"/>
            or <see cref="P:AForge.Imaging.Filters.BaseInPlaceFilter2.UnmanagedOverlayImage"/> property and must have the same size and pixel format
            as source image. See documentation of particular inherited class for information
            about overlay image purpose.
            </para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BaseInPlaceFilter2"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter2.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BaseInPlaceFilter2"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter2.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BaseInPlaceFilter2"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter2.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Source and overlay images have different pixel formats and/or size.</exception>
             <exception cref="T:System.NullReferenceException">Overlay image is not set.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseInPlaceFilter2.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
             
             <remarks><para>Overlay image size and pixel format is checked by this base class, before
             passing execution to inherited class.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseInPlaceFilter2.OverlayImage">
             <summary>
             Overlay image.
             </summary>
             
             <remarks>
             <para>The property sets an overlay image, which will be used as the second image required
             to process source image. See documentation of particular inherited class for information
             about overlay image purpose.
             </para>
             
             <para><note>Overlay image must have the same size and pixel format as source image.
             Otherwise exception will be generated when filter is applied to source image.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.BaseInPlaceFilter2.UnmanagedOverlayImage"/> property -
             only one overlay image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseInPlaceFilter2.UnmanagedOverlayImage">
             <summary>
             Unmanaged overlay image.
             </summary>
             
             <remarks>
             <para>The property sets an overlay image, which will be used as the second image required
             to process source image. See documentation of particular inherited class for information
             about overlay image purpose.
             </para>
             
             <para><note>Overlay image must have the same size and pixel format as source image.
             Otherwise exception will be generated when filter is applied to source image.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.BaseInPlaceFilter2.OverlayImage"/> property -
             only one overlay image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Add.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Add"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Add.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Add"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Add.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Add"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Add.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Add.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.ColorReduction.StuckiColorDithering">
             <summary>
             Color dithering using Stucki error diffusion.
             </summary>
             
             <remarks><para>The image processing routine represents color dithering algorithm, which is based on
             error diffusion dithering with Stucki coefficients. Error is diffused
             on 12 neighbor pixels with next coefficients:</para>
             <code lang="none">
                     | * | 8 | 4 |
             | 2 | 4 | 8 | 4 | 2 |
             | 1 | 2 | 4 | 2 | 1 |
             
             / 42
             </code>
             
             <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
             produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
             <see cref="P:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
             color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
             
             <para>Sample usage:</para>
             <code>
             // create color image quantization routine
             ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
             // create 64 colors table
             Color[] colorTable = ciq.CalculatePalette( image, 64 );
             // create dithering routine
             StuckiColorDithering dithering = new StuckiColorDithering( );
             dithering.ColorTable = colorTable;
             // apply the dithering routine
             Bitmap newImage = dithering.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/color_stucki.png" width="480" height="361"/>
             </remarks>
            
             <seealso cref="T:AForge.Imaging.ColorReduction.BurkesColorDithering"/>
             <seealso cref="T:AForge.Imaging.ColorReduction.FloydSteinbergColorDithering"/>
             <seealso cref="T:AForge.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering"/>
             <seealso cref="T:AForge.Imaging.ColorReduction.SierraColorDithering"/>
             
        </member>
        <member name="T:AForge.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors">
            <summary>
            Base class for error diffusion color dithering, where error is diffused to 
            adjacent neighbor pixels.
            </summary>
            
            <remarks><para>The class does error diffusion to adjacent neighbor pixels
            using specified set of coefficients. These coefficients are represented by
            2 dimensional jugged array, where first array of coefficients is for
            right-standing pixels, but the rest of arrays are for bottom-standing pixels.
            All arrays except the first one should have odd number of coefficients.</para>
            
            <para>Suppose that error diffusion coefficients are represented by the next
            jugged array:</para>
            
            <code>
            int[][] coefficients = new int[2][] {
                new int[1] { 7 },
                new int[3] { 3, 5, 1 }
            };
            </code>
            
            <para>The above coefficients are used to diffuse error over the next neighbor
            pixels (<b>*</b> marks current pixel, coefficients are placed to corresponding
            neighbor pixels):</para>
            <code lang="none">
                | * | 7 |
            | 3 | 5 | 1 |
            
            / 16
            </code>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create dithering routine
            ColorErrorDiffusionToAdjacentNeighbors dithering = new ColorErrorDiffusionToAdjacentNeighbors(
                new int[3][] {
                    new int[2] { 5, 3 },
                    new int[5] { 2, 4, 5, 4, 2 },
                    new int[3] { 2, 3, 2 }
                } );
            // apply the dithering routine
            Bitmap newImage = dithering.Apply( image );
            </code>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering">
            <summary>
            Base class for error diffusion color dithering.
            </summary>
            
            <remarks><para>The class is the base class for color dithering algorithms based on
            <a href="http://en.wikipedia.org/wiki/Error_diffusion">error diffusion</a>.</para>
            
            <para>Color dithering with error diffusion is based on the idea that each pixel from the specified source
            image is substituted with a best matching color (or better say with color's index) from the specified color
            table. However, the error (difference between color value in the source image and the best matching color)
            is diffused to neighbor pixels of the source image, which affects the way those pixels are substituted by colors
            from the specified table.</para>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
            produces 4 bpp or 8 bpp indexed image, which depends on size of the specified <see cref="P:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
            color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
            </remarks>
            
        </member>
        <member name="F:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.x">
            <summary>
            Current processing X coordinate.
            </summary>
        </member>
        <member name="F:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.y">
            <summary>
            Current processing Y coordinate.
            </summary>
        </member>
        <member name="F:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.width">
            <summary>
            Processing image's width.
            </summary>
        </member>
        <member name="F:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.height">
            <summary>
            Processing image's height.
            </summary>
        </member>
        <member name="F:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.stride">
            <summary>
            Processing image's stride (line size).
            </summary>
        </member>
        <member name="F:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.pixelSize">
            <summary>
            Processing image's pixel size in bytes.
            </summary>
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.Diffuse(System.Int32,System.Int32,System.Int32,System.Byte*)">
            <summary>
            Do error diffusion.
            </summary>
            
            <param name="rError">Error value of red component.</param>
            <param name="gError">Error value of green component.</param>
            <param name="bError">Error value of blue component.</param>
            <param name="ptr">Pointer to current processing pixel.</param>
            
            <remarks>All parameters of the image and current processing pixel's coordinates
            are initialized in protected members.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.Apply(System.Drawing.Bitmap)">
            <summary>
            Perform color dithering for the specified image.
            </summary>
            
            <param name="sourceImage">Source image to do color dithering for.</param>
            
            <returns>Returns color dithered image. See <see cref="P:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable"/> for information about format of
            the result image.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. It must 24 or 32 bpp color image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.Apply(AForge.Imaging.UnmanagedImage)">
            <summary>
            Perform color dithering for the specified image.
            </summary>
            
            <param name="sourceImage">Source image to do color dithering for.</param>
            
            <returns>Returns color dithered image. See <see cref="P:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable"/> for information about format of
            the result image.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. It must 24 or 32 bpp color image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">
            <summary>
            Color table to use for image dithering. Must contain 2-256 colors.
            </summary>
            
            <remarks><para>Color table size determines format of the resulting image produced by this
            image processing routine. If color table contains 16 color or less, then result image will have
            4 bpp indexed pixel format. If color table contains more than 16 colors, then result image will
            have 8 bpp indexed pixel format.</para>
            
            <para>By default the property is initialized with default 16 colors, which are:
            Black, Dark Blue, Dark Green, Dark Cyan, Dark Red, Dark Magenta, Dark Khaki, Light Gray,
            Gray, Blue, Green, Cyan, Red, Magenta, Yellow and White.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Color table length must be in the [2, 256] range.</exception>
            
        </member>
        <member name="P:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.UseCaching">
            <summary>
            Use color caching during color dithering or not.
            </summary>
            
            <remarks><para>The property  specifies if internal cache of already processed colors should be used or not.
            For each pixel in the original image the color dithering routine does search in target color palette to find
            the best matching color. To avoid doing the search again and again for already processed colors, the class may
            use internal dictionary which maps colors of original image to indexes in target color palette.
            </para>
            
            <para><note>The property provides a trade off. On one hand it may speedup color dithering routine, but on another
            hand it increases memory usage. Also cache usage may not be efficient for very small target color tables.</note></para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors.#ctor(System.Int32[][])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors"/> class.
            </summary>
            
            <param name="coefficients">Diffusion coefficients (see <see cref="T:AForge.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors"/>
            for more information).</param>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors.Diffuse(System.Int32,System.Int32,System.Int32,System.Byte*)">
            <summary>
            Do error diffusion.
            </summary>
            
            <param name="rError">Error value of red component.</param>
            <param name="gError">Error value of green component.</param>
            <param name="bError">Error value of blue component.</param>
            <param name="ptr">Pointer to current processing pixel.</param>
            
            <remarks>All parameters of the image and current processing pixel's coordinates
            are initialized by base class.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors.Coefficients">
            <summary>
            Diffusion coefficients.
            </summary>
            
            <remarks>Set of coefficients, which are used for error diffusion to
            pixel's neighbors.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.StuckiColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ColorReduction.StuckiColorDithering"/> class.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.ColorReduction.IColorQuantizer">
            <summary>
            Interface which is implemented by different color quantization algorithms.
            </summary>
            
            <remarks><para>The interface defines set of methods, which are to be implemented by different
            color quantization algorithms - algorithms which are aimed to provide reduced color table/palette
            for a color image.</para>
            
            <para>See documentation to particular implementation of the interface for additional information
            about the algorithm.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.IColorQuantizer.AddColor(System.Drawing.Color)">
            <summary>
            Process color by a color quantization algorithm.
            </summary>
            
            <param name="color">Color to process.</param>
            
            <remarks><para>Depending on particular implementation of <see cref="T:AForge.Imaging.ColorReduction.IColorQuantizer"/> interface,
            this method may simply process the specified color or store it in internal list for
            later color palette calculation.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.IColorQuantizer.GetPalette(System.Int32)">
             <summary>
             Get palette of the specified size.
             </summary>
             
             <param name="colorCount">Palette size to return.</param>
             
             <returns>Returns reduced color palette for the accumulated/processed colors.</returns>
             
             <remarks><para>The method must be called after continuously calling <see cref="M:AForge.Imaging.ColorReduction.IColorQuantizer.AddColor(System.Drawing.Color)"/> method and
             returns reduced color palette for colors accumulated/processed so far.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.IColorQuantizer.Clear">
            <summary>
            Clear internals of the algorithm, like accumulated color table, etc.
            </summary>
            
            <remarks><para>The methods resets internal state of a color quantization algorithm returning
            it to initial state.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.ColorReduction.FloydSteinbergColorDithering">
            <summary>
            Color dithering using Floyd-Steinberg error diffusion.
            </summary>
            
            <remarks><para>The image processing routine represents color dithering algorithm, which is based on
            error diffusion dithering with <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering">Floyd-Steinberg</a>
            coefficients. Error is diffused on 4 neighbor pixels with the next coefficients:</para>
            
            <code lang="none">
                | * | 7 |
            | 3 | 5 | 1 |
            
            / 16
            </code>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
            produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
            <see cref="P:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
            color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
            
            <para>Sample usage:</para>
            <code>
            // create color image quantization routine
            ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
            // create 16 colors table
            Color[] colorTable = ciq.CalculatePalette( image, 16 );
            // create dithering routine
            FloydSteinbergColorDithering dithering = new FloydSteinbergColorDithering( );
            dithering.ColorTable = colorTable;
            // apply the dithering routine
            Bitmap newImage = dithering.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/color_floyd_steinberg.png" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.ColorReduction.BurkesColorDithering"/>
            <seealso cref="T:AForge.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering"/>
            <seealso cref="T:AForge.Imaging.ColorReduction.SierraColorDithering"/>
            <seealso cref="T:AForge.Imaging.ColorReduction.StuckiColorDithering"/>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.FloydSteinbergColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ColorReduction.FloydSteinbergColorDithering"/> class.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.TemplateMatch">
            <summary>
            Template match class keeps information about found template match. The class is
            used with template matching algorithms implementing <see cref="T:AForge.Imaging.ITemplateMatching"/>
            interface.
            </summary>
        </member>
        <member name="M:AForge.Imaging.TemplateMatch.#ctor(System.Drawing.Rectangle,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.TemplateMatch"/> class.
            </summary>
            
            <param name="rect">Rectangle of the matching area.</param>
            <param name="similarity">Similarity between template and found matching, [0..1].</param>
            
        </member>
        <member name="P:AForge.Imaging.TemplateMatch.Rectangle">
            <summary>
            Rectangle of the matching area.
            </summary>
        </member>
        <member name="P:AForge.Imaging.TemplateMatch.Similarity">
            <summary>
            Similarity between template and found matching, [0..1].
            </summary>
        </member>
        <member name="T:AForge.Imaging.SusanCornersDetector">
            <summary>
            Susan corners detector.
            </summary>
            
            <remarks><para>The class implements Susan corners detector, which is described by
            S.M. Smith in: <b>S.M. Smith, "SUSAN - a new approach to low level image processing",
            Internal Technical Report TR95SMS1, Defense Research Agency, Chobham Lane, Chertsey,
            Surrey, UK, 1995</b>.</para>
            
            <para><note>Some implementation notes:
            <list type="bullet">
            <item>Analyzing each pixel and searching for its USAN area, the 7x7 mask is used,
            which is comprised of 37 pixels. The mask has circle shape:
            <code lang="none">
              xxx
             xxxxx
            xxxxxxx
            xxxxxxx
            xxxxxxx
             xxxxx
              xxx
            </code>
            </item>
            <item>In the case if USAN's center of mass has the same coordinates as nucleus
            (central point), the pixel is not a corner.</item>
            <item>For noise suppression the 5x5 square window is used.</item></list></note></para>
            
            <para>The class processes only grayscale 8 bpp and color 24/32 bpp images.
            In the case of color image, it is converted to grayscale internally using
            <see cref="T:AForge.Imaging.Filters.GrayscaleBT709"/> filter.</para>
            
            <para>Sample usage:</para>
            <code>
            // create corners detector's instance
            SusanCornersDetector scd = new SusanCornersDetector( );
            // process image searching for corners
            List&lt;IntPoint&gt; corners = scd.ProcessImage( image );
            // process points
            foreach ( IntPoint corner in corners )
            {
                // ... 
            }
            </code>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.MoravecCornersDetector"/>
            
        </member>
        <member name="M:AForge.Imaging.SusanCornersDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.SusanCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.SusanCornersDetector.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.SusanCornersDetector"/> class.
            </summary>
            
            <param name="differenceThreshold">Brightness difference threshold.</param>
            <param name="geometricalThreshold">Geometrical threshold.</param>
            
        </member>
        <member name="M:AForge.Imaging.SusanCornersDetector.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="image">Source image to process.</param>
            
            <returns>Returns list of found corners (X-Y coordinates).</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.SusanCornersDetector.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            
            <returns>Returns list of found corners (X-Y coordinates).</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.SusanCornersDetector.ProcessImage(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process image looking for corners.
             </summary>
             
             <param name="image">Unmanaged source image to process.</param>
             
             <returns>Returns array of found corners (X-Y coordinates).</returns>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
             
        </member>
        <member name="P:AForge.Imaging.SusanCornersDetector.DifferenceThreshold">
            <summary>
            Brightness difference threshold.
            </summary>
            
            <remarks><para>The brightness difference threshold controls the amount
            of pixels, which become part of USAN area. If difference between central
            pixel (nucleus) and surrounding pixel is not higher than difference threshold,
            then that pixel becomes part of USAN.</para>
            
            <para>Increasing this value decreases the amount of detected corners.</para>
            
            <para>Default value is set to <b>25</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.SusanCornersDetector.GeometricalThreshold">
            <summary>
            Geometrical threshold.
            </summary>
            
            <remarks><para>The geometrical threshold sets the maximum number of pixels
            in USAN area around corner. If potential corner has USAN with more pixels, than
            it is not a corner.</para>
            
            <para> Decreasing this value decreases the amount of detected corners - only sharp corners
            are detected. Increasing this value increases the amount of detected corners, but
            also increases amount of flat corners, which may be not corners at all.</para>
            
            <para>Default value is set to <b>18</b>, which is half of maximum amount of pixels in USAN.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.RotateBilinear">
             <summary>
             Rotate image using bilinear interpolation.
             </summary>
             
             <para><note>Rotation is performed in counterclockwise direction.</note></para>
             
             <remarks><para>The class implements image rotation filter using bilinear
             interpolation algorithm.</para>
             
             <para>The filter accepts 8 bpp grayscale images and 24 bpp
             color images for processing.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter - rotate for 30 degrees keeping original image size
             RotateBilinear filter = new RotateBilinear( 30, true );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample9.png" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/rotate_bilinear.png" width="320" height="240"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.RotateNearestNeighbor"/>
             <seealso cref="T:AForge.Imaging.Filters.RotateBicubic"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.RotateBilinear.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.RotateBilinear"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            
            <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.BaseRotateFilter.KeepSize"/> property
            to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.RotateBilinear.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.RotateBilinear"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            <param name="keepSize">Keep image size or not.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.RotateBilinear.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="sourceData">Source image data.</param>
             <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.RotateBilinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.WaterWave">
            <summary>
            Simple water wave effect filter.
            </summary>
            
            <remarks><para>The image processing filter implements simple water wave effect. Using
            properties of the class, it is possible to set number of vertical/horizontal waves,
            as well as their amplitude.</para>
            
            <para>Bilinear interpolation is used to create smooth effect.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            WaterWave filter = new WaterWave( );
            filter.HorizontalWavesCount     = 10;
            filter.HorizontalWavesAmplitude = 5;
            filter.VerticalWavesCount       = 3;
            filter.VerticalWavesAmplitude   = 15;
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="img/imaging/water_wave.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BaseFilter">
            <summary>
            Base class for filters, which produce new image of the same size as a
            result of image processing.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which
            do image processing creating new image with the same size as source.
            Filters based on this class cannot be applied directly to the source
            image, which is kept unchanged.</para>
            
            <para>The base class itself does not define supported pixel formats of source
            image and resulting pixel formats of destination image. Filters inheriting from
            this base class, should specify supported pixel formats and their transformations
            overriding abstract <see cref="P:AForge.Imaging.Filters.BaseFilter.FormatTranslations"/> property.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseFilter.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseFilter.Apply(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseFilter.Apply(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:AForge.Imaging.Filters.BaseFilter.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseFilter.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.WaterWave.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.WaterWave"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.WaterWave.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.WaterWave.HorizontalWavesCount">
            <summary>
            Number of horizontal waves, [1, 10000].
            </summary>
            
            <remarks><para>Default value is set to <b>5</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.WaterWave.VerticalWavesCount">
            <summary>
            Number of vertical waves, [1, 10000].
            </summary>
            
            <remarks><para>Default value is set to <b>5</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.WaterWave.HorizontalWavesAmplitude">
            <summary>
            Amplitude of horizontal waves measured in pixels, [0, 10000].
            </summary>
            
            <remarks><para>Default value is set to <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.WaterWave.VerticalWavesAmplitude">
            <summary>
            Amplitude of vertical waves measured in pixels, [0, 10000].
            </summary>
            
            <remarks><para>Default value is set to <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.WaterWave.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.CornersMarker">
            <summary>
            Filter to mark (highlight) corners of objects.
            </summary>
            
            <remarks>
            <para>The filter highlights corners of objects on the image using provided corners
            detection algorithm.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24/32 color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create corner detector's instance
            SusanCornersDetector scd = new SusanCornersDetector( );
            // create corner maker filter
            CornersMarker filter = new CornersMarker( scd, Color.Red );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample2.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="img/imaging/susan_corners.png" width="320" height="240" />
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CornersMarker.#ctor(AForge.Imaging.ICornersDetector)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CornersMarker"/> class.
            </summary>
            
            <param name="detector">Interface of corners' detection algorithm.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CornersMarker.#ctor(AForge.Imaging.ICornersDetector,System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CornersMarker"/> class.
            </summary>
            
            <param name="detector">Interface of corners' detection algorithm.</param>
            <param name="markerColor">Marker's color used to mark corner.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CornersMarker.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CornersMarker.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.CornersMarker.MarkerColor">
            <summary>
            Color used to mark corners.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.CornersMarker.Detector">
            <summary>
            Interface of corners' detection algorithm used to detect corners.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.PointedMeanFloodFill">
            <summary>
            Flood filling with mean color starting from specified point.
            </summary>
            
            <remarks><para>The filter performs image's area filling (4 directional) starting
            from the <see cref="P:AForge.Imaging.Filters.PointedMeanFloodFill.StartingPoint">specified point</see>. It fills
            the area of the pointed color, but also fills other colors, which
            are similar to the pointed within specified <see cref="P:AForge.Imaging.Filters.PointedMeanFloodFill.Tolerance">tolerance</see>.
            The area is filled using its mean color.
            </para>
            
            <para>The filter is similar to <see cref="T:AForge.Imaging.Filters.PointedColorFloodFill"/> filter, but instead
            of filling the are with specified color, it fills the area with its mean color. This means
            that this is a two pass filter - first pass is to calculate the mean value and the second pass is to
            fill the area. Unlike to <see cref="T:AForge.Imaging.Filters.PointedColorFloodFill"/> filter, this filter has nothing
            to do in the case if zero <see cref="P:AForge.Imaging.Filters.PointedMeanFloodFill.Tolerance">tolerance</see> is specified.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            PointedMeanFloodFill filter = new PointedMeanFloodFill( );
            // configre the filter
            filter.Tolerance = Color.FromArgb( 150, 92, 92 );
            filter.StartingPoint = new IntPoint( 150, 100 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/pointed_mean_fill.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.PointedColorFloodFill"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.PointedMeanFloodFill.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.PointedMeanFloodFill"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.PointedMeanFloodFill.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.PointedMeanFloodFill.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.PointedMeanFloodFill.Tolerance">
            <summary>
            Flood fill tolerance.
            </summary>
            
            <remarks><para>The tolerance value determines the level of similarity between
            colors to fill and the pointed color. If the value is set to zero, then the
            filter does nothing, since the filling area contains only one color and its
            filling with mean is meaningless.</para>
            
            <para>The tolerance value is specified as <see cref="T:System.Drawing.Color"/>,
            where each component (R, G and B) represents tolerance for the corresponding
            component of color. This allows to set different tolerances for red, green
            and blue components.</para>
            
            <para>Default value is set to <b>(16, 16, 16)</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.PointedMeanFloodFill.StartingPoint">
            <summary>
            Point to start filling from.
            </summary>
            
            <remarks><para>The property allows to set the starting point, where filling is
            started from.</para>
            
            <remarks>Default value is set to <b>(0, 0)</b>.</remarks>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ColorFiltering">
            <summary>
            Color filtering.
            </summary>
            
            <remarks><para>The filter filters pixels inside/outside of specified RGB color range -
            it keeps pixels with colors inside/outside of specified range and fills the rest with
            <see cref="P:AForge.Imaging.Filters.ColorFiltering.FillColor">specified color</see>.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ColorFiltering filter = new ColorFiltering( );
            // set color ranges to keep
            filter.Red   = new IntRange( 100, 255 );
            filter.Green = new IntRange( 0, 75 );
            filter.Blue  = new IntRange( 0, 75 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/color_filtering.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.ChannelFiltering"/>
            <seealso cref="T:AForge.Imaging.Filters.EuclideanColorFiltering"/>
            <seealso cref="T:AForge.Imaging.Filters.HSLFiltering"/>
            <seealso cref="T:AForge.Imaging.Filters.YCbCrFiltering"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ColorFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ColorFiltering"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ColorFiltering.#ctor(AForge.IntRange,AForge.IntRange,AForge.IntRange)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ColorFiltering"/> class.
            </summary>
            
            <param name="red">Red components filtering range.</param>
            <param name="green">Green components filtering range.</param>
            <param name="blue">Blue components filtering range.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ColorFiltering.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ColorFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ColorFiltering.Red">
            <summary>
            Range of red color component.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ColorFiltering.Green">
            <summary>
            Range of green color component.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ColorFiltering.Blue">
            <summary>
            Range of blue color component.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ColorFiltering.FillColor">
            <summary>
            Fill color used to fill filtered pixels.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ColorFiltering.FillOutsideRange">
            <summary>
            Determines, if pixels should be filled inside or outside of specified
            color ranges.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/>, which means
            the filter removes colors outside of the specified range.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering">
             <summary>
             Color dithering using Jarvis, Judice and Ninke error diffusion.
             </summary>
             
             <remarks><para>The image processing routine represents color dithering algorithm, which is based on
             error diffusion dithering with Jarvis-Judice-Ninke coefficients. Error is diffused
             on 12 neighbor pixels with next coefficients:</para>
             <code lang="none">
                     | * | 7 | 5 |
             | 3 | 5 | 7 | 5 | 3 |
             | 1 | 3 | 5 | 3 | 1 |
             
             / 48
             </code>
             
             <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
             produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
             <see cref="P:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
             color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
             
             <para>Sample usage:</para>
             <code>
             // create color image quantization routine
             ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
             // create 32 colors table
             Color[] colorTable = ciq.CalculatePalette( image, 32 );
             // create dithering routine
             JarvisJudiceNinkeColorDithering dithering = new JarvisJudiceNinkeColorDithering( );
             dithering.ColorTable = colorTable;
             // apply the dithering routine
             Bitmap newImage = dithering.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/color_jarvis_judice_ninke.png" width="480" height="361"/>
             </remarks>
            
             <seealso cref="T:AForge.Imaging.ColorReduction.BurkesColorDithering"/>
             <seealso cref="T:AForge.Imaging.ColorReduction.FloydSteinbergColorDithering"/>
             <seealso cref="T:AForge.Imaging.ColorReduction.SierraColorDithering"/>
             <seealso cref="T:AForge.Imaging.ColorReduction.StuckiColorDithering"/>
             
        </member>
        <member name="M:AForge.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering"/> class.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Filters.SimpleSkeletonization">
            <summary>
            Simple skeletonization filter.
            </summary>
            
            <remarks><para>The filter build simple objects' skeletons by thinning them until
            they have one pixel wide "bones" horizontally and vertically. The filter uses
            <see cref="P:AForge.Imaging.Filters.SimpleSkeletonization.Background"/> and <see cref="P:AForge.Imaging.Filters.SimpleSkeletonization.Foreground"/> colors to distinguish
            between object and background.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SimpleSkeletonization filter = new SimpleSkeletonization( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample14.png" width="150" height="150"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/simple_skeletonization.png" width="150" height="150"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SimpleSkeletonization.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SimpleSkeletonization"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.SimpleSkeletonization.#ctor(System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SimpleSkeletonization"/> class.
            </summary>
            
            <param name="bg">Background pixel color.</param>
            <param name="fg">Foreground pixel color.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SimpleSkeletonization.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimpleSkeletonization.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimpleSkeletonization.Background">
            <summary>
            Background pixel color.
            </summary>
            
            <remarks><para>The property sets background (none object) color to look for.</para>
            
            <para>Default value is set to <b>0</b> - black.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimpleSkeletonization.Foreground">
            <summary>
            Foreground pixel color.
            </summary>
            
            <remarks><para>The property sets objects' (none background) color to look for.</para>
            
            <para>Default value is set to <b>255</b> - white.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ConnectedComponentsLabeling">
             <summary>
             Connected components labeling.
             </summary>
             
             <remarks><para>The filter performs labeling of objects in the source image. It colors
             each separate object using different color. The image processing filter treats all none
             black pixels as objects' pixels and all black pixel as background.</para>
             
             <para>The filter accepts 8 bpp grayscale images and 24/32 bpp color images and produces
             24 bpp RGB image.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter
             ConnectedComponentsLabeling filter = new ConnectedComponentsLabeling( );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             // check objects count
             int objectCount = filter.ObjectCount;
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample2.jpg" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="img/imaging/labeling.jpg" width="320" height="240" />
             </remarks>
             
        </member>
        <member name="M:AForge.Imaging.Filters.ConnectedComponentsLabeling.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ConnectedComponentsLabeling"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ConnectedComponentsLabeling.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ConnectedComponentsLabeling.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ConnectedComponentsLabeling.BlobCounter">
            <summary>
            Blob counter used to locate separate blobs.
            </summary>
            
            <remarks><para>The property allows to set blob counter to use for blobs' localization.</para>
            
            <para>Default value is set to <see cref="P:AForge.Imaging.Filters.ConnectedComponentsLabeling.BlobCounter"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ConnectedComponentsLabeling.ColorTable">
            <summary>
            Colors used to color the binary image.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ConnectedComponentsLabeling.FilterBlobs">
            <summary>
            Specifies if blobs should be filtered.
            </summary>
            
            <remarks><para>See documentation for <see cref="P:AForge.Imaging.BlobCounterBase.FilterBlobs"/> property
            of <see cref="T:AForge.Imaging.BlobCounterBase"/> class for more information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ConnectedComponentsLabeling.CoupledSizeFiltering">
            <summary>
            Specifies if size filetering should be coupled or not.
            </summary>
            
            <remarks><para>See documentation for <see cref="P:AForge.Imaging.BlobCounterBase.CoupledSizeFiltering"/> property
            of <see cref="T:AForge.Imaging.BlobCounterBase"/> class for more information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ConnectedComponentsLabeling.MinWidth">
            <summary>
            Minimum allowed width of blob.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ConnectedComponentsLabeling.MinHeight">
            <summary>
            Minimum allowed height of blob.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ConnectedComponentsLabeling.MaxWidth">
            <summary>
            Maximum allowed width of blob.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ConnectedComponentsLabeling.MaxHeight">
            <summary>
            Maximum allowed height of blob.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ConnectedComponentsLabeling.ObjectCount">
            <summary>
            Objects count.
            </summary>
            
            <remarks>The amount of objects found in the last processed image.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Morph">
            <summary>
            Morph filter.
            </summary>
            
            <remarks><para>The filter combines two images by taking
            <see cref="P:AForge.Imaging.Filters.Morph.SourcePercent">specified percent</see> of pixels' intensities from source
            image and the rest from overlay image. For example, if the
            <see cref="P:AForge.Imaging.Filters.Morph.SourcePercent">source percent</see> value is set to 0.8, then each pixel
            of the result image equals to <b>0.8 * source + 0.2 * overlay</b>, where <b>source</b>
            and <b>overlay</b> are corresponding pixels' values in source and overlay images.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Morph filter = new Morph( overlayImage );
            filter.SourcePercent = 0.75;
            // apply the filter
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="img/imaging/sample6.png" width="320" height="240"/>
            <para><b>Overlay image:</b></para>
            <img src="img/imaging/sample7.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/morph.png" width="320" height="240"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Morph.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Morph"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Morph.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Morph"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Morph.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Morph"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Morph.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Morph.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.Morph.SourcePercent">
            <summary>
            Percent of source image to keep, [0, 1].
            </summary>
            
            <remarks><para>The property specifies the percentage of source pixels' to take. The
            rest is taken from an overlay image.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.ComplexFilters.FrequencyFilter">
            <summary>
            Filtering of frequencies outside of specified range in complex Fourier
            transformed image.
            </summary>
            
            <remarks><para>The filer keeps only specified range of frequencies in complex
            Fourier transformed image. The rest of frequencies are zeroed.</para>
            
            <para>Sample usage:</para>
            <code>
            // create complex image
            ComplexImage complexImage = ComplexImage.FromBitmap( image );
            // do forward Fourier transformation
            complexImage.ForwardFourierTransform( );
            // create filter
            FrequencyFilter filter = new FrequencyFilter( new IntRange( 20, 128 ) );
            // apply filter
            filter.Apply( complexImage );
            // do backward Fourier transformation
            complexImage.BackwardFourierTransform( );
            // get complex image as bitmat
            Bitmap fourierImage = complexImage.ToBitmap( );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample3.jpg" width="256" height="256" />
            <para><b>Fourier image:</b></para>
            <img src="img/imaging/frequency_filter.jpg" width="256" height="256" />
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.ComplexFilters.IComplexFilter">
            <summary>
            Image processing filter, which operates with Fourier transformed
            complex image.
            </summary>
            
            <remarks>The interface defines the set of methods, which should be
            provided by all image processing filter, which operate with Fourier
            transformed complex image.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.ComplexFilters.IComplexFilter.Apply(AForge.Imaging.ComplexImage)">
            <summary>
            Apply filter to complex image.
            </summary>
            
            <param name="complexImage">Complex image to apply filter to.</param>
            
        </member>
        <member name="M:AForge.Imaging.ComplexFilters.FrequencyFilter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ComplexFilters.FrequencyFilter"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.ComplexFilters.FrequencyFilter.#ctor(AForge.IntRange)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ComplexFilters.FrequencyFilter"/> class.
            </summary>
            
            <param name="frequencyRange">Range of frequencies to keep.</param>
            
        </member>
        <member name="M:AForge.Imaging.ComplexFilters.FrequencyFilter.Apply(AForge.Imaging.ComplexImage)">
            <summary>
            Apply filter to complex image.
            </summary>
            
            <param name="complexImage">Complex image to apply filter to.</param>
            
            <exception cref="T:System.ArgumentException">The source complex image should be Fourier transformed.</exception>
            
        </member>
        <member name="P:AForge.Imaging.ComplexFilters.FrequencyFilter.FrequencyRange">
            <summary>
            Range of frequencies to keep.
            </summary>
            
            <remarks><para>The range specifies the range of frequencies to keep. Values is frequencies
            outside of this range are zeroed.</para>
            
            <para>Default value is set to <b>[0, 1024]</b>.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ResizeBicubic">
             <summary>
             Resize image using bicubic interpolation algorithm.
             </summary>
             
             <remarks><para>The class implements image resizing filter using bicubic
             interpolation algorithm. It uses bicubic kernel W(x) as described on
             <a href="http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm">Wikipedia</a>
             (coefficient <b>a</b> is set to <b>-0.5</b>).</para>
             
             <para>The filter accepts 8 grayscale images and 24 bpp
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             ResizeBicubic filter = new ResizeBicubic( 400, 300 );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample9.png" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/resize_bicubic.png" width="400" height="300"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.ResizeNearestNeighbor"/>
             <seealso cref="T:AForge.Imaging.Filters.ResizeBilinear"/>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BaseResizeFilter">
            <summary>
            Base class for image resizing filters.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters,
            which implement image rotation algorithms.</para>
            </remarks>
            
        </member>
        <member name="F:AForge.Imaging.Filters.BaseResizeFilter.newWidth">
            <summary>
            New image width.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.BaseResizeFilter.newHeight">
            <summary>
            New image height.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.BaseResizeFilter.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BaseResizeFilter"/> class.
            </summary>
            
            <param name="newWidth">Width of the new resized image.</param>
            <param name="newHeight">Height of the new resize image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseResizeFilter.CalculateNewImageSize(AForge.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseResizeFilter.NewWidth">
            <summary>
            Width of the new resized image.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseResizeFilter.NewHeight">
            <summary>
            Height of the new resized image.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ResizeBicubic.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ResizeBicubic"/> class.
            </summary>
            
            <param name="newWidth">Width of new image.</param>
            <param name="newHeight">Height of new image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ResizeBicubic.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ResizeBicubic.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.QuadrilateralTransformation">
            <summary>
            Performs quadrilateral transformation of an area in a given source image.
            </summary>
            
            <remarks><para>The class implements quadrilateral transformation algorithm,
            which allows to transform any quadrilateral from a given source image
            to a rectangular image. The idea of the algorithm is based on homogeneous
            transformation and its math is described by Paul Heckbert in his
            "<a href="http://graphics.cs.cmu.edu/courses/15-463/2008_fall/Papers/proj.pdf">Projective Mappings for Image Warping</a>" paper.
            </para>
            
            <para>The image processing filter accepts 8 grayscale images and 24/32 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // define quadrilateral's corners
            List&lt;IntPoint&gt; corners = new List&lt;IntPoint&gt;( );
            corners.Add( new IntPoint(  99,  99 ) );
            corners.Add( new IntPoint( 156,  79 ) );
            corners.Add( new IntPoint( 184, 126 ) );
            corners.Add( new IntPoint( 122, 150 ) );
            // create filter
            QuadrilateralTransformation filter =
                new QuadrilateralTransformation( corners, 200, 200 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample18.jpg" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/quadrilateral_ex_bilinear.png" width="200" height="200"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.BackwardQuadrilateralTransformation"/>
            <seealso cref="T:AForge.Imaging.Filters.SimpleQuadrilateralTransformation"/>
            
        </member>
        <member name="F:AForge.Imaging.Filters.QuadrilateralTransformation.newWidth">
            <summary>
            New image width.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.QuadrilateralTransformation.newHeight">
            <summary>
            New image height.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.QuadrilateralTransformation"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformation.#ctor(System.Collections.Generic.List{AForge.IntPoint},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.QuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceQuadrilateral">Corners of the source quadrilateral area.</param>
            <param name="newWidth">Width of the new transformed image.</param>
            <param name="newHeight">Height of the new transformed image.</param>
            
            <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformation.AutomaticSizeCalculaton"/> to
            <see langword="false"/>, which means that destination image will have width and
            height as specified by user.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformation.#ctor(System.Collections.Generic.List{AForge.IntPoint})">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.QuadrilateralTransformation"/> class.
             </summary>
             
             <param name="sourceQuadrilateral">Corners of the source quadrilateral area.</param>
             
             <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformation.AutomaticSizeCalculaton"/> to
             <see langword="true"/>, which means that destination image will have width and
             height automatically calculated based on <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformation.SourceQuadrilateral"/> property.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformation.CalculateNewImageSize(AForge.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
            <exception cref="T:System.NullReferenceException">Source quadrilateral was not set.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformation.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformation.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformation.AutomaticSizeCalculaton">
            <summary>
            Automatic calculation of destination image or not.
            </summary>
            
            <remarks><para>The property specifies how to calculate size of destination (transformed)
            image. If the property is set to <see langword="false"/>, then <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformation.NewWidth"/>
            and <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformation.NewHeight"/> properties have effect and destination image's size is
            specified by user. If the property is set to <see langword="true"/>, then setting the above
            mentioned properties does not have any effect, but destionation image's size is
            automatically calculated from <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformation.SourceQuadrilateral"/> property - width and height
            come from length of longest edges.
            </para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformation.SourceQuadrilateral">
            <summary>
            Quadrilateral's corners in source image.
            </summary>
            
            <remarks><para>The property specifies four corners of the quadrilateral area
            in the source image to be transformed.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformation.NewWidth">
            <summary>
            Width of the new transformed image.
            </summary>
            
            <remarks><para>The property defines width of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformation.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's width
            is calculated automatically based on <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformation.SourceQuadrilateral"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformation.NewHeight">
            <summary>
            Height of the new transformed image.
            </summary>
            
            <remarks><para>The property defines height of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformation.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's height
            is calculated automatically based on <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformation.SourceQuadrilateral"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformation.UseInterpolation">
            <summary>
            Specifies if bilinear interpolation should be used or not.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/> - interpolation
            is used.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.SaturationCorrection">
            <summary>
            Saturation adjusting in HSL color space.
            </summary>
            
            <remarks><para>The filter operates in <b>HSL</b> color space and adjusts
            pixels' saturation value, increasing it or decreasing by specified percentage.
            The filters is based on <see cref="T:AForge.Imaging.Filters.HSLLinear"/> filter, passing work to it after
            recalculating saturation <see cref="P:AForge.Imaging.Filters.SaturationCorrection.AdjustValue">adjust value</see> to input/output
            ranges of the <see cref="T:AForge.Imaging.Filters.HSLLinear"/> filter.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SaturationCorrection filter = new SaturationCorrection( -0.5f );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/saturation_correction.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SaturationCorrection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SaturationCorrection"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SaturationCorrection.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SaturationCorrection"/> class.
            </summary>
            
            <param name="adjustValue">Saturation adjust value.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SaturationCorrection.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SaturationCorrection.AdjustValue">
            <summary>
            Saturation adjust value, [-1, 1].
            </summary>
            
            <remarks>Default value is set to <b>0.1</b>, which corresponds to increasing
            saturation by 10%.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SaturationCorrection.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.Convolution">
            <summary>
            Convolution filter.
            </summary>
            
            <remarks><para>The filter implements convolution operator, which calculates each pixel
            of the result image as weighted sum of the correspond pixel and its neighbors in the source
            image. The weights are set by <see cref="P:AForge.Imaging.Filters.Convolution.Kernel">convolution kernel</see>. The weighted
            sum is divided by <see cref="P:AForge.Imaging.Filters.Convolution.Divisor"/> before putting it into result image and also
            may be thresholded using <see cref="P:AForge.Imaging.Filters.Convolution.Threshold"/> value.</para>
            
            <para>Convolution is a simple mathematical operation which is fundamental to many common
            image processing filters. Depending on the type of provided kernel, the filter may produce
            different results, like blur image, sharpen it, find edges, etc.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing. Note: depending on the value of <see cref="P:AForge.Imaging.Filters.Convolution.ProcessAlpha"/>
            property, the alpha channel is either copied as is or processed with the kernel.</para>
            
            <para>Sample usage:</para>
            <code>
            // define emboss kernel
            int[,] kernel = {
                        { -2, -1,  0 },
                        { -1,  1,  1 },
                        {  0,  1,  2 } };
            // create filter
            Convolution filter = new Convolution( kernel );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample5.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/emboss.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Convolution.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Convolution"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Convolution.#ctor(System.Int32[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Convolution"/> class.
            </summary>
            
            <param name="kernel">Convolution kernel.</param>
            
            <remarks><para>Using this constructor (specifying only convolution kernel),
            <see cref="P:AForge.Imaging.Filters.Convolution.Divisor">division factor</see> will be calculated automatically
            summing all kernel values. In the case if kernel's sum equals to zero,
            division factor will be assigned to 1.</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid kernel size is specified. Kernel must be
            square, its width/height should be odd and should be in the [3, 25] range.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Convolution.#ctor(System.Int32[0:,0:],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Convolution"/> class.
            </summary>
            
            <param name="kernel">Convolution kernel.</param>
            <param name="divisor">Divisor, used used to divide weighted sum.</param>
            
            <exception cref="T:System.ArgumentException">Invalid kernel size is specified. Kernel must be
            square, its width/height should be odd and should be in the [3, 25] range.</exception>
            <exception cref="T:System.ArgumentException">Divisor can not be equal to zero.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Convolution.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Convolution.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.Convolution.Kernel">
            <summary>
            Convolution kernel.
            </summary>
            
            <remarks>
            <para><note>Convolution kernel must be square and its width/height
            should be odd and should be in the [3, 99] range.</note></para>
            
            <para><note>Setting convolution kernel through this property does not
            affect <see cref="P:AForge.Imaging.Filters.Convolution.Divisor"/> - it is not recalculated automatically.</note></para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Invalid kernel size is specified.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Convolution.Divisor">
            <summary>
            Division factor.
            </summary>
            
            <remarks><para>The value is used to divide convolution - weighted sum
            of pixels is divided by this value.</para>
            
            <para><note>The value may be calculated automatically in the case if constructor
            with one parameter is used (<see cref="M:AForge.Imaging.Filters.Convolution.#ctor(System.Int32[0:,0:])"/>).</note></para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Divisor can not be equal to zero.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Convolution.Threshold">
            <summary>
            Threshold to add to weighted sum.
            </summary>
            
            <remarks><para>The property specifies threshold value, which is added to each weighted
            sum of pixels. The value is added right after division was done by <see cref="P:AForge.Imaging.Filters.Convolution.Divisor"/>
            value.</para>
            
            <para>Default value is set to <b>0</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Convolution.DynamicDivisorForEdges">
            <summary>
            Use dynamic divisor for edges or not.
            </summary>
            
            <remarks><para>The property specifies how to handle edges. If it is set to
            <see langword="false"/>, then the same divisor (which is specified by <see cref="P:AForge.Imaging.Filters.Convolution.Divisor"/>
            property or calculated automatically) will be applied both for non-edge regions
            and for edge regions. If the value is set to <see langword="true"/>, then dynamically
            calculated divisor will be used for edge regions, which is sum of those kernel
            elements, which are taken into account for particular processed pixel
            (elements, which are not outside image).</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Convolution.ProcessAlpha">
            <summary>
            Specifies if alpha channel must be processed or just copied.
            </summary>
            
            <remarks><para>The property specifies the way how alpha channel is handled for 32 bpp
            and 64 bpp images. If the property is set to <see langword="false"/>, then alpha
            channel's values are just copied as is. If the property is set to <see langword="true"/>
            then alpha channel is convolved using the specified kernel same way as RGB channels.</para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.GrayscaleToRGB">
            <summary>
            Convert grayscale image to RGB.
            </summary>
            
            <remarks><para>The filter creates color image from specified grayscale image
            initializing all RGB channels to the same value - pixel's intensity of grayscale image.</para>
            
            <para>The filter accepts 8 bpp grayscale images and produces
            24 bpp RGB image.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            GrayscaleToRGB filter = new GrayscaleToRGB( );
            // apply the filter
            Bitmap rgbImage = filter.Apply( image );
            </code>
            
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GrayscaleToRGB.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GrayscaleToRGB"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GrayscaleToRGB.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.GrayscaleToRGB.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.BradleyLocalThresholding">
            <summary>
            Adaptive thresholding using the internal image.
            </summary>
            
            <remarks><para>The image processing routine implements local thresholding technique described
            by Derek Bradley and Gerhard Roth in the "Adaptive Thresholding Using the Integral Image" paper.
            </para>
            
            <para>The brief idea of the algorithm is that every image's pixel is set to black if its brightness
            is <i>t</i> percent lower (see <see cref="P:AForge.Imaging.Filters.BradleyLocalThresholding.PixelBrightnessDifferenceLimit"/>) than the average brightness
            of surrounding pixels in the window of the specified size (see <see cref="P:AForge.Imaging.Filters.BradleyLocalThresholding.WindowSize"/>), othwerwise it is set
            to white.</para>
            
            <para>Sample usage:</para>
            <code>
            // create the filter
            BradleyLocalThresholding filter = new BradleyLocalThresholding( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample20.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/bradley_local_thresholding.png" width="320" height="240"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BradleyLocalThresholding.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BradleyLocalThresholding"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BradleyLocalThresholding.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BradleyLocalThresholding.WindowSize">
            <summary>
            Window size to calculate average value of pixels for.
            </summary>
            
            <remarks><para>The property specifies window size around processing pixel, which determines number of
            neighbor pixels to use for calculating their average brightness.</para>
            
            <para>Default value is set to <b>41</b>.</para>
            
            <para><note>The value should be odd.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BradleyLocalThresholding.PixelBrightnessDifferenceLimit">
             <summary>
             Brightness difference limit between processing pixel and average value across neighbors.
             </summary>
            
             <remarks><para>The property specifies what is the allowed difference percent between processing pixel
             and average brightness of neighbor pixels in order to be set white. If the value of the
             current pixel is <i>t</i> percent (this property value) lower than the average then it is set
             to black, otherwise it is set to white. </para>
             
             <para>Default value is set to <b>0.15</b>.</para>
             </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BradleyLocalThresholding.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.IntegralImage">
            <summary>
            Integral image.
            </summary>
            
            <remarks><para>The class implements integral image concept, which is described by
            Viola and Jones in: <b>P. Viola and M. J. Jones, "Robust real-time face detection",
            Int. Journal of Computer Vision 57(2), pp. 137–154, 2004</b>.</para>
            
            <para><i>"An integral image <b>I</b> of an input image <b>G</b> is defined as the image in which the
            intensity at a pixel position is equal to the sum of the intensities of all the pixels
            above and to the left of that position in the original image."</i></para>
            
            <para>The intensity at position (x, y) can be written as:</para>
            <code>
                      x    y
            I(x,y) = SUM( SUM( G(i,j) ) )
                     i=0  j=0
            </code>
            
            <para><note>The class uses 32-bit integers to represent integral image.</note></para>
            
            <para><note>The class processes only grayscale (8 bpp indexed) images.</note></para>
            
            <para><note>This class contains two versions of each method: safe and unsafe. Safe methods do
            checks of provided coordinates and ensure that these coordinates belong to the image, what makes
            these methods slower. Unsafe methods do not do coordinates' checks and rely that these
            coordinates belong to the image, what makes these methods faster.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create integral image
            IntegralImage im = IntegralImage.FromBitmap( image );
            // get pixels' mean value in the specified rectangle
            float mean = im.GetRectangleMean( 10, 10, 20, 30 )
            </code>
            </remarks>
            
        </member>
        <member name="F:AForge.Imaging.IntegralImage.integralImage">
            <summary>
            Intergral image's array.
            </summary>
            
            <remarks>See remarks to <see cref="P:AForge.Imaging.IntegralImage.InternalData"/> property.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.#ctor(System.Int32,System.Int32)">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.IntegralImage"/> class.
             </summary>
             
             <param name="width">Image width.</param>
             <param name="height">Image height.</param>
             
             <remarks>The constractor is protected, what makes it imposible to instantiate this
             class directly. To create an instance of this class <see cref="M:AForge.Imaging.IntegralImage.FromBitmap(System.Drawing.Bitmap)"/> or
             <see cref="M:AForge.Imaging.IntegralImage.FromBitmap(System.Drawing.Imaging.BitmapData)"/> method should be used.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.FromBitmap(System.Drawing.Bitmap)">
            <summary>
            Construct integral image from source grayscale image.
            </summary>
            
            <param name="image">Source grayscale image.</param>
            
            <returns>Returns integral image.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.FromBitmap(System.Drawing.Imaging.BitmapData)">
            <summary>
            Construct integral image from source grayscale image.
            </summary>
            
            <param name="imageData">Source image data.</param>
            
            <returns>Returns integral image.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.FromBitmap(AForge.Imaging.UnmanagedImage)">
            <summary>
            Construct integral image from source grayscale image.
            </summary>
            
            <param name="image">Source unmanaged image.</param>
            
            <returns>Returns integral image.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.GetRectangleSum(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate sum of pixels in the specified rectangle.
            </summary>
            
            <param name="x1">X coordinate of left-top rectangle's corner.</param>
            <param name="y1">Y coordinate of left-top rectangle's corner.</param>
            <param name="x2">X coordinate of right-bottom rectangle's corner.</param>
            <param name="y2">Y coordinate of right-bottom rectangle's corner.</param>
            
            <returns>Returns sum of pixels in the specified rectangle.</returns>
            
            <remarks><para>Both specified points are included into the calculation rectangle.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.GetHaarXWavelet(System.Int32,System.Int32,System.Int32)">
             <summary>
             Calculate horizontal (X) haar wavelet at the specified point.
             </summary>
             
             <param name="x">X coordinate of the point to calculate wavelet at.</param>
             <param name="y">Y coordinate of the point to calculate wavelet at.</param>
             <param name="radius">Wavelet size to calculate.</param>
             
             <returns>Returns value of the horizontal wavelet at the specified point.</returns>
            
             <remarks><para>The method calculates horizontal wavelet, which is a difference
             of two horizontally adjacent boxes' sums, i.e. <b>A-B</b>. A is the sum of rectangle with coordinates
             (x, y-radius, x+radius-1, y+radius-1). B is the sum of rectangle with coordinates
             (x-radius, y-radius, x-1, y+radiys-1).</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.GetHaarYWavelet(System.Int32,System.Int32,System.Int32)">
             <summary>
             Calculate vertical (Y) haar wavelet at the specified point.
             </summary>
             
             <param name="x">X coordinate of the point to calculate wavelet at.</param>
             <param name="y">Y coordinate of the point to calculate wavelet at.</param>
             <param name="radius">Wavelet size to calculate.</param>
             
             <returns>Returns value of the vertical wavelet at the specified point.</returns>
            
             <remarks><para>The method calculates vertical wavelet, which is a difference
             of two vertical adjacent boxes' sums, i.e. <b>A-B</b>. A is the sum of rectangle with coordinates
             (x-radius, y, x+radius-1, y+radius-1). B is the sum of rectangle with coordinates
             (x-radius, y-radius, x+radius-1, y-1).</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.GetRectangleSumUnsafe(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate sum of pixels in the specified rectangle without checking it's coordinates.
            </summary>
            
            <param name="x1">X coordinate of left-top rectangle's corner.</param>
            <param name="y1">Y coordinate of left-top rectangle's corner.</param>
            <param name="x2">X coordinate of right-bottom rectangle's corner.</param>
            <param name="y2">Y coordinate of right-bottom rectangle's corner.</param>
            
            <returns>Returns sum of pixels in the specified rectangle.</returns>
            
            <remarks><para>Both specified points are included into the calculation rectangle.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.GetRectangleSum(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate sum of pixels in the specified rectangle.
            </summary>
            
            <param name="x">X coordinate of central point of the rectangle.</param>
            <param name="y">Y coordinate of central point of the rectangle.</param>
            <param name="radius">Radius of the rectangle.</param>
            
            <returns>Returns sum of pixels in the specified rectangle.</returns>
            
            <remarks><para>The method calculates sum of pixels in square rectangle with
            odd width and height. In the case if it is required to calculate sum of
            3x3 rectangle, then it is required to specify its center and radius equal to 1.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.GetRectangleSumUnsafe(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate sum of pixels in the specified rectangle without checking it's coordinates.
            </summary>
            
            <param name="x">X coordinate of central point of the rectangle.</param>
            <param name="y">Y coordinate of central point of the rectangle.</param>
            <param name="radius">Radius of the rectangle.</param>
            
            <returns>Returns sum of pixels in the specified rectangle.</returns>
            
            <remarks><para>The method calculates sum of pixels in square rectangle with
            odd width and height. In the case if it is required to calculate sum of
            3x3 rectangle, then it is required to specify its center and radius equal to 1.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.GetRectangleMean(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate mean value of pixels in the specified rectangle.
            </summary>
            
            <param name="x1">X coordinate of left-top rectangle's corner.</param>
            <param name="y1">Y coordinate of left-top rectangle's corner.</param>
            <param name="x2">X coordinate of right-bottom rectangle's corner.</param>
            <param name="y2">Y coordinate of right-bottom rectangle's corner.</param>
            
            <returns>Returns mean value of pixels in the specified rectangle.</returns>
            
            <remarks>Both specified points are included into the calculation rectangle.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.GetRectangleMeanUnsafe(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate mean value of pixels in the specified rectangle without checking it's coordinates.
            </summary>
            
            <param name="x1">X coordinate of left-top rectangle's corner.</param>
            <param name="y1">Y coordinate of left-top rectangle's corner.</param>
            <param name="x2">X coordinate of right-bottom rectangle's corner.</param>
            <param name="y2">Y coordinate of right-bottom rectangle's corner.</param>
            
            <returns>Returns mean value of pixels in the specified rectangle.</returns>
            
            <remarks>Both specified points are included into the calculation rectangle.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.GetRectangleMean(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate mean value of pixels in the specified rectangle.
            </summary>
            
            <param name="x">X coordinate of central point of the rectangle.</param>
            <param name="y">Y coordinate of central point of the rectangle.</param>
            <param name="radius">Radius of the rectangle.</param>
            
            <returns>Returns mean value of pixels in the specified rectangle.</returns>
            
            <remarks>The method calculates mean value of pixels in square rectangle with
            odd width and height. In the case if it is required to calculate mean value of
            3x3 rectangle, then it is required to specify its center and radius equal to 1.
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.IntegralImage.GetRectangleMeanUnsafe(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate mean value of pixels in the specified rectangle without checking it's coordinates.
            </summary>
            
            <param name="x">X coordinate of central point of the rectangle.</param>
            <param name="y">Y coordinate of central point of the rectangle.</param>
            <param name="radius">Radius of the rectangle.</param>
            
            <returns>Returns mean value of pixels in the specified rectangle.</returns>
            
            <remarks>The method calculates mean value of pixels in square rectangle with
            odd width and height. In the case if it is required to calculate mean value of
            3x3 rectangle, then it is required to specify its center and radius equal to 1.
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.IntegralImage.Width">
            <summary>
            Width of the source image the integral image was constructed for.
            </summary>
        </member>
        <member name="P:AForge.Imaging.IntegralImage.Height">
            <summary>
            Height of the source image the integral image was constructed for.
            </summary>
        </member>
        <member name="P:AForge.Imaging.IntegralImage.InternalData">
            <summary>
            Provides access to internal array keeping integral image data.
            </summary>
            
            <remarks>
            <para><note>The array should be accessed by [y, x] indexing.</note></para>
            
            <para><note>The array's size is [<see cref="P:AForge.Imaging.IntegralImage.Height"/>+1, <see cref="P:AForge.Imaging.IntegralImage.Width"/>+1]. The first
            row and column are filled with zeros, what is done for more efficient calculation of
            rectangles' sums.</note></para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.ImageStatistics">
            <summary>
            Gather statistics about image in RGB color space.
            </summary>
            
            <remarks><para>The class is used to accumulate statistical values about images,
            like histogram, mean, standard deviation, etc. for each color channel in RGB color
            space.</para>
            
            <para>The class accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // gather statistics
            ImageStatistics stat = new ImageStatistics( image );
            // get red channel's histogram
            Histogram red = stat.Red;
            // check mean value of red channel
            if ( red.Mean &gt; 128 )
            {
                // do further processing
            }
            </code>
            </remarks>
            
            <seealso cref="T:AForge.Math.Histogram"/>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatistics.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatistics.#ctor(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatistics.#ctor(System.Drawing.Bitmap,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatistics.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Unmanaged image to gather statistics about.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatistics.#ctor(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatistics.#ctor(AForge.Imaging.UnmanagedImage,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatistics.Red">
            <summary>
            Histogram of red channel.
            </summary>
            
            <remarks><para><note>The property is valid only for color images
            (see <see cref="P:AForge.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatistics.Green">
            <summary>
            Histogram of green channel.
            </summary>
            
            <remarks><para><note>The property is valid only for color images
            (see <see cref="P:AForge.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatistics.Blue">
            <summary>
            Histogram of blue channel.
            </summary>
            
            <remarks><para><note>The property is valid only for color images
            (see <see cref="P:AForge.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatistics.Gray">
            <summary>
            Histogram of gray channel.
            </summary>
            
            <remarks><para><note>The property is valid only for grayscale images
            (see <see cref="P:AForge.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatistics.RedWithoutBlack">
            <summary>
            Histogram of red channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about red channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            
            <para><note>The property is valid only for color images
            (see <see cref="P:AForge.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatistics.GreenWithoutBlack">
            <summary>
            Histogram of green channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about green channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            
            <para><note>The property is valid only for color images
            (see <see cref="P:AForge.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatistics.BlueWithoutBlack">
            <summary>
            Histogram of blue channel excluding black pixels
            </summary>
            
            <remarks><para>The property keeps statistics about blue channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            
            <para><note>The property is valid only for color images
            (see <see cref="P:AForge.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatistics.GrayWithoutBlack">
            <summary>
            Histogram of gray channel channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about gray channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            
            <para><note>The property is valid only for grayscale images
            (see <see cref="P:AForge.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatistics.PixelsCount">
            <summary>
            Total pixels count in the processed image.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatistics.PixelsCountWithoutBlack">
            <summary>
            Total pixels count in the processed image excluding black pixels.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatistics.IsGrayscale">
            <summary>
            Value wich specifies if the processed image was color or grayscale.
            </summary>
            
            <remarks><para>If the value is set to <see langword="true"/> then <see cref="P:AForge.Imaging.ImageStatistics.Gray"/>
            property should be used to get statistics information about image. Otherwise
            <see cref="P:AForge.Imaging.ImageStatistics.Red"/>, <see cref="P:AForge.Imaging.ImageStatistics.Green"/> and <see cref="P:AForge.Imaging.ImageStatistics.Blue"/> properties should be used
            for color images.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.HorizontalIntensityStatistics">
            <summary>
            Horizontal intensity statistics.
            </summary>
            
            <remarks><para>The class provides information about horizontal distribution
            of pixel intensities, which may be used to locate objects, their centers, etc.
            </para>
            
            <para>The class accepts grayscale (8 bpp indexed and 16 bpp) and color (24, 32, 48 and 64 bpp) images.
            In the case of 32 and 64 bpp color images, the alpha channel is not processed - statistics is not
            gathered for this channel.</para>
            
            <para>Sample usage:</para>
            <code>
            // collect statistics
            HorizontalIntensityStatistics his = new HorizontalIntensityStatistics( sourceImage );
            // get gray histogram (for grayscale image)
            Histogram histogram = his.Gray;
            // output some histogram's information
            System.Diagnostics.Debug.WriteLine( "Mean = " + histogram.Mean );
            System.Diagnostics.Debug.WriteLine( "Min = " + histogram.Min );
            System.Diagnostics.Debug.WriteLine( "Max = " + histogram.Max );
            </code>
            
            <para><b>Sample grayscale image with its horizontal intensity histogram:</b></para>
            <img src="img/imaging/hor_histogram.jpg" width="320" height="338"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.VerticalIntensityStatistics"/>
            
        </member>
        <member name="M:AForge.Imaging.HorizontalIntensityStatistics.#ctor(System.Drawing.Bitmap)">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.HorizontalIntensityStatistics"/> class.
             </summary>
             
             <param name="image">Source image.</param>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:AForge.Imaging.HorizontalIntensityStatistics.#ctor(System.Drawing.Imaging.BitmapData)">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.HorizontalIntensityStatistics"/> class.
             </summary>
             
             <param name="imageData">Source image data.</param>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:AForge.Imaging.HorizontalIntensityStatistics.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.HorizontalIntensityStatistics"/> class.
            </summary>
            
            <param name="image">Source unmanaged image.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HorizontalIntensityStatistics.ProcessImage(AForge.Imaging.UnmanagedImage)">
            <summary>
            Gather horizontal intensity statistics for specified image.
            </summary>
            
            <param name="image">Source image.</param>
            
        </member>
        <member name="P:AForge.Imaging.HorizontalIntensityStatistics.Red">
            <summary>
            Histogram for red channel.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.HorizontalIntensityStatistics.Green">
            <summary>
            Histogram for green channel.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.HorizontalIntensityStatistics.Blue">
            <summary>
            Histogram for blue channel.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.HorizontalIntensityStatistics.Gray">
            <summary>
            Histogram for gray channel (intensities).
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.HorizontalIntensityStatistics.IsGrayscale">
            <summary>
            Value wich specifies if the processed image was color or grayscale.
            </summary>
            
            <remarks><para>If the property equals to <b>true</b>, then the <see cref="P:AForge.Imaging.HorizontalIntensityStatistics.Gray"/>
            property should be used to retrieve histogram for the processed grayscale image.
            Otherwise <see cref="P:AForge.Imaging.HorizontalIntensityStatistics.Red"/>, <see cref="P:AForge.Imaging.HorizontalIntensityStatistics.Green"/> and <see cref="P:AForge.Imaging.HorizontalIntensityStatistics.Blue"/> property
            should be used to retrieve histogram for particular RGB channel of the processed
            color image.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor">
             <summary>
             Performs quadrilateral transformation using nearest neighbor algorithm for interpolation.
             </summary>
             
             <remarks><para>The class is deprecated and <see cref="T:AForge.Imaging.Filters.SimpleQuadrilateralTransformation"/> should be used instead.</para>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.SimpleQuadrilateralTransformation"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.#ctor(System.Collections.Generic.List{AForge.IntPoint},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor"/> class.
            </summary>
            
            <param name="sourceCorners">Corners of the source quadrilateral area.</param>
            <param name="newWidth">Width of the new transformed image.</param>
            <param name="newHeight">Height of the new transformed image.</param>
            
            <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.AutomaticSizeCalculaton"/> to
            <see langword="false"/>, which means that destination image will have width and
            height as specified by user.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.#ctor(System.Collections.Generic.List{AForge.IntPoint})">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor"/> class.
             </summary>
             
             <param name="sourceCorners">Corners of the source quadrilateral area.</param>
             
             <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.AutomaticSizeCalculaton"/> to
             <see langword="true"/>, which means that destination image will have width and
             height automatically calculated based on <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.SourceCorners"/> property.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.CalculateNewImageSize(AForge.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
            <exception cref="T:System.ArgumentException">The specified quadrilateral's corners are outside of the given image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.AutomaticSizeCalculaton">
            <summary>
            Automatic calculation of destination image or not.
            </summary>
            
            <remarks><para>The property specifies how to calculate size of destination (transformed)
            image. If the property is set to <see langword="false"/>, then <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.NewWidth"/>
            and <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.NewHeight"/> properties have effect and destination image's size is
            specified by user. If the property is set to <see langword="true"/>, then setting the above
            mentioned properties does not have any effect, but destionation image's size is
            automatically calculated from <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.SourceCorners"/> property - width and height
            come from length of longest edges.
            </para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.SourceCorners">
            <summary>
            Quadrilateral's corners in source image.
            </summary>
            
            <remarks><para>The property specifies four corners of the quadrilateral area
            in the source image to be transformed.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.NewWidth">
            <summary>
            Width of the new transformed image.
            </summary>
            
            <remarks><para>The property defines width of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's width
            is calculated automatically based on <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.SourceCorners"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.NewHeight">
            <summary>
            Height of the new transformed image.
            </summary>
            
            <remarks><para>The property defines height of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's height
            is calculated automatically based on <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.SourceCorners"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Median">
            <summary>
            Median filter.
            </summary>
            
            <remarks><para>The median filter is normally used to reduce noise in an image, somewhat like
            the <see cref="T:AForge.Imaging.Filters.Mean">mean filter</see>. However, it often does a better job than the mean
            filter of preserving useful detail in the image.</para>
            
            <para>Each pixel of the original source image is replaced with the median of neighboring pixel
            values. The median is calculated by first sorting all the pixel values from the surrounding
            neighborhood into numerical order and then replacing the pixel being considered with the
            middle pixel value.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Median filter = new Median( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample13.png" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/median.png" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Median.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Median"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Median.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Median"/> class.
            </summary>
            
            <param name="size">Processing square size.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Median.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Median.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.Median.Size">
            <summary>
            Processing square size for the median filter, [3, 25].
            </summary>
            
            <remarks><para>Default value is set to <b>3</b>.</para>
            
            <para><note>The value should be odd.</note></para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.TexturedFilter">
            <summary>
            Textured filter - filter an image using texture.
            </summary>
            
            <remarks><para>The filter is similar to <see cref="T:AForge.Imaging.Filters.TexturedMerge"/> filter in its
            nature, but instead of working with source image and overly, it uses provided
            filters to create images to merge (see <see cref="P:AForge.Imaging.Filters.TexturedFilter.Filter1"/> and <see cref="P:AForge.Imaging.Filters.TexturedFilter.Filter2"/>
            properties). In addition, it uses a bit more complex formula for calculation
            of destination pixel's value, which gives greater amount of flexibility:<br/>
            <b>dst = <see cref="P:AForge.Imaging.Filters.TexturedFilter.FilterLevel"/> * ( src1 * textureValue + src2 * ( 1.0 - textureValue ) ) + <see cref="P:AForge.Imaging.Filters.TexturedFilter.PreserveLevel"/> * src2</b>,
            where <b>src1</b> is value of pixel from the image produced by <see cref="P:AForge.Imaging.Filters.TexturedFilter.Filter1"/>,
            <b>src2</b> is value of pixel from the image produced by <see cref="P:AForge.Imaging.Filters.TexturedFilter.Filter2"/>,
            <b>dst</b> is value of pixel in a destination image and <b>textureValue</b> is corresponding value
            from provided texture (see <see cref="P:AForge.Imaging.Filters.TexturedFilter.TextureGenerator"/> or <see cref="P:AForge.Imaging.Filters.TexturedFilter.Texture"/>).</para>
            
            <para><note>It is possible to set <see cref="P:AForge.Imaging.Filters.TexturedFilter.Filter2"/> to <see langword="null"/>. In this case
            original source image will be used instead of result produced by the second filter.</note></para>
            
            <para>The filter 24 bpp color images for processing.</para>
            
            <para>Sample usage #1:</para>
            <code>
            // create filter
            TexturedFilter filter = new TexturedFilter( new CloudsTexture( ),
                new HueModifier( 50 ) );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para>Sample usage #2:</para>
            <code>
            // create filter
            TexturedFilter filter = new TexturedFilter( new CloudsTexture( ),
                new GrayscaleBT709( ), new Sepia( ) );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image #1:</b></para>
            <img src="img/imaging/textured_filter1.jpg" width="480" height="361"/>
            <para><b>Result image #2:</b></para>
            <img src="img/imaging/textured_filter2.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TexturedFilter.#ctor(System.Single[0:,0:],AForge.Imaging.Filters.IFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.TexturedFilter"/> class.
            </summary>
            
            <param name="texture">Generated texture.</param>
            <param name="filter1">First filter.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TexturedFilter.#ctor(System.Single[0:,0:],AForge.Imaging.Filters.IFilter,AForge.Imaging.Filters.IFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.TexturedFilter"/> class.
            </summary>
            
            <param name="texture">Generated texture.</param>
            <param name="filter1">First filter.</param>
            <param name="filter2">Second filter.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TexturedFilter.#ctor(AForge.Imaging.Textures.ITextureGenerator,AForge.Imaging.Filters.IFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.TexturedFilter"/> class.
            </summary>
            
            <param name="generator">Texture generator.</param>
            <param name="filter1">First filter.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TexturedFilter.#ctor(AForge.Imaging.Textures.ITextureGenerator,AForge.Imaging.Filters.IFilter,AForge.Imaging.Filters.IFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.TexturedFilter"/> class.
            </summary>
            
            <param name="generator">Texture generator.</param>
            <param name="filter1">First filter.</param>
            <param name="filter2">Second filter.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TexturedFilter.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Texture size does not match image size.</exception>
            <exception cref="T:System.ApplicationException">Filters should not change image dimension.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TexturedFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
            
             <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TexturedFilter.FilterLevel">
            <summary>
            Filter level value, [0, 1].
            </summary>
            
            <remarks><para>Filtering factor determines portion of the destionation image, which is formed
            as a result of merging source images using specified texture.</para>
            
            <para>Default value is set to <b>1.0</b>.</para>
            
            <para>See <see cref="T:AForge.Imaging.Filters.TexturedFilter"/> class description for more details.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TexturedFilter.PreserveLevel">
            <summary>
            Preserve level value
            </summary>
            
            <remarks><para>Preserving factor determines portion taken from the image produced
            by <see cref="P:AForge.Imaging.Filters.TexturedFilter.Filter2"/> (or from original source) without applying textured
            merge to it.</para>
            
            <para>Default value is set to <b>0.0</b>.</para>
            
            <para>See <see cref="T:AForge.Imaging.Filters.TexturedFilter"/> class description for more details.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TexturedFilter.Texture">
            <summary>
            Generated texture.
            </summary>
            
            <remarks><para>Two dimensional array of texture intensities.</para>
            
            <para><note>Size of the provided texture should be the same as size of images, which will
            be passed to the filter.</note></para>
            
            <para><note>The <see cref="P:AForge.Imaging.Filters.TexturedFilter.TextureGenerator"/> property has priority over this property - if
            generator is specified than the static generated texture is not used.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TexturedFilter.TextureGenerator">
            <summary>
            Texture generator.
            </summary>
            
            <remarks><para>Generator used to generate texture.</para>
            
            <para><note>The property has priority over the <see cref="P:AForge.Imaging.Filters.TexturedFilter.Texture"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TexturedFilter.Filter1">
            <summary>
            First filter.
            </summary>
            
            <remarks><para>Filter, which is used to produce first image for the merge. The filter
            needs to implement <see cref="T:AForge.Imaging.Filters.IFilterInformation"/> interface, so it could be possible
            to get information about the filter. The filter must be able to process color 24 bpp
            images and produce color 24 bpp or grayscale 8 bppp images as result.</para>
            </remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The specified filter does not support 24 bpp color images.</exception>
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The specified filter does not produce image of supported format.</exception>
            <exception cref="T:System.ArgumentException">The specified filter does not implement IFilterInformation interface.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TexturedFilter.Filter2">
            <summary>
            Second filter
            </summary>
            
            <remarks><para>Filter, which is used to produce second image for the merge. The filter
            needs to implement <see cref="T:AForge.Imaging.Filters.IFilterInformation"/> interface, so it could be possible
            to get information about the filter. The filter must be able to process color 24 bpp
            images and produce color 24 bpp or grayscale 8 bppp images as result.</para>
            
            <para><note>The filter may be set to <see langword="null"/>. In this case original source image
            is used as a second image for the merge.</note></para>
            </remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The specified filter does not support 24 bpp color images.</exception>
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The specified filter does not produce image of supported format.</exception>
            <exception cref="T:System.ArgumentException">The specified filter does not implement IFilterInformation interface.</exception>
            
        </member>
        <member name="T:AForge.Imaging.Filters.TopHat">
            <summary>
            Top-hat operator from Mathematical Morphology.
            </summary>
            
            <remarks><para>Top-hat morphological operator <see cref="T:AForge.Imaging.Filters.Subtract">subtracts</see>
            result of <see cref="T:AForge.Imaging.Filters.Opening">morphological opening</see> on the input image
            from the input image itself.</para>
            
             <para>Applied to binary image, the filter allows to get all those object (their parts)
             which were removed by <see cref="T:AForge.Imaging.Filters.Opening">opening</see> filter, but never restored.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24 and 48 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            TopHat filter = new TopHat( );
            // apply the filter
            filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample12.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/tophat.png" width="320" height="240"/>
            </remarks>
            
            <see cref="T:AForge.Imaging.Filters.BottomHat"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TopHat.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.TopHat"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TopHat.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.TopHat"/> class.
            </summary>
            
            <param name="se">Structuring element to pass to <see cref="T:AForge.Imaging.Filters.Opening"/> operator.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TopHat.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TopHat.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.DifferenceEdgeDetector">
            <summary>
            Difference edge detector.
            </summary>
            
            <remarks><para>The filter finds objects' edges by calculating maximum difference
            between pixels in 4 directions around the processing pixel.</para>
            
            <para>Suppose 3x3 square element of the source image (x - is currently processed
            pixel):
            <code lang="none">
            P1 P2 P3
            P8  x P4
            P7 P6 P5
            </code>
            The corresponding pixel of the result image equals to:
            <code lang="none">
            max( |P1-P5|, |P2-P6|, |P3-P7|, |P4-P8| )
            </code>
            </para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            DifferenceEdgeDetector filter = new DifferenceEdgeDetector( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample2.jpg" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/difference_edges.png" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.HomogenityEdgeDetector"/>
            <seealso cref="T:AForge.Imaging.Filters.SobelEdgeDetector"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.DifferenceEdgeDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.DifferenceEdgeDetector"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.DifferenceEdgeDetector.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.DifferenceEdgeDetector.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.Mean">
            <summary>
            Mean filter.
            </summary>
            
            <remarks><para>The filter performs each pixel value's averaging with its 8 neighbors, which is 
            <see cref="T:AForge.Imaging.Filters.Convolution">convolution filter</see> using the mean kernel:</para>
            
            <code lang="none">
            1  1  1
            1  1  1
            1  1  1
            </code>
            
            <para>For the list of supported pixel formats, see the documentation to <see cref="T:AForge.Imaging.Filters.Convolution"/>
            filter.</para>
            
            <para>With the above kernel the convolution filter is just calculates each pixel's value
            in result image as average of 9 corresponding pixels in the source image.</para>
            
            <para><note>By default this filter sets <see cref="P:AForge.Imaging.Filters.Convolution.ProcessAlpha"/> property to
            <see langword="true"/>, so the alpha channel of 32 bpp and 64 bpp images is blurred as well.
            </note></para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Mean filter = new Mean( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample13.png" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/mean.png" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Convolution"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Mean.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Mean"/> class.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.LevelsLinear">
            <summary>
            Linear correction of RGB channels.
            </summary>
            
            <remarks><para>The filter performs linear correction of RGB channels by mapping specified
            channels' input ranges to output ranges. It is similar to the
            <see cref="T:AForge.Imaging.Filters.ColorRemapping"/>, but the remapping is linear.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            LevelsLinear filter = new LevelsLinear( );
            // set ranges
            filter.InRed   = new IntRange( 30, 230 );
            filter.InGreen = new IntRange( 50, 240 );
            filter.InBlue  = new IntRange( 10, 210 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/levels_linear.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.HSLLinear"/>
            <seealso cref="T:AForge.Imaging.Filters.YCbCrLinear"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.LevelsLinear.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.LevelsLinear"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.LevelsLinear.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.LevelsLinear.CalculateMap(AForge.IntRange,AForge.IntRange,System.Byte[])">
            <summary>
            Calculate conversion map.
            </summary>
            
            <param name="inRange">Input range.</param>
            <param name="outRange">Output range.</param>
            <param name="map">Conversion map.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear.InRed">
            <summary>
            Red component's input range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear.InGreen">
            <summary>
            Green component's input range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear.InBlue">
            <summary>
            Blue component's input range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear.InGray">
            <summary>
            Gray component's input range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear.Input">
            <summary>
            Input range for RGB components.
            </summary>
            
            <remarks>The property allows to set red, green and blue input ranges to the same value.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear.OutRed">
            <summary>
            Red component's output range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear.OutGreen">
            <summary>
            Green component's output range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear.OutBlue">
            <summary>
            Blue component's output range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear.OutGray">
            <summary>
            Gray component's output range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear.Output">
            <summary>
            Output range for RGB components.
            </summary>
            
            <remarks>The property allows to set red, green and blue output ranges to the same value.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.SISThreshold">
            <summary>
            Threshold using Simple Image Statistics (SIS).
            </summary>
            
            <remarks><para>The filter performs image thresholding calculating threshold automatically
            using simple image statistics method. For each pixel:
            <list type="bullet">
            <item>two gradients are calculated - ex = |I(x + 1, y) - I(x - 1, y)| and
            |I(x, y + 1) - I(x, y - 1)|;</item>
            <item>weight is calculated as maximum of two gradients;</item>
            <item>sum of weights is updated (weightTotal += weight);</item>
            <item>sum of weighted pixel values is updated (total += weight * I(x, y)).</item>
            </list>
            The result threshold is calculated as sum of weighted pixel values divided by sum of weight.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SISThreshold filter = new SISThreshold( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample11.png" width="256" height="256"/>
            <para><b>Result image (calculated threshold is 127):</b></para>
            <img src="img/imaging/sis_threshold.png" width="256" height="256"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.IterativeThreshold"/>
            <seealso cref="T:AForge.Imaging.Filters.OtsuThreshold"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SISThreshold.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SISThreshold"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SISThreshold.CalculateThreshold(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:AForge.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SISThreshold.CalculateThreshold(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:AForge.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SISThreshold.CalculateThreshold(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:AForge.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SISThreshold.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SISThreshold.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.SISThreshold.ThresholdValue">
            <summary>
            Threshold value.
            </summary>
            
            <remarks><para>The property is read only and represents the value, which
            was automaticaly calculated using image statistics.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Difference">
             <summary>
             Difference filter - get the difference between overlay and source images.
             </summary>
             
             <remarks><para>The difference filter takes two images (source and
             <see cref="P:AForge.Imaging.Filters.BaseInPlaceFilter2.OverlayImage">overlay</see> images)
             of the same size and pixel format and produces an image, where each pixel equals
             to absolute difference between corresponding pixels from provided images.</para>
             
             <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
             color images for processing.</para>
             
             <para><note>In the case if images with alpha channel are used (32 or 64 bpp), visualization
             of the result image may seem a bit unexpected - most probably nothing will be seen
             (in the case if image is displayed according to its alpha channel). This may be
             caused by the fact that after differencing the entire alpha channel will be zeroed
             (zero difference between alpha channels), what means that the resulting image will be
             100% transparent.</note></para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Difference filter = new Difference( overlayImage );
             // apply the filter
             Bitmap resultImage = filter.Apply( sourceImage );
             </code>
            
             <para><b>Source image:</b></para>
             <img src="img/imaging/sample6.png" width="320" height="240"/>
             <para><b>Overlay image:</b></para>
             <img src="img/imaging/sample7.png" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/difference.png" width="320" height="240"/>
             </remarks>
            
             <seealso cref="T:AForge.Imaging.Filters.Intersect"/>
             <seealso cref="T:AForge.Imaging.Filters.Merge"/>
             <seealso cref="T:AForge.Imaging.Filters.Add"/>
             <seealso cref="T:AForge.Imaging.Filters.Subtract"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.Difference.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Difference"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Difference.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Difference"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Difference.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Difference"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Difference.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Difference.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.UnmanagedImage">
            <summary>
            Image in unmanaged memory.
            </summary>
            
            <remarks>
            <para>The class represents wrapper of an image in unmanaged memory. Using this class
            it is possible as to allocate new image in unmanaged memory, as to just wrap provided
            pointer to unmanaged memory, where an image is stored.</para>
            
            <para>Usage of unmanaged images is mostly beneficial when it is required to apply <b>multiple</b>
            image processing routines to a single image. In such scenario usage of .NET managed images 
            usually leads to worse performance, because each routine needs to lock managed image
            before image processing is done and then unlock it after image processing is done. Without
            these lock/unlock there is no way to get direct access to managed image's data, which means
            there is no way to do fast image processing. So, usage of managed images lead to overhead, which
            is caused by locks/unlock. Unmanaged images are represented internally using unmanaged memory
            buffer. This means that it is not required to do any locks/unlocks in order to get access to image
            data (no overhead).</para>
            
            <para>Sample usage:</para>
            <code>
            // sample 1 - wrapping .NET image into unmanaged without
            // making extra copy of image in memory
            BitmapData imageData = image.LockBits(
                new Rectangle( 0, 0, image.Width, image.Height ),
                ImageLockMode.ReadWrite, image.PixelFormat );
            
            try
            {
                UnmanagedImage unmanagedImage = new UnmanagedImage( imageData ) );
                // apply several routines to the unmanaged image
            }
            finally
            {
                image.UnlockBits( imageData );
            }
            
            
            // sample 2 - converting .NET image into unmanaged
            UnmanagedImage unmanagedImage = UnmanagedImage.FromManagedImage( image );
            // apply several routines to the unmanaged image
            ...
            // conver to managed image if it is required to display it at some point of time
            Bitmap managedImage = unmanagedImage.ToManagedImage( );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.#ctor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.UnmanagedImage"/> class.
            </summary>
            
            <param name="imageData">Pointer to image data in unmanaged memory.</param>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="stride">Image stride (line size in bytes).</param>
            <param name="pixelFormat">Image pixel format.</param>
            
            <remarks><para><note>Using this constructor, make sure all specified image attributes are correct
            and correspond to unmanaged memory buffer. If some attributes are specified incorrectly,
            this may lead to exceptions working with the unmanaged memory.</note></para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.UnmanagedImage"/> class.
            </summary>
            
            <param name="bitmapData">Locked bitmap data.</param>
            
            <remarks><note>Unlike <see cref="M:AForge.Imaging.UnmanagedImage.FromManagedImage(System.Drawing.Imaging.BitmapData)"/> method, this constructor does not make
            copy of managed image. This means that managed image must stay locked for the time of using the instance
            of unamanged image.</note></remarks>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.Finalize">
            <summary>
            Destroys the instance of the <see cref="T:AForge.Imaging.UnmanagedImage"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.Dispose">
            <summary>
            Dispose the object.
            </summary>
            
            <remarks><para>Frees unmanaged resources used by the object. The object becomes unusable
            after that.</para>
            
            <par><note>The method needs to be called only in the case if unmanaged image was allocated
            using <see cref="M:AForge.Imaging.UnmanagedImage.Create(System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)"/> method. In the case if the class instance was created using constructor,
            this method does not free unmanaged memory.</note></par>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.Dispose(System.Boolean)">
            <summary>
            Dispose the object.
            </summary>
            
            <param name="disposing">Indicates if disposing was initiated manually.</param>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.Clone">
            <summary>
            Clone the unmanaged images.
            </summary>
            
            <returns>Returns clone of the unmanaged image.</returns>
            
            <remarks><para>The method does complete cloning of the object.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.Copy(AForge.Imaging.UnmanagedImage)">
            <summary>
            Copy unmanaged image.
            </summary>
            
            <param name="destImage">Destination image to copy this image to.</param>
            
            <remarks><para>The method copies current unmanaged image to the specified image.
            Size and pixel format of the destination image must be exactly the same.</para></remarks>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Destination image has different size or pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.Create(System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)">
            <summary>
            Allocate new image in unmanaged memory.
            </summary>
            
            <param name="width">Image width.</param>
            <param name="height">Image height.</param>
            <param name="pixelFormat">Image pixel format.</param>
            
            <returns>Return image allocated in unmanaged memory.</returns>
            
            <remarks><para>Allocate new image with specified attributes in unmanaged memory.</para>
            
            <para><note>The method supports only
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format16bppGrayScale</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format24bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppArgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppPArgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format48bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format64bppArgb</see> and
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format64bppPArgb</see> pixel formats.
            In the case if <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            format is specified, pallete is not not created for the image (supposed that it is
            8 bpp grayscale image).
            </note></para>
            </remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format was specified.</exception>
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Invalid image size was specified.</exception>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.ToManagedImage">
            <summary>
            Create managed image from the unmanaged.
            </summary>
            
            <returns>Returns managed copy of the unmanaged image.</returns>
            
            <remarks><para>The method creates a managed copy of the unmanaged image with the
            same size and pixel format (it calls <see cref="M:AForge.Imaging.UnmanagedImage.ToManagedImage(System.Boolean)"/> specifying
            <see langword="true"/> for the <b>makeCopy</b> parameter).</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.ToManagedImage(System.Boolean)">
            <summary>
            Create managed image from the unmanaged.
            </summary>
            
            <param name="makeCopy">Make a copy of the unmanaged image or not.</param>
            
            <returns>Returns managed copy of the unmanaged image.</returns>
            
            <remarks><para>If the <paramref name="makeCopy"/> is set to <see langword="true"/>, then the method
            creates a managed copy of the unmanaged image, so the managed image stays valid even when the unmanaged
            image gets disposed. However, setting this parameter to <see langword="false"/> creates a managed image which is
            just a wrapper around the unmanaged image. So if unmanaged image is disposed, the
            managed image becomes no longer valid and accessing it will generate an exception.</para></remarks>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">The unmanaged image has some invalid properties, which results
            in failure of converting it to managed image. This may happen if user used the
            <see cref="M:AForge.Imaging.UnmanagedImage.#ctor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)"/> constructor specifying some
            invalid parameters.</exception>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.FromManagedImage(System.Drawing.Bitmap)">
            <summary>
            Create unmanaged image from the specified managed image.
            </summary>
            
            <param name="image">Source managed image.</param>
            
            <returns>Returns new unmanaged image, which is a copy of source managed image.</returns>
            
            <remarks><para>The method creates an exact copy of specified managed image, but allocated
            in unmanaged memory.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.FromManagedImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Create unmanaged image from the specified managed image.
            </summary>
            
            <param name="imageData">Source locked image data.</param>
            
            <returns>Returns new unmanaged image, which is a copy of source managed image.</returns>
            
            <remarks><para>The method creates an exact copy of specified managed image, but allocated
            in unmanaged memory. This means that managed image may be unlocked right after call to this
            method.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.Collect8bppPixelValues(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Collect pixel values from the specified list of coordinates.
            </summary>
            
            <param name="points">List of coordinates to collect pixels' value from.</param>
            
            <returns>Returns array of pixels' values from the specified coordinates.</returns>
            
            <remarks><para>The method goes through the specified list of points and for each point retrievs
            corresponding pixel's value from the unmanaged image.</para>
            
            <para><note>For grayscale image the output array has the same length as number of points in the
            specified list of points. For color image the output array has triple length, containing pixels'
            values in RGB order.</note></para>
            
            <para><note>The method does not make any checks for valid coordinates and leaves this up to user.
            If specified coordinates are out of image's bounds, the result is not predictable (crash in most cases).
            </note></para>
            
            <para><note>This method is supposed for images with 8 bpp channels only (8 bpp grayscale image and
            24/32 bpp color images).</note></para>
            </remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. Use Collect16bppPixelValues() method for
            images with 16 bpp channels.</exception>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.CollectActivePixels">
            <summary>
            Collect coordinates of none black pixels in the image.
            </summary>
            
            <returns>Returns list of points, which have other than black color.</returns>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.CollectActivePixels(System.Drawing.Rectangle)">
             <summary>
             Collect coordinates of none black pixels within specified rectangle of the image.
             </summary>
             
             <param name="rect">Image's rectangle to process.</param>
             
             <returns>Returns list of points, which have other than black color.</returns>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.SetPixels(System.Collections.Generic.List{AForge.IntPoint},System.Drawing.Color)">
             <summary>
             Set pixels with the specified coordinates to the specified color.
             </summary>
             
             <param name="coordinates">List of points to set color for.</param>
             <param name="color">Color to set for the specified points.</param>
             
             <remarks><para><note>For images having 16 bpp per color plane, the method extends the specified color
             value to 16 bit by multiplying it by 256.</note></para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.SetPixel(AForge.IntPoint,System.Drawing.Color)">
             <summary>
             Set pixel with the specified coordinates to the specified color.
             </summary>
             
             <param name="point">Point's coordiates to set color for.</param>
             <param name="color">Color to set for the pixel.</param>
             
             <remarks><para>See <see cref="M:AForge.Imaging.UnmanagedImage.SetPixel(System.Int32,System.Int32,System.Drawing.Color)"/> for more information.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.SetPixel(System.Int32,System.Int32,System.Drawing.Color)">
            <summary>
            Set pixel with the specified coordinates to the specified color.
            </summary>
            
            <param name="x">X coordinate of the pixel to set.</param>
            <param name="y">Y coordinate of the pixel to set.</param>
            <param name="color">Color to set for the pixel.</param>
            
            <remarks><para><note>For images having 16 bpp per color plane, the method extends the specified color
            value to 16 bit by multiplying it by 256.</note></para>
            
            <para>For grayscale images this method will calculate intensity value based on the below formula:
            <code lang="none">
            0.2125 * Red + 0.7154 * Green + 0.0721 * Blue
            </code>
            </para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.SetPixel(System.Int32,System.Int32,System.Byte)">
             <summary>
             Set pixel with the specified coordinates to the specified value.
             </summary>
            
             <param name="x">X coordinate of the pixel to set.</param>
             <param name="y">Y coordinate of the pixel to set.</param>
             <param name="value">Pixel value to set.</param>
             
             <remarks><para>The method sets all color components of the pixel to the specified value.
             If it is a grayscale image, then pixel's intensity is set to the specified value.
             If it is a color image, then pixel's R/G/B components are set to the same specified value
             (if an image has alpha channel, then it is set to maximum value - 255 or 65535).</para>
             
             <para><note>For images having 16 bpp per color plane, the method extends the specified color
             value to 16 bit by multiplying it by 256.</note></para>
             </remarks>
             
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.GetPixel(AForge.IntPoint)">
             <summary>
             Get color of the pixel with the specified coordinates.
             </summary>
             
             <param name="point">Point's coordiates to get color of.</param>
             
             <returns>Return pixel's color at the specified coordinates.</returns>
             
             <remarks><para>See <see cref="M:AForge.Imaging.UnmanagedImage.GetPixel(System.Int32,System.Int32)"/> for more information.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.GetPixel(System.Int32,System.Int32)">
            <summary>
            Get color of the pixel with the specified coordinates.
            </summary>
            
            <param name="x">X coordinate of the pixel to get.</param>
            <param name="y">Y coordinate of the pixel to get.</param>
            
            <returns>Return pixel's color at the specified coordinates.</returns>
            
            <remarks>
            <para><note>In the case if the image has 8 bpp grayscale format, the method will return a color with
            all R/G/B components set to same value, which is grayscale intensity.</note></para>
            
            <para><note>The method supports only 8 bpp grayscale images and 24/32 bpp color images so far.</note></para>
            </remarks>
            
            <exception cref="T:System.ArgumentOutOfRangeException">The specified pixel coordinate is out of image's bounds.</exception>
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Pixel format of this image is not supported by the method.</exception>
            
        </member>
        <member name="M:AForge.Imaging.UnmanagedImage.Collect16bppPixelValues(System.Collections.Generic.List{AForge.IntPoint})">
             <summary>
             Collect pixel values from the specified list of coordinates.
             </summary>
             
             <param name="points">List of coordinates to collect pixels' value from.</param>
             
             <returns>Returns array of pixels' values from the specified coordinates.</returns>
             
             <remarks><para>The method goes through the specified list of points and for each point retrievs
             corresponding pixel's value from the unmanaged image.</para>
             
             <para><note>For grayscale image the output array has the same length as number of points in the
             specified list of points. For color image the output array has triple length, containing pixels'
             values in RGB order.</note></para>
             
             <para><note>The method does not make any checks for valid coordinates and leaves this up to user.
             If specified coordinates are out of image's bounds, the result is not predictable (crash in most cases).
             </note></para>
             
             <para><note>This method is supposed for images with 16 bpp channels only (16 bpp grayscale image and
             48/64 bpp color images).</note></para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. Use Collect8bppPixelValues() method for
             images with 8 bpp channels.</exception>
            
        </member>
        <member name="P:AForge.Imaging.UnmanagedImage.ImageData">
            <summary>
            Pointer to image data in unmanaged memory.
            </summary>
        </member>
        <member name="P:AForge.Imaging.UnmanagedImage.Width">
            <summary>
            Image width in pixels.
            </summary>
        </member>
        <member name="P:AForge.Imaging.UnmanagedImage.Height">
            <summary>
            Image height in pixels.
            </summary>
        </member>
        <member name="P:AForge.Imaging.UnmanagedImage.Stride">
            <summary>
            Image stride (line size in bytes).
            </summary>
        </member>
        <member name="P:AForge.Imaging.UnmanagedImage.PixelFormat">
            <summary>
            Image pixel format.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Textures.CloudsTexture">
             <summary>
             Clouds texture.
             </summary>
             
             <remarks><para>The texture generator creates textures with effect of clouds.</para>
             
             <para>The generator is based on the <see cref="T:AForge.Math.PerlinNoise">Perlin noise function</see>.</para>
             
             <para>Sample usage:</para>
             <code>
             // create texture generator
             CloudsTexture textureGenerator = new CloudsTexture( );
             // generate new texture
             float[,] texture = textureGenerator.Generate( 320, 240 );
             // convert it to image to visualize
             Bitmap textureImage = TextureTools.ToBitmap( texture );
             </code>
            
             <para><b>Result image:</b></para>
             <img src="img/imaging/clouds_texture.jpg" width="320" height="240"/>
             </remarks>
             
        </member>
        <member name="T:AForge.Imaging.Textures.ITextureGenerator">
            <summary>
            Texture generator interface.
            </summary>
            
            <remarks><para>Each texture generator generates a 2-D texture of the specified size and returns
            it as two dimensional array of intensities in the range of [0, 1] - texture's values.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Textures.ITextureGenerator.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of texture's intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Textures.ITextureGenerator.Reset">
            <summary>
            Reset generator.
            </summary>
            
            <remarks>Resets the generator - resets all internal variables, regenerates
            internal random numbers, etc.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Textures.CloudsTexture.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Textures.CloudsTexture"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Textures.CloudsTexture.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
             
        </member>
        <member name="M:AForge.Imaging.Textures.CloudsTexture.Reset">
            <summary>
            Reset generator.
            </summary>
            
            <remarks>Regenerates internal random numbers.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.QuadrilateralFinder">
             <summary>
             Searching of quadrilateral/triangle corners.
             </summary>
            
             <remarks><para>The class searches for quadrilateral's/triangle's corners on the specified image.
             It first collects edge points of the object and then uses
             <see cref="M:AForge.Math.Geometry.PointsCloud.FindQuadrilateralCorners(System.Collections.Generic.IEnumerable{AForge.IntPoint})"/> to find corners
             the quadrilateral/triangle.</para>
             
             <para><note>The class treats all black pixels as background (none-object) and
             all none-black pixels as object.</note></para>
             
             <para>The class processes grayscale 8 bpp and color 24/32 bpp images.</para>
             
             <para>Sample usage:</para>
             <code>
             // get corners of the quadrilateral
             QuadrilateralFinder qf = new QuadrilateralFinder( );
             List&lt;IntPoint&gt; corners = qf.ProcessImage( image );
             
             // lock image to draw on it with AForge.NET's methods
             // (or draw directly on image without locking if it is unmanaged image)
             BitmapData data = image.LockBits( new Rectangle( 0, 0, image.Width, image.Height ),
                 ImageLockMode.ReadWrite, image.PixelFormat );
             
             Drawing.Polygon( data, corners, Color.Red );
             for ( int i = 0; i &lt; corners.Count; i++ )
             {
                 Drawing.FillRectangle( data,
                     new Rectangle( corners[i].X - 2, corners[i].Y - 2, 5, 5 ),
                     Color.FromArgb( i * 32 + 127 + 32, i * 64, i * 64 ) );
             }
             
             image.UnlockBits( data );
             </code>
             
             <para><b>Source image:</b></para>
             <img src="img/imaging/sample17.png" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/quadrilateral_finder.png" width="320" height="240"/>
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.QuadrilateralFinder.ProcessImage(System.Drawing.Bitmap)">
             <summary>
             Find corners of quadrilateral/triangular area in the specified image.
             </summary>
             
             <param name="image">Source image to search quadrilateral for.</param>
             
             <returns>Returns a list of points, which are corners of the quadrilateral/triangular area found
             in the specified image. The first point in the list is the point with lowest
             X coordinate (and with lowest Y if there are several points with the same X value).
             Points are in clockwise order (screen coordinates system).</returns>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:AForge.Imaging.QuadrilateralFinder.ProcessImage(System.Drawing.Imaging.BitmapData)">
             <summary>
             Find corners of quadrilateral/triangular area in the specified image.
             </summary>
             
             <param name="imageData">Source image data to search quadrilateral for.</param>
             
             <returns>Returns a list of points, which are corners of the quadrilateral/triangular area found
             in the specified image. The first point in the list is the point with lowest
             X coordinate (and with lowest Y if there are several points with the same X value).
             Points are in clockwise order (screen coordinates system).</returns>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:AForge.Imaging.QuadrilateralFinder.ProcessImage(AForge.Imaging.UnmanagedImage)">
             <summary>
             Find corners of quadrilateral/triangular area in the specified image.
             </summary>
             
             <param name="image">Source image to search quadrilateral for.</param>
             
             <returns>Returns a list of points, which are corners of the quadrilateral/triangular area found
             in the specified image. The first point in the list is the point with lowest
             X coordinate (and with lowest Y if there are several points with the same X value).
             Points are in clockwise order (screen coordinates system).</returns>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="T:AForge.Imaging.IBlobsFilter">
             <summary>
             Interface for custom blobs' filters used for filtering blobs after
             blob counting.
             </summary>
             
             <remarks><para>The interface should be implemented by classes, which perform
             custom blobs' filtering different from default filtering implemented in
             <see cref="T:AForge.Imaging.BlobCounterBase"/>. See <see cref="P:AForge.Imaging.BlobCounterBase.BlobsFilter"/>
             for additional information.</para>
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.IBlobsFilter.Check(AForge.Imaging.Blob)">
             <summary>
             Check specified blob and decide if should be kept or not.
             </summary>
             
             <param name="blob">Blob to check.</param>
             
             <returns>Return <see langword="true"/> if the blob should be kept or
             <see langword="false"/> if it should be removed.</returns>
            
        </member>
        <member name="T:AForge.Imaging.HoughLine">
            <summary>
            Hough line.
            </summary>
            
            <remarks><para>Represents line of Hough Line transformation using
            <a href="http://en.wikipedia.org/wiki/Polar_coordinate_system">polar coordinates</a>.
            See <a href="http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates">Wikipedia</a>
            for information on how to convert polar coordinates to Cartesian coordinates.
            </para>
            
            <para><note><see cref="T:AForge.Imaging.HoughLineTransformation">Hough Line transformation</see> does not provide
            information about lines start and end points, only slope and distance from image's center. Using
            only provided information it is not possible to draw the detected line as it exactly appears on
            the source image. But it is possible to draw a line through the entire image, which contains the
            source line (see sample code below).
            </note></para>
            
            <para>Sample code to draw detected Hough lines:</para>
            <code>
            HoughLineTransformation lineTransform = new HoughLineTransformation( );
            // apply Hough line transofrm
            lineTransform.ProcessImage( sourceImage );
            Bitmap houghLineImage = lineTransform.ToBitmap( );
            // get lines using relative intensity
            HoughLine[] lines = lineTransform.GetLinesByRelativeIntensity( 0.5 );
            
            foreach ( HoughLine line in lines )
            {
                // get line's radius and theta values
                int    r = line.Radius;
                double t = line.Theta;
                
                // check if line is in lower part of the image
                if ( r &lt; 0 )
                {
                    t += 180;
                    r = -r;
                }
                
                // convert degrees to radians
                t = ( t / 180 ) * Math.PI;
                
                // get image centers (all coordinate are measured relative
                // to center)
                int w2 = image.Width /2;
                int h2 = image.Height / 2;
                
                double x0 = 0, x1 = 0, y0 = 0, y1 = 0;
                
                if ( line.Theta != 0 )
                {
                    // none-vertical line
                    x0 = -w2; // most left point
                    x1 = w2;  // most right point
                
                    // calculate corresponding y values
                    y0 = ( -Math.Cos( t ) * x0 + r ) / Math.Sin( t );
                    y1 = ( -Math.Cos( t ) * x1 + r ) / Math.Sin( t );
                }
                else
                {
                    // vertical line
                    x0 = line.Radius;
                    x1 = line.Radius;
                
                    y0 = h2;
                    y1 = -h2;
                }
                
                // draw line on the image
                Drawing.Line( sourceData,
                    new IntPoint( (int) x0 + w2, h2 - (int) y0 ),
                    new IntPoint( (int) x1 + w2, h2 - (int) y1 ),
                    Color.Red );
            }
            </code>
            
            <para>To clarify meaning of <see cref="F:AForge.Imaging.HoughLine.Radius"/> and <see cref="F:AForge.Imaging.HoughLine.Theta"/> values
            of detected Hough lines, let's take a look at the below sample image and
            corresponding values of radius and theta for the lines on the image:
            </para>
            
            <img src="img/imaging/sample15.png" width="400" height="300"/>
            
            <para>Detected radius and theta values (color in corresponding colors):
            <list type="bullet">
            <item><font color="#FF0000">Theta = 90, R = 125, I = 249</font>;</item>
            <item><font color="#00FF00">Theta = 0, R = -170, I = 187</font> (converts to Theta = 180, R = 170);</item>
            <item><font color="#0000FF">Theta = 90, R = -58, I = 163</font> (converts to Theta = 270, R = 58);</item>
            <item><font color="#FFFF00">Theta = 101, R = -101, I = 130</font> (converts to Theta = 281, R = 101);</item>
            <item><font color="#FF8000">Theta = 0, R = 43, I = 112</font>;</item>
            <item><font color="#FF80FF">Theta = 45, R = 127, I = 82</font>.</item>
            </list>
            </para>
            
            </remarks>
            
            <seealso cref="T:AForge.Imaging.HoughLineTransformation"/>
            
        </member>
        <member name="F:AForge.Imaging.HoughLine.Theta">
            <summary>
            Line's slope - angle between polar axis and line's radius (normal going
            from pole to the line). Measured in degrees, [0, 180).
            </summary>
        </member>
        <member name="F:AForge.Imaging.HoughLine.Radius">
            <summary>
            Line's distance from image center, (−∞, +∞).
            </summary>
            
            <remarks><note>Negative line's radius means, that the line resides in lower
            part of the polar coordinates system. This means that <see cref="F:AForge.Imaging.HoughLine.Theta"/> value
            should be increased by 180 degrees and radius should be made positive.
            </note></remarks>
            
        </member>
        <member name="F:AForge.Imaging.HoughLine.Intensity">
            <summary>
            Line's absolute intensity, (0, +∞).
            </summary>
            
            <remarks><para>Line's absolute intensity is a measure, which equals
            to number of pixels detected on the line. This value is bigger for longer
            lines.</para>
            
            <para><note>The value may not be 100% reliable to measure exact number of pixels
            on the line. Although these value correlate a lot (which means they are very close
            in most cases), the intensity value may slightly vary.</note></para>
            </remarks>
            
        </member>
        <member name="F:AForge.Imaging.HoughLine.RelativeIntensity">
            <summary>
            Line's relative intensity, (0, 1].
            </summary>
            
            <remarks><para>Line's relative intensity is relation of line's <see cref="F:AForge.Imaging.HoughLine.Intensity"/>
            value to maximum found intensity. For the longest line (line with highest intesity) the
            relative intensity is set to 1. If line's relative is set 0.5, for example, this means
            its intensity is half of maximum found intensity.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.HoughLine.#ctor(System.Double,System.Int16,System.Int16,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.HoughLine"/> class.
            </summary>
            
            <param name="theta">Line's slope.</param>
            <param name="radius">Line's distance from image center.</param>
            <param name="intensity">Line's absolute intensity.</param>
            <param name="relativeIntensity">Line's relative intensity.</param>
            
        </member>
        <member name="M:AForge.Imaging.HoughLine.CompareTo(System.Object)">
            <summary>
            Compare the object with another instance of this class.
            </summary>
            
            <param name="value">Object to compare with.</param>
            
            <returns><para>A signed number indicating the relative values of this instance and <b>value</b>: 1) greater than zero - 
            this instance is greater than <b>value</b>; 2) zero - this instance is equal to <b>value</b>;
            3) greater than zero - this instance is less than <b>value</b>.</para>
            
            <para><note>The sort order is descending.</note></para></returns>
            
            <remarks>
            <para><note>Object are compared using their <see cref="F:AForge.Imaging.HoughLine.Intensity">intensity</see> value.</note></para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.HoughLineTransformation">
             <summary>
             Hough line transformation.
             </summary>
            
             <remarks><para>The class implements Hough line transformation, which allows to detect
             straight lines in an image. Lines, which are found by the class, are provided in
             <a href="http://en.wikipedia.org/wiki/Polar_coordinate_system">polar coordinates system</a> -
             lines' distances from image's center and lines' slopes are provided.
             The pole of polar coordinates system is put into processing image's center and the polar
             axis is directed to the right from the pole. Lines' slope is measured in degrees and
             is actually represented by angle between polar axis and line's radius (normal going
             from pole to the line), which is measured in counter-clockwise direction.
             </para>
             
             <para><note>Found lines may have negative <see cref="F:AForge.Imaging.HoughLine.Radius">radius</see>.
             This means, that the line resides in lower part of the polar coordinates system
             and its <see cref="F:AForge.Imaging.HoughLine.Theta"/> value should be increased by 180 degrees and
             radius should be made positive.
             </note></para>
             
             <para>The class accepts binary images for processing, which are represented by 8 bpp grayscale images.
             All black pixels (0 pixel's value) are treated as background, but pixels with different value are
             treated as lines' pixels.</para>
             
             <para>See also documentation to <see cref="T:AForge.Imaging.HoughLine"/> class for additional information
             about Hough Lines.</para>
             
             <para>Sample usage:</para>
             <code>
             HoughLineTransformation lineTransform = new HoughLineTransformation( );
             // apply Hough line transofrm
             lineTransform.ProcessImage( sourceImage );
             Bitmap houghLineImage = lineTransform.ToBitmap( );
             // get lines using relative intensity
             HoughLine[] lines = lineTransform.GetLinesByRelativeIntensity( 0.5 );
             
             foreach ( HoughLine line in lines )
             {
                 // ...
             }
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample8.jpg" width="400" height="300"/>
             <para><b>Hough line transformation image:</b></para>
             <img src="img/imaging/hough_lines.jpg" width="500" height="180"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.HoughLine"/>
             
        </member>
        <member name="M:AForge.Imaging.HoughLineTransformation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.HoughLineTransformation"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.HoughLineTransformation.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source image to process.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HoughLineTransformation.ProcessImage(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="rect">Image's rectangle to process.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HoughLineTransformation.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HoughLineTransformation.ProcessImage(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            <param name="rect">Image's rectangle to process.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HoughLineTransformation.ProcessImage(AForge.Imaging.UnmanagedImage)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source unmanaged image to process.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HoughLineTransformation.ProcessImage(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source unmanaged image to process.</param>
            <param name="rect">Image's rectangle to process.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HoughLineTransformation.ToBitmap">
            <summary>
            Convert Hough map to bitmap. 
            </summary>
            
            <returns>Returns 8 bppp grayscale bitmap, which shows Hough map.</returns>
            
            <exception cref="T:System.ApplicationException">Hough transformation was not yet done by calling
            ProcessImage() method.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HoughLineTransformation.GetMostIntensiveLines(System.Int32)">
            <summary>
            Get specified amount of lines with highest <see cref="F:AForge.Imaging.HoughLine.Intensity">intensity</see>.
            </summary>
            
            <param name="count">Amount of lines to get.</param>
            
            <returns>Returns array of most intesive lines. If there are no lines detected,
            the returned array has zero length.</returns>
            
        </member>
        <member name="M:AForge.Imaging.HoughLineTransformation.GetLinesByRelativeIntensity(System.Double)">
            <summary>
            Get lines with <see cref="F:AForge.Imaging.HoughLine.RelativeIntensity">relative intensity</see> higher then specified value.
            </summary>
            
            <param name="minRelativeIntensity">Minimum relative intesity of lines.</param>
            
            <returns>Returns array of lines. If there are no lines detected,
            the returned array has zero length.</returns>
            
        </member>
        <member name="P:AForge.Imaging.HoughLineTransformation.StepsPerDegree">
            <summary>
            Steps per degree.
            </summary>
            
            <remarks><para>The value defines quality of Hough line transformation and its ability to detect
            lines' slope precisely.</para>
            
            <para>Default value is set to <b>1</b>. Minimum value is <b>1</b>. Maximum value is <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.HoughLineTransformation.MinLineIntensity">
             <summary>
             Minimum <see cref="F:AForge.Imaging.HoughLine.Intensity">line's intensity</see> in Hough map to recognize a line.
             </summary>
            
             <remarks><para>The value sets minimum intensity level for a line. If a value in Hough
             map has lower intensity, then it is not treated as a line.</para>
             
             <para>Default value is set to <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.HoughLineTransformation.LocalPeakRadius">
            <summary>
            Radius for searching local peak value.
            </summary>
            
            <remarks><para>The value determines radius around a map's value, which is analyzed to determine
            if the map's value is a local maximum in specified area.</para>
            
            <para>Default value is set to <b>4</b>. Minimum value is <b>1</b>. Maximum value is <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.HoughLineTransformation.MaxIntensity">
            <summary>
            Maximum found <see cref="F:AForge.Imaging.HoughLine.Intensity">intensity</see> in Hough map.
            </summary>
            
            <remarks><para>The property provides maximum found line's intensity.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.HoughLineTransformation.LinesCount">
            <summary>
            Found lines count.
            </summary>
            
            <remarks><para>The property provides total number of found lines, which intensity is higher (or equal to),
            than the requested <see cref="P:AForge.Imaging.HoughLineTransformation.MinLineIntensity">minimum intensity</see>.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.SimpleQuadrilateralTransformation">
             <summary>
             Performs quadrilateral transformation of an area in the source image.
             </summary>
             
             <remarks><para>The class implements simple algorithm described by
             <a href="http://www.codeguru.com/forum/showpost.php?p=1186454&amp;postcount=2">Olivier Thill</a>
             for transforming quadrilateral area from a source image into rectangular image.
             The idea of the algorithm is based on finding for each line of destination
             rectangular image a corresponding line connecting "left" and "right" sides of
             quadrilateral in a source image. Then the line is linearly transformed into the
             line in destination image.</para>
             
             <para><note>Due to simplicity of the algorithm it does not do any correction for perspective.
             </note></para>
             
             <para><note>To make sure the algorithm works correctly, it is preferred if the
             "left-top" corner of the quadrilateral (screen coordinates system) is
             specified first in the list of quadrilateral's corners. At least
             user need to make sure that the "left" side (side connecting first and the last
             corner) and the "right" side (side connecting second and third corners) are
             not horizontal.</note></para>
             
             <para>Use <see cref="T:AForge.Imaging.Filters.QuadrilateralTransformation"/> to avoid the above mentioned limitations,
             which is a more advanced quadrilateral transformation algorithms (although a bit more
             computationally expensive).</para>
             
             <para>The image processing filter accepts 8 grayscale images and 24/32 bpp
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // define quadrilateral's corners
             List&lt;IntPoint&gt; corners = new List&lt;IntPoint&gt;( );
             corners.Add( new IntPoint(  99,  99 ) );
             corners.Add( new IntPoint( 156,  79 ) );
             corners.Add( new IntPoint( 184, 126 ) );
             corners.Add( new IntPoint( 122, 150 ) );
             // create filter
             SimpleQuadrilateralTransformation filter =
                 new SimpleQuadrilateralTransformation( corners, 200, 200 );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample18.jpg" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/quadrilateral_bilinear.png" width="200" height="200"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.QuadrilateralTransformation"/>
            
        </member>
        <member name="F:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.newWidth">
            <summary>
            New image width.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.newHeight">
            <summary>
            New image height.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SimpleQuadrilateralTransformation"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.#ctor(System.Collections.Generic.List{AForge.IntPoint},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SimpleQuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceQuadrilateral">Corners of the source quadrilateral area.</param>
            <param name="newWidth">Width of the new transformed image.</param>
            <param name="newHeight">Height of the new transformed image.</param>
            
            <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.AutomaticSizeCalculaton"/> to
            <see langword="false"/>, which means that destination image will have width and
            height as specified by user.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.#ctor(System.Collections.Generic.List{AForge.IntPoint})">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SimpleQuadrilateralTransformation"/> class.
             </summary>
             
             <param name="sourceQuadrilateral">Corners of the source quadrilateral area.</param>
             
             <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.AutomaticSizeCalculaton"/> to
             <see langword="true"/>, which means that destination image will have width and
             height automatically calculated based on <see cref="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.SourceQuadrilateral"/> property.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.CalculateNewImageSize(AForge.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
            <exception cref="T:System.NullReferenceException">Source quadrilateral was not set.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.AutomaticSizeCalculaton">
            <summary>
            Automatic calculation of destination image or not.
            </summary>
            
            <remarks><para>The property specifies how to calculate size of destination (transformed)
            image. If the property is set to <see langword="false"/>, then <see cref="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.NewWidth"/>
            and <see cref="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.NewHeight"/> properties have effect and destination image's size is
            specified by user. If the property is set to <see langword="true"/>, then setting the above
            mentioned properties does not have any effect, but destionation image's size is
            automatically calculated from <see cref="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.SourceQuadrilateral"/> property - width and height
            come from length of longest edges.
            </para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.SourceQuadrilateral">
            <summary>
            Quadrilateral's corners in source image.
            </summary>
            
            <remarks><para>The property specifies four corners of the quadrilateral area
            in the source image to be transformed.</para>
            
            <para>See documentation to the <see cref="T:AForge.Imaging.Filters.SimpleQuadrilateralTransformation"/>
            class itself for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.NewWidth">
            <summary>
            Width of the new transformed image.
            </summary>
            
            <remarks><para>The property defines width of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's width
            is calculated automatically based on <see cref="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.SourceQuadrilateral"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.NewHeight">
            <summary>
            Height of the new transformed image.
            </summary>
            
            <remarks><para>The property defines height of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's height
            is calculated automatically based on <see cref="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.SourceQuadrilateral"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimpleQuadrilateralTransformation.UseInterpolation">
            <summary>
            Specifies if bilinear interpolation should be used or not.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/> - interpolation
            is used.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Texturer">
            <summary>
            Texturer filter.
            </summary>
            
            <remarks><para>Adjust pixels’ color values using factors from the given texture. In conjunction with different type
            of texture generators, the filter may produce different type of interesting effects.</para>
            
            <para>The filter uses specified texture to adjust values using the next formula:<br/>
            <b>dst = src * <see cref="P:AForge.Imaging.Filters.Texturer.PreserveLevel"/> + src * <see cref="P:AForge.Imaging.Filters.Texturer.FilterLevel"/> * textureValue</b>,<br/>
            where <b>src</b> is value of pixel in a source image, <b>dst</b> is value of pixel in a destination image and
            <b>textureValue</b> is corresponding value from provided texture (see <see cref="P:AForge.Imaging.Filters.Texturer.TextureGenerator"/> or
            <see cref="P:AForge.Imaging.Filters.Texturer.Texture"/>). Using <see cref="P:AForge.Imaging.Filters.Texturer.PreserveLevel"/> and <see cref="P:AForge.Imaging.Filters.Texturer.FilterLevel"/> values it is possible
            to control the portion of source data affected by texture.
            </para>
            
            <para>In most cases the <see cref="P:AForge.Imaging.Filters.Texturer.PreserveLevel"/> and <see cref="P:AForge.Imaging.Filters.Texturer.FilterLevel"/> properties are set in such
            way, that <see cref="P:AForge.Imaging.Filters.Texturer.PreserveLevel"/> + <see cref="P:AForge.Imaging.Filters.Texturer.FilterLevel"/> = <b>1</b>. But there is no limitations actually
            for those values, so their sum may be as greater, as lower than 1 in order create different type of
            effects.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Texturer filter = new Texturer( new TextileTexture( ), 0.3, 0.7 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/texturer.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Texturer.#ctor(System.Single[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Texturer"/> class.
            </summary>
            
            <param name="texture">Generated texture.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Texturer.#ctor(System.Single[0:,0:],System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Texturer"/> class.
            </summary>
            
            <param name="texture">Generated texture.</param>
            <param name="filterLevel">Filter level value (see <see cref="P:AForge.Imaging.Filters.Texturer.FilterLevel"/> property).</param>
            <param name="preserveLevel">Preserve level value (see <see cref="P:AForge.Imaging.Filters.Texturer.PreserveLevel"/> property).</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Texturer.#ctor(AForge.Imaging.Textures.ITextureGenerator)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Texturer"/> class.
            </summary>
            
            <param name="generator">Texture generator.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Texturer.#ctor(AForge.Imaging.Textures.ITextureGenerator,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Texturer"/> class.
            </summary>
            
            <param name="generator">Texture generator.</param>
            <param name="filterLevel">Filter level value (see <see cref="P:AForge.Imaging.Filters.Texturer.FilterLevel"/> property).</param>
            <param name="preserveLevel">Preserve level value (see <see cref="P:AForge.Imaging.Filters.Texturer.PreserveLevel"/> property).</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Texturer.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Texturer.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
            
             <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Texturer.FilterLevel">
            <summary>
            Filter level value.
            </summary>
            
            <remarks><para>Filtering factor determines image fraction to filter - to multiply 
            by values from the provided texture.</para>
            
            <para>Default value is set to <b>0.5</b>.</para>
            
            <para>See <see cref="T:AForge.Imaging.Filters.Texturer"/> class description for more details.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Texturer.PreserveLevel">
            <summary>
            Preserve level value.
            </summary>
            
            <remarks><para>Preserving factor determines image fraction to keep from filtering.</para>
            
            <para>Default value is set to <b>0.5</b>.</para>
            
            <para>See <see cref="T:AForge.Imaging.Filters.Texturer"/> class description for more details.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Texturer.Texture">
            <summary>
            Generated texture.
            </summary>
            
            <remarks><para>Two dimensional array of texture intensities.</para>
            
            <para><note>In the case if image passed to the filter is smaller or
            larger than the specified texture, than image's region is processed, which equals to the
            minimum overlapping area.</note></para>
            
            <para><note>The <see cref="P:AForge.Imaging.Filters.Texturer.TextureGenerator"/> property has priority over this property - if
            generator is specified than the static generated texture is not used.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Texturer.TextureGenerator">
            <summary>
            Texture generator.
            </summary>
            
            <remarks><para>Generator used to generate texture.</para>
            
            <para><note>The property has priority over the <see cref="P:AForge.Imaging.Filters.Texturer.Texture"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.HSLLinear">
            <summary>
            Luminance and saturation linear correction.
            </summary>
            
            <remarks><para>The filter operates in <b>HSL</b> color space and provides
            with the facility of luminance and saturation linear correction - mapping specified channels'
            input ranges to specified output ranges.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            HSLLinear filter = new HSLLinear( );
            // configure the filter
            filter.InLuminance   = new Range( 0, 0.85f );
            filter.OutSaturation = new Range( 0.25f, 1 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/hsl_linear.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.LevelsLinear"/>
            <seealso cref="T:AForge.Imaging.Filters.YCbCrLinear"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HSLLinear.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.HSLLinear"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HSLLinear.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HSLLinear.InLuminance">
            <summary>
            Luminance input range.
            </summary>
            
            <remarks>Luminance component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HSLLinear.OutLuminance">
            <summary>
            Luminance output range.
            </summary>
            
            <remarks>Luminance component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HSLLinear.InSaturation">
            <summary>
            Saturation input range.
            </summary>
            
            <remarks>Saturation component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HSLLinear.OutSaturation">
            <summary>
            Saturation output range.
            </summary>
            
            <remarks>Saturation component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HSLLinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.Blur">
             <summary>
             Blur filter.
             </summary>
             
             <remarks><para>The filter performs <see cref="T:AForge.Imaging.Filters.Convolution">convolution filter</see> using
             the blur kernel:</para>
             
             <code lang="none">
             1  2  3  2  1
             2  4  5  4  2
             3  5  6  5  3
             2  4  5  4  2
             1  2  3  2  1
             </code>
             
             <para>For the list of supported pixel formats, see the documentation to <see cref="T:AForge.Imaging.Filters.Convolution"/>
             filter.</para>
             
             <para><note>By default this filter sets <see cref="P:AForge.Imaging.Filters.Convolution.ProcessAlpha"/> property to
             <see langword="true"/>, so the alpha channel of 32 bpp and 64 bpp images is blurred as well.
             </note></para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Blur filter = new Blur( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
            
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/blur.jpg" width="480" height="361"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.Convolution"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.Blur.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Blur"/> class.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.SimplePosterization">
             <summary>
             Simple posterization of an image.
             </summary>
             
             <remarks><para>The class implements simple <a href="http://en.wikipedia.org/wiki/Posterization">posterization</a> of an image by splitting
             each color plane into adjacent areas of the <see cref="P:AForge.Imaging.Filters.SimplePosterization.PosterizationInterval">specified size</see>. After the process
             is done, each color plane will contain maximum of 256/<see cref="P:AForge.Imaging.Filters.SimplePosterization.PosterizationInterval">PosterizationInterval</see> levels.
             For example, if grayscale image is posterized with posterization interval equal to 64,
             then result image will contain maximum of 4 tones. If color image is posterized with the
             same posterization interval, then it will contain maximum of 4<sup>3</sup>=64 colors.
             See <see cref="P:AForge.Imaging.Filters.SimplePosterization.FillingType"/> property to get information about the way how to control
             color used to fill posterization areas.</para>
             
             <para>Posterization is a process in photograph development which converts normal photographs
             into an image consisting of distinct, but flat, areas of different tones or colors.</para>
            
             <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             SimplePosterization filter = new SimplePosterization( );
             // process image
             filter.ApplyInPlace( sourceImage );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/posterization.png" width="480" height="361"/>
             </remarks>
             
        </member>
        <member name="M:AForge.Imaging.Filters.SimplePosterization.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SimplePosterization"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.SimplePosterization.#ctor(AForge.Imaging.Filters.SimplePosterization.PosterizationFillingType)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SimplePosterization"/> class.
            </summary>
            
            <param name="fillingType">Specifies <see cref="P:AForge.Imaging.Filters.SimplePosterization.FillingType">filling type</see> of posterization areas.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SimplePosterization.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimplePosterization.PosterizationInterval">
            <summary>
            Posterization interval, which specifies size of posterization areas.
            </summary>
            
            <remarks><para>The property specifies size of adjacent posterization areas
            for each color plane. The value has direct effect on the amount of colors
            in the result image. For example, if grayscale image is posterized with posterization
            interval equal to 64, then result image will contain maximum of 4 tones. If color
            image is posterized with same posterization interval, then it will contain maximum
            of 4<sup>3</sup>=64 colors.</para>
            
            <para>Default value is set to <b>64</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimplePosterization.FillingType">
            <summary>
            Posterization filling type.
            </summary>
            
            <remarks><para>The property controls the color, which is used to substitute
            colors within the same posterization interval - minimum, maximum or average value.
            </para>
            
            <para>Default value is set to <see cref="F:AForge.Imaging.Filters.SimplePosterization.PosterizationFillingType.Average"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SimplePosterization.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.SimplePosterization.PosterizationFillingType">
            <summary>
            Enumeration of possible types of filling posterized areas.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.SimplePosterization.PosterizationFillingType.Min">
            <summary>
            Fill area with minimum color's value.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.SimplePosterization.PosterizationFillingType.Max">
            <summary>
            Fill area with maximum color's value.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.SimplePosterization.PosterizationFillingType.Average">
            <summary>
            Fill area with average color's value.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.JarvisJudiceNinkeDithering">
             <summary>
             Dithering using Jarvis, Judice and Ninke error diffusion.
             </summary>
             
             <remarks><para>The filter represents binarization filter, which is based on
             error diffusion dithering with Jarvis-Judice-Ninke coefficients. Error is diffused
             on 12 neighbor pixels with next coefficients:</para>
             <code lang="none">
                     | * | 7 | 5 |
             | 3 | 5 | 7 | 5 | 3 |
             | 1 | 3 | 5 | 3 | 1 |
             
             / 48
             </code>
             
             <para>The filter accepts 8 bpp grayscale images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             JarvisJudiceNinkeDithering filter = new JarvisJudiceNinkeDithering( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/grayscale.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/jarvis_judice_ninke.jpg" width="480" height="361"/>
             </remarks>
            
             <seealso cref="T:AForge.Imaging.Filters.BurkesDithering"/>
             <seealso cref="T:AForge.Imaging.Filters.FloydSteinbergDithering"/>
             <seealso cref="T:AForge.Imaging.Filters.SierraDithering"/>
             <seealso cref="T:AForge.Imaging.Filters.StuckiDithering"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.JarvisJudiceNinkeDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.JarvisJudiceNinkeDithering"/> class.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.ColorReduction.MedianCutQuantizer">
            <summary>
            Median cut color quantization algorithm.
            </summary>
            
            <remarks><para>The class implements <a href="http://en.wikipedia.org/wiki/Median_cut">median cut</a>
            <a href="http://en.wikipedia.org/wiki/Median_cut">color quantization</a> algorithm.</para>
            
            <para>See also <see cref="T:AForge.Imaging.ColorReduction.ColorImageQuantizer"/> class, which may simplify processing of images.</para>
            
            <para>Sample usage:</para>
            <code>
            // create the color quantization algorithm
            IColorQuantizer quantizer = new MedianCutQuantizer( );
            // process colors (taken from image for example)
            for ( int i = 0; i &lt; pixelsToProcess; i++ )
            {
                quantizer.AddColor( /* pixel color */ );
            }
            // get palette reduced to 16 colors
            Color[] palette = quantizer.GetPalette( 16 );
            </code>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.ColorReduction.ColorImageQuantizer"/>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.MedianCutQuantizer.AddColor(System.Drawing.Color)">
            <summary>
            Add color to the list of processed colors.
            </summary>
            
            <param name="color">Color to add to the internal list.</param>
            
            <remarks><para>The method adds the specified color into internal list of processed colors. The list
            is used later by <see cref="M:AForge.Imaging.ColorReduction.MedianCutQuantizer.GetPalette(System.Int32)"/> method to build reduced color table of the specified size.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.MedianCutQuantizer.GetPalette(System.Int32)">
            <summary>
            Get paletter of the specified size.
            </summary>
            
            <param name="colorCount">Palette size to get.</param>
            
            <returns>Returns reduced palette of the specified size, which covers colors processed so far.</returns>
            
            <remarks><para>The method must be called after continuously calling <see cref="M:AForge.Imaging.ColorReduction.MedianCutQuantizer.AddColor(System.Drawing.Color)"/> method and
            returns reduced color palette for colors accumulated/processed so far.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.MedianCutQuantizer.Clear">
            <summary>
            Clear internal state of the color quantization algorithm by clearing the list of colors
            so far processed.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Textures.LabyrinthTexture">
             <summary>
             Labirinth texture.
             </summary>
             
             <remarks><para>The texture generator creates textures with effect of labyrinth.</para>
             
             <para>The generator is based on the <see cref="T:AForge.Math.PerlinNoise">Perlin noise function</see>.</para>
             
             <para>Sample usage:</para>
             <code>
             // create texture generator
             LabyrinthTexture textureGenerator = new LabyrinthTexture( );
             // generate new texture
             float[,] texture = textureGenerator.Generate( 320, 240 );
             // convert it to image to visualize
             Bitmap textureImage = TextureTools.ToBitmap( texture );
             </code>
            
             <para><b>Result image:</b></para>
             <img src="img/imaging/labyrinth_texture.jpg" width="320" height="240"/>
             </remarks>
             
        </member>
        <member name="M:AForge.Imaging.Textures.LabyrinthTexture.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Textures.LabyrinthTexture"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Textures.LabyrinthTexture.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
             
        </member>
        <member name="M:AForge.Imaging.Textures.LabyrinthTexture.Reset">
            <summary>
            Reset generator.
            </summary>
            
            <remarks>Regenerates internal random numbers.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.ITemplateMatching">
            <summary>
            Template matching algorithm's interface.
            </summary>
            
            <remarks><para>The interface specifies set of methods, which should be implemented by different
            template matching algorithms - algorithms, which search for the given template in specified
            image.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.ITemplateMatching.ProcessImage(System.Drawing.Bitmap,System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="template">Template image to search for.</param>
            <param name="searchZone">Rectangle in source image to search template for.</param>
            
            <returns>Returns array of found matchings.</returns>
            
        </member>
        <member name="M:AForge.Imaging.ITemplateMatching.ProcessImage(System.Drawing.Imaging.BitmapData,System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            <param name="templateData">Template image to search for.</param>
            <param name="searchZone">Rectangle in source image to search template for.</param>
            
            <returns>Returns array of found matchings.</returns>
            
        </member>
        <member name="M:AForge.Imaging.ITemplateMatching.ProcessImage(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="image">Unmanaged source image to process.</param>
            <param name="template">Unmanaged template image to search for.</param>
            <param name="searchZone">Rectangle in source image to search template for.</param>
            
            <returns>Returns array of found matchings.</returns>
            
        </member>
        <member name="T:AForge.Imaging.Filters.YCbCrReplaceChannel">
            <summary>
            Replace channel of YCbCr color space.
            </summary>
            
            <remarks><para>Replaces specified YCbCr channel of color image with
            specified grayscale imge.</para>
            
            <para>The filter is quite useful in conjunction with <see cref="T:AForge.Imaging.Filters.YCbCrExtractChannel"/> filter
            (however may be used alone in some cases). Using the <see cref="T:AForge.Imaging.Filters.YCbCrExtractChannel"/> filter
            it is possible to extract one of YCbCr channel, perform some image processing with it and then
            put it back into the original color image.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create YCbCrExtractChannel filter for channel extracting
            YCbCrExtractChannel extractFilter = new YCbCrExtractChannel(
                                                YCbCr.CbIndex );
            // extract Cb channel
            Bitmap cbChannel = extractFilter.Apply( image );
            // invert the channel
            Invert invertFilter = new Invert( );
            invertFilter.ApplyInPlace( cbChannel );
            // put the channel back into the source image
            YCbCrReplaceChannel replaceFilter = new YCbCrReplaceChannel(
                                                YCbCr.CbIndex, cbChannel );
            replaceFilter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/ycbcr_replace_channel.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.YCbCrExtractChannel"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.YCbCrReplaceChannel.#ctor(System.Int16,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.YCbCrReplaceChannel"/> class.
            </summary>
            
            <param name="channel">YCbCr channel to replace.</param>
            <param name="channelImage">Channel image to use for replacement.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.YCbCrReplaceChannel.#ctor(System.Int16,AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.YCbCrReplaceChannel"/> class.
            </summary>
            
            <param name="channel">YCbCr channel to replace.</param>
            <param name="channelImage">Unmanaged channel image to use for replacement.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.YCbCrReplaceChannel.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Channel image size does not match source
             image size.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrReplaceChannel.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrReplaceChannel.Channel">
            <summary>
            YCbCr channel to replace.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:AForge.Imaging.YCbCr.YIndex"/> (Y channel).</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid channel was specified.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrReplaceChannel.ChannelImage">
            <summary>
            Grayscale image to use for channel replacement.
            </summary>
            
            <remarks>
            <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.YCbCrReplaceChannel.UnmanagedChannelImage"/> property -
            only one channel image is allowed: managed or unmanaged.</note></para>
            </remarks>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Channel image should be 8bpp indexed image (grayscale).</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrReplaceChannel.UnmanagedChannelImage">
            <summary>
            Unmanaged grayscale image to use for channel replacement.
            </summary>
            
            <remarks>
            <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.YCbCrReplaceChannel.ChannelImage"/> property -
            only one channel image is allowed: managed or unmanaged.</note></para>
            </remarks>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Channel image should be 8bpp indexed image (grayscale).</exception>
            
        </member>
        <member name="T:AForge.Imaging.Filters.AdaptiveSmoothing">
            <summary>
            Adaptive Smoothing - noise removal with edges preserving.
            </summary>
            
            <remarks><para>The filter is aimed to perform image smoothing, but keeping sharp edges.
            This makes it applicable to additive noise removal and smoothing objects' interiors, but
            not applicable for spikes (salt and pepper noise) removal.</para>
            
            <para>The next calculations are done for each pixel:
            <list type="bullet">
            <item>weights are calculate for 9 pixels - pixel itself and 8 neighbors:
            <code lang="none">
            w(x, y) = exp( -1 * (Gx^2 + Gy^2) / (2 * factor^2) )
            Gx(x, y) = (I(x + 1, y) - I(x - 1, y)) / 2
            Gy(x, y) = (I(x, y + 1) - I(x, y - 1)) / 2
            </code>,
            where <see cref="P:AForge.Imaging.Filters.AdaptiveSmoothing.Factor">factor</see> is a configurable value determining smoothing's quality.</item>
            <item>sum of 9 weights is calclated (weightTotal);</item>
            <item>sum of 9 weighted pixel values is calculatd (total);</item>
            <item>destination pixel is calculated as <b>total / weightTotal</b>.</item>
            </list></para>
            
            <para>Description of the filter was found in <b>"An Edge Detection Technique Using
            the Facet Model and Parameterized Relaxation Labeling" by Ioannis Matalas, Student Member,
            IEEE, Ralph Benjamin, and Richard Kitney</b>.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            AdaptiveSmoothing filter = new AdaptiveSmoothing( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample13.png" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/adaptive_smooth.png" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.AdaptiveSmoothing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.AdaptiveSmoothing"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.AdaptiveSmoothing.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.AdaptiveSmoothing"/> class.
            </summary>
            
            <param name="factor">Factor value.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.AdaptiveSmoothing.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.AdaptiveSmoothing.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.AdaptiveSmoothing.Factor">
            <summary>
            Factor value.
            </summary>
            
            <remarks><para>Factor determining smoothing quality (see <see cref="T:AForge.Imaging.Filters.AdaptiveSmoothing"/>
            documentation).</para>
            
            <para>Default value is set to <b>3</b>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BlobsFiltering">
             <summary>
             Blobs filtering by size.
             </summary>
             
             <remarks><para>The filter performs filtering of blobs by their size in the specified
             source image - all blobs, which are smaller or bigger then specified limits, are
             removed from the image.</para>
             
             <para><note>The image processing filter treats all none black pixels as objects'
             pixels and all black pixel as background.</note></para>
             
             <para>The filter accepts 8 bpp grayscale images and 24/32
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             BlobsFiltering filter = new BlobsFiltering( );
             // configure filter
             filter.CoupledSizeFiltering = true;
             filter.MinWidth  = 70;
             filter.MinHeight = 70;
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample2.jpg" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/blobs_filtering.jpg" width="320" height="240"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.BlobCounter"/>
             <seealso cref="T:AForge.Imaging.BlobCounterBase"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BlobsFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BlobsFiltering"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BlobsFiltering.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BlobsFiltering"/> class.
            </summary>
            
            <param name="minWidth">Minimum allowed width of blob.</param>
            <param name="minHeight">Minimum allowed height of blob.</param>
            <param name="maxWidth">Maximum allowed width of blob.</param>
            <param name="maxHeight">Maximum allowed height of blob.</param>
            
            <remarks>This constructor creates an instance of <see cref="T:AForge.Imaging.Filters.BlobsFiltering"/> class
            with <see cref="P:AForge.Imaging.Filters.BlobsFiltering.CoupledSizeFiltering"/> property set to <b>false</b>.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BlobsFiltering.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BlobsFiltering"/> class.
            </summary>
            
            <param name="minWidth">Minimum allowed width of blob.</param>
            <param name="minHeight">Minimum allowed height of blob.</param>
            <param name="maxWidth">Maximum allowed width of blob.</param>
            <param name="maxHeight">Maximum allowed height of blob.</param>
            <param name="coupledSizeFiltering">Specifies if size filetering should be coupled or not.</param>
            
            <remarks><para>For information about coupled filtering mode see documentation for
            <see cref="P:AForge.Imaging.BlobCounterBase.CoupledSizeFiltering"/> property of <see cref="T:AForge.Imaging.BlobCounterBase"/>
            class.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BlobsFiltering.#ctor(AForge.Imaging.IBlobsFilter)">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BlobsFiltering"/> class.
             </summary>
             
             <param name="blobsFilter">Custom blobs' filtering routine to use
             (see <see cref="P:AForge.Imaging.BlobCounterBase.BlobsFilter"/>).</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BlobsFiltering.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BlobsFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.BlobsFiltering.CoupledSizeFiltering">
            <summary>
            Specifies if size filetering should be coupled or not.
            </summary>
            
            <remarks><para>See documentation for <see cref="P:AForge.Imaging.BlobCounterBase.CoupledSizeFiltering"/> property
            of <see cref="T:AForge.Imaging.BlobCounterBase"/> class for more information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BlobsFiltering.MinWidth">
            <summary>
            Minimum allowed width of blob.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BlobsFiltering.MinHeight">
            <summary>
            Minimum allowed height of blob.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BlobsFiltering.MaxWidth">
            <summary>
            Maximum allowed width of blob.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BlobsFiltering.MaxHeight">
            <summary>
            Maximum allowed height of blob.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BlobsFiltering.BlobsFilter">
            <summary>
            Custom blobs' filter to use.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.BlobCounterBase.BlobsFilter"/> for information
            about custom blobs' filtering routine.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.HitAndMiss">
            <summary>
            Hit-And-Miss operator from Mathematical Morphology.
            </summary>
            
            <remarks><para>The hit-and-miss filter represents generalization of <see cref="T:AForge.Imaging.Filters.Erosion"/>
            and <see cref="T:AForge.Imaging.Filters.Dilatation"/> filters by extending flexibility of structuring element and
            providing different modes of its work. Structuring element may contain:
            <list type="bullet">
            <item>1 - foreground;</item>
            <item>0 - background;</item>
            <item>-1 - don't care.</item>
            </list>
            </para>
            
            <para>Filter's mode is set by <see cref="P:AForge.Imaging.Filters.HitAndMiss.Mode"/> property. The list of modes and its
            documentation may be found in <see cref="T:AForge.Imaging.Filters.HitAndMiss.Modes"/> enumeration.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing. <b>Note</b>: grayscale images are treated
            as binary with 0 value equals to black and 255 value equals to white.</para>
            
            <para>Sample usage:</para>
            <code>
            // define kernel to remove pixels on the right side of objects
            // (pixel is removed, if there is white pixel on the left and
            // black pixel on the right)
            short[,] se = new short[,] {
                { -1, -1, -1 },
                {  1,  1,  0 },
                { -1, -1, -1 }
            };
            // create filter
            HitAndMiss filter = new HitAndMiss( se, HitAndMiss.Modes.Thinning );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample12.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/hit-and-miss.png" width="320" height="240"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HitAndMiss.#ctor(System.Int16[0:,0:])">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.HitAndMiss"/> class.
             </summary>
             
             <param name="se">Structuring element.</param>
            
             <remarks><para>Structuring elemement for the hit-and-miss morphological operator
             must be square matrix with odd size in the range of [3, 99].</para></remarks>
             
             <exception cref="T:System.ArgumentException">Invalid size of structuring element.</exception>
             
        </member>
        <member name="M:AForge.Imaging.Filters.HitAndMiss.#ctor(System.Int16[0:,0:],AForge.Imaging.Filters.HitAndMiss.Modes)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.HitAndMiss"/> class.
            </summary>
            
            <param name="se">Structuring element.</param>
            <param name="mode">Operation mode.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HitAndMiss.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HitAndMiss.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.HitAndMiss.Mode">
            <summary>
            Operation mode.
            </summary>
            
            <remarks><para>Mode to use for the filter. See <see cref="T:AForge.Imaging.Filters.HitAndMiss.Modes"/> enumeration
            for the list of available modes and their documentation.</para>
            
            <para>Default mode is set to <see cref="F:AForge.Imaging.Filters.HitAndMiss.Modes.HitAndMiss"/>.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.HitAndMiss.Modes">
            <summary>
            Hit and Miss modes.
            </summary>
            
            <remarks><para>Bellow is a list of modes meaning depending on pixel's correspondence
            to specified structuring element:
            <list type="bullet">
            <item><see cref="F:AForge.Imaging.Filters.HitAndMiss.Modes.HitAndMiss"/> - on match pixel is set to white, otherwise to black;</item>
            <item><see cref="F:AForge.Imaging.Filters.HitAndMiss.Modes.Thinning"/> - on match pixel is set to black, otherwise not changed.</item>
            <item><see cref="F:AForge.Imaging.Filters.HitAndMiss.Modes.Thickening"/> - on match pixel is set to white, otherwise not changed.</item>
            </list>
            </para></remarks>
            
        </member>
        <member name="F:AForge.Imaging.Filters.HitAndMiss.Modes.HitAndMiss">
            <summary>
            Hit and miss mode.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.HitAndMiss.Modes.Thinning">
            <summary>
            Thinning mode.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.HitAndMiss.Modes.Thickening">
            <summary>
            Thickening mode.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.HomogenityEdgeDetector">
            <summary>
            Homogenity edge detector.
            </summary>
            
            <remarks><para>The filter finds objects' edges by calculating maximum difference
            of processing pixel with neighboring pixels in 8 direction.</para>
            
            <para>Suppose 3x3 square element of the source image (x - is currently processed
            pixel):
            <code lang="none">
            P1 P2 P3
            P8  x P4
            P7 P6 P5
            </code>
            The corresponding pixel of the result image equals to:
            <code lang="none">
            max( |x-P1|, |x-P2|, |x-P3|, |x-P4|,
                 |x-P5|, |x-P6|, |x-P7|, |x-P8| )
            </code>
            </para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            HomogenityEdgeDetector filter = new HomogenityEdgeDetector( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample2.jpg" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/homogenity_edges.png" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.DifferenceEdgeDetector"/>
            <seealso cref="T:AForge.Imaging.Filters.SobelEdgeDetector"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HomogenityEdgeDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.HomogenityEdgeDetector"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HomogenityEdgeDetector.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HomogenityEdgeDetector.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.GaussianSharpen">
             <summary>
             Gaussian sharpen filter.
             </summary>
             
             <remarks><para>The filter performs <see cref="T:AForge.Imaging.Filters.Convolution">convolution filter</see> using
             the kernel, which is calculate with the help of <see cref="M:AForge.Math.Gaussian.Kernel2D(System.Int32)"/>
             method and then converted to integer sharpening kernel. First of all the integer kernel
             is calculated from <see cref="M:AForge.Math.Gaussian.Kernel2D(System.Int32)"/> by dividing all elements by
             the element with the smallest value. Then the integer kernel is converted to sharpen kernel by
             negating all kernel's elements (multiplying with <b>-1</b>), but the central kernel's element
             is calculated as <b>2 * sum - centralElement</b>, where <b>sum</b> is the sum off elements
             in the integer kernel before negating.</para>
             
             <para>For the list of supported pixel formats, see the documentation to <see cref="T:AForge.Imaging.Filters.Convolution"/>
             filter.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter with kernel size equal to 11
             // and Gaussia sigma value equal to 4.0
             GaussianSharpen filter = new GaussianSharpen( 4, 11 );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
            
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/gaussian_sharpen.jpg" width="480" height="361"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.Convolution"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GaussianSharpen.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GaussianSharpen"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GaussianSharpen.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GaussianSharpen"/> class.
            </summary>
            
            <param name="sigma">Gaussian sigma value.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GaussianSharpen.#ctor(System.Double,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GaussianSharpen"/> class.
            </summary>
            
            <param name="sigma">Gaussian sigma value.</param>
            <param name="size">Kernel size.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.GaussianSharpen.Sigma">
            <summary>
            Gaussian sigma value, [0.5, 5.0].
            </summary>
            
            <remarks><para>Sigma value for Gaussian function used to calculate
            the kernel.</para>
            
            <para>Default value is set to <b>1.4</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.GaussianSharpen.Size">
             <summary>
             Kernel size, [3, 5].
             </summary>
             
             <remarks><para>Size of Gaussian kernel.</para>
             
             <para>Default value is set to <b>5</b>.</para>
             </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Merge">
             <summary>
             Merge filter - get MAX of pixels in two images.
             </summary>
             
             <remarks><para>The merge filter takes two images (source and overlay images)
             of the same size and pixel format and produces an image, where each pixel equals
             to the maximum value of corresponding pixels from provided images.</para>
             
             <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Merge filter = new Merge( overlayImage );
             // apply the filter
             Bitmap resultImage = filter.Apply( sourceImage );
             </code>
            
             <para><b>Source image:</b></para>
             <img src="img/imaging/sample6.png" width="320" height="240"/>
             <para><b>Overlay image:</b></para>
             <img src="img/imaging/sample7.png" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/merge.png" width="320" height="240"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.Intersect"/>
             <seealso cref="T:AForge.Imaging.Filters.Difference"/>
             <seealso cref="T:AForge.Imaging.Filters.Add"/>
             <seealso cref="T:AForge.Imaging.Filters.Subtract"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.Merge.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Merge"/> class
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Merge.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Merge"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Merge.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Merge"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Merge.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Merge.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.DocumentSkewChecker">
             <summary>
             Skew angle checker for scanned documents.
             </summary>
            
             <remarks><para>The class implements document's skew checking algorithm, which is based
             on <see cref="T:AForge.Imaging.HoughLineTransformation">Hough line transformation</see>. The algorithm
             is based on searching for text base lines - black line of text bottoms' followed
             by white line below.</para>
             
             <para><note>The routine supposes that a white-background document is provided
             with black letters. The algorithm is not supposed for any type of objects, but for
             document images with text.</note></para>
             
             <para>The range of angles to detect is controlled by <see cref="P:AForge.Imaging.DocumentSkewChecker.MaxSkewToDetect"/> property.</para>
             
             <para>The filter accepts 8 bpp grayscale images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create instance of skew checker
             DocumentSkewChecker skewChecker = new DocumentSkewChecker( );
             // get documents skew angle
             double angle = skewChecker.GetSkewAngle( documentImage );
             // create rotation filter
             RotateBilinear rotationFilter = new RotateBilinear( -angle );
             rotationFilter.FillColor = Color.White;
             // rotate image applying the filter
             Bitmap rotatedImage = rotationFilter.Apply( documentImage );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample10.png" width="300" height="184"/>
             <para><b>Deskewed image:</b></para>
             <img src="img/imaging/deskew.png" width="335" height="250"/> 
             </remarks>
             
             <seealso cref="T:AForge.Imaging.HoughLineTransformation"/>
            
        </member>
        <member name="M:AForge.Imaging.DocumentSkewChecker.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.DocumentSkewChecker"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.DocumentSkewChecker.GetSkewAngle(System.Drawing.Bitmap)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="image">Document's image to get skew angle of.</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.DocumentSkewChecker.GetSkewAngle(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="image">Document's image to get skew angle of.</param>
            <param name="rect">Image's rectangle to process (used to exclude processing of
            regions, which are not relevant to skew detection).</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.DocumentSkewChecker.GetSkewAngle(System.Drawing.Imaging.BitmapData)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="imageData">Document's image data to get skew angle of.</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.DocumentSkewChecker.GetSkewAngle(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="imageData">Document's image data to get skew angle of.</param>
            <param name="rect">Image's rectangle to process (used to exclude processing of
            regions, which are not relevant to skew detection).</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.DocumentSkewChecker.GetSkewAngle(AForge.Imaging.UnmanagedImage)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="image">Document's unmanaged image to get skew angle of.</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.DocumentSkewChecker.GetSkewAngle(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="image">Document's unmanaged image to get skew angle of.</param>
            <param name="rect">Image's rectangle to process (used to exclude processing of
            regions, which are not relevant to skew detection).</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.DocumentSkewChecker.StepsPerDegree">
            <summary>
            Steps per degree, [1, 10].
            </summary>
            
            <remarks><para>The value defines quality of Hough transform and its ability to detect
            line slope precisely.</para>
            
            <para>Default value is set to <b>1</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.DocumentSkewChecker.MaxSkewToDetect">
             <summary>
             Maximum skew angle to detect, [0, 45] degrees.
             </summary>
             
             <remarks><para>The value sets maximum document's skew angle to detect.
             Document's skew angle can be as positive (rotated counter clockwise), as negative
             (rotated clockwise). So setting this value to 25, for example, will lead to
             [-25, 25] degrees detection range.</para>
            
             <para>Scanned documents usually have skew in the [-20, 20] degrees range.</para>
             
             <para>Default value is set to <b>30</b>.</para>
             </remarks>
             
        </member>
        <member name="P:AForge.Imaging.DocumentSkewChecker.MinBeta">
             <summary>
             Minimum angle to detect skew in degrees.
             </summary>
            
             <remarks><para><note>The property is deprecated and setting it has not any effect.
             Use <see cref="P:AForge.Imaging.DocumentSkewChecker.MaxSkewToDetect"/> property instead.</note></para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.DocumentSkewChecker.MaxBeta">
             <summary>
             Maximum angle to detect skew in degrees.
             </summary>
            
             <remarks><para><note>The property is deprecated and setting it has not any effect.
             Use <see cref="P:AForge.Imaging.DocumentSkewChecker.MaxSkewToDetect"/> property instead.</note></para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.DocumentSkewChecker.LocalPeakRadius">
            <summary>
            Radius for searching local peak value, [1, 10].
            </summary>
            
            <remarks><para>The value determines radius around a map's value, which is analyzed to determine
            if the map's value is a local maximum in specified area.</para>
            
            <para>Default value is set to <b>4</b>.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Textures.WoodTexture">
             <summary>
             Wood texture.
             </summary>
             
             <remarks><para>The texture generator creates textures with effect of
             rings on trunk's shear. The <see cref="P:AForge.Imaging.Textures.WoodTexture.Rings"/> property allows to specify the
             desired amount of wood rings.</para>
             
             <para>The generator is based on the <see cref="T:AForge.Math.PerlinNoise">Perlin noise function</see>.</para>
             
             <para>Sample usage:</para>
             <code>
             // create texture generator
             WoodTexture textureGenerator = new WoodTexture( );
             // generate new texture
             float[,] texture = textureGenerator.Generate( 320, 240 );
             // convert it to image to visualize
             Bitmap textureImage = TextureTools.ToBitmap( texture );
             </code>
            
             <para><b>Result image:</b></para>
             <img src="img/imaging/wood_texture.jpg" width="320" height="240"/>
             </remarks>
             
        </member>
        <member name="M:AForge.Imaging.Textures.WoodTexture.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Textures.WoodTexture"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Textures.WoodTexture.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Textures.WoodTexture"/> class.
            </summary>
            
            <param name="rings">Wood rings amount.</param>
            
        </member>
        <member name="M:AForge.Imaging.Textures.WoodTexture.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Textures.WoodTexture.Reset">
            <summary>
            Reset generator.
            </summary>
            
            <remarks>Regenerates internal random numbers.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Textures.WoodTexture.Rings">
            <summary>
            Wood rings amount, ≥ 3.
            </summary>
            
            <remarks><para>The property sets the amount of wood rings, which make effect of
            rings on trunk's shear.</para>
            
            <para>Default value is set to <b>12</b>.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.MemoryManager">
            <summary>
            Internal memory manager used by image processing routines.
            </summary>
            
            <remarks><para>The memory manager supports memory allocation/deallocation
            caching. Caching means that memory blocks may be not freed on request, but
            kept for later reuse.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.MemoryManager.Alloc(System.Int32)">
            <summary>
            Allocate unmanaged memory.
            </summary>
            
            <param name="size">Memory size to allocate.</param>
            
            <returns>Return's pointer to the allocated memory buffer.</returns>
            
            <remarks>The method allocates requested amount of memory and returns pointer to it. It may avoid allocation
            in the case some caching scheme is uses and there is already enough allocated memory available.</remarks>
            
            <exception cref="T:System.OutOfMemoryException">There is insufficient memory to satisfy the request.</exception>
            
        </member>
        <member name="M:AForge.Imaging.MemoryManager.Free(System.IntPtr)">
            <summary>
            Free unmanaged memory.
            </summary>
            
            <param name="pointer">Pointer to memory buffer to free.</param>
            
            <remarks>This method may skip actual deallocation of memory and keep it for future <see cref="M:AForge.Imaging.MemoryManager.Alloc(System.Int32)"/> requests,
            if some caching scheme is used.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.MemoryManager.FreeUnusedMemory">
            <summary>
            Force freeing unused memory.
            </summary>
            
            <remarks>Frees and removes from cache memory blocks, which are not used by users.</remarks>
            
            <returns>Returns number of freed memory blocks.</returns>
            
        </member>
        <member name="P:AForge.Imaging.MemoryManager.MaximumCacheSize">
            <summary>
            Maximum amount of memory blocks to keep in cache.
            </summary>
            
            <remarks><para>The value specifies the amount of memory blocks, which could be
            cached by the memory manager.</para>
            
            <para>Default value is set to 3. Maximum value is 10.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.MemoryManager.CurrentCacheSize">
            <summary>
            Current amount of memory blocks in cache.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.MemoryManager.BusyMemoryBlocks">
            <summary>
            Amount of busy memory blocks in cache (which were not freed yet by user).
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.MemoryManager.FreeMemoryBlocks">
            <summary>
            Amount of free memory blocks in cache (which are not busy by users).
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.MemoryManager.CachedMemory">
            <summary>
            Amount of cached memory in bytes.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.MemoryManager.MaxSizeToCache">
            <summary>
            Maximum memory block's size in bytes, which could be cached.
            </summary>
            
            <remarks>Memory blocks, which size is greater than this value, are not cached.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.MemoryManager.MinSizeToCache">
            <summary>
            Minimum memory block's size in bytes, which could be cached.
            </summary>
            
            <remarks>Memory blocks, which size is less than this value, are not cached.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.YCbCrExtractChannel">
            <summary>
            Extract YCbCr channel from image.
            </summary>
            
            <remarks><para>The filter extracts specified YCbCr channel of color image and returns
            it in the form of grayscale image.</para>
            
            <para>The filter accepts 24 and 32 bpp color images and produces
            8 bpp grayscale images.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            YCbCrExtractChannel filter = new YCbCrExtractChannel( YCbCr.CrIndex );
            // apply the filter
            Bitmap crChannel = filter.Apply( image );
            </code>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.YCbCrReplaceChannel"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.YCbCrExtractChannel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.YCbCrExtractChannel"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.YCbCrExtractChannel.#ctor(System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.YCbCrExtractChannel"/> class.
            </summary>
            
            <param name="channel">YCbCr channel to extract.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.YCbCrExtractChannel.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrExtractChannel.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrExtractChannel.Channel">
            <summary>
            YCbCr channel to extract.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:AForge.Imaging.YCbCr.YIndex"/> (Y channel).</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid channel was specified.</exception>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ResizeNearestNeighbor">
            <summary>
            Resize image using nearest neighbor algorithm.
            </summary>
            
            <remarks><para>The class implements image resizing filter using nearest
            neighbor algorithm, which does not assume any interpolation.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ResizeNearestNeighbor filter = new ResizeNearestNeighbor( 400, 300 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample9.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/resize_nearest.png" width="400" height="300"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.ResizeBilinear"/>
            <seealso cref="T:AForge.Imaging.Filters.ResizeBicubic"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ResizeNearestNeighbor.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ResizeNearestNeighbor"/> class.
            </summary>
            
            <param name="newWidth">Width of the new image.</param>
            <param name="newHeight">Height of the new image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ResizeNearestNeighbor.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ResizeNearestNeighbor.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.Crop">
            <summary>
            Crop an image.
            </summary>
            
            <remarks>
            <para>The filter crops an image providing a new image, which contains only the specified
            rectangle of the original image.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Crop filter = new Crop( new Rectangle( 75, 75, 320, 240 ) );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="img/imaging/crop.jpg" width="320" height="240" />
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Crop.#ctor(System.Drawing.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Crop"/> class.
            </summary>
            
            <param name="rect">Rectangle to crop.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Crop.CalculateNewImageSize(AForge.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Crop.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Crop.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.Crop.Rectangle">
            <summary>
            Rectangle to crop.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.PointedColorFloodFill">
            <summary>
            Flood filling with specified color starting from specified point.
            </summary>
            
            <remarks><para>The filter performs image's area filling (4 directional) starting
            from the <see cref="P:AForge.Imaging.Filters.PointedColorFloodFill.StartingPoint">specified point</see>. It fills
            the area of the pointed color, but also fills other colors, which
            are similar to the pointed within specified <see cref="P:AForge.Imaging.Filters.PointedColorFloodFill.Tolerance">tolerance</see>.
            The area is filled using <see cref="P:AForge.Imaging.Filters.PointedColorFloodFill.FillColor">specified fill color</see>.
            </para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            PointedColorFloodFill filter = new PointedColorFloodFill( );
            // configure the filter
            filter.Tolerance = Color.FromArgb( 150, 92, 92 );
            filter.FillColor = Color.FromArgb( 255, 255, 255 );
            filter.StartingPoint = new IntPoint( 150, 100 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/pointed_color_fill.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.PointedMeanFloodFill"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.PointedColorFloodFill.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.PointedColorFloodFill"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.PointedColorFloodFill.#ctor(System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.PointedColorFloodFill"/> class.
            </summary>
            
            <param name="fillColor">Fill color.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.PointedColorFloodFill.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.PointedColorFloodFill.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.PointedColorFloodFill.Tolerance">
            <summary>
            Flood fill tolerance.
            </summary>
            
            <remarks><para>The tolerance value determines which colors to fill. If the
            value is set to 0, then only color of the <see cref="P:AForge.Imaging.Filters.PointedColorFloodFill.StartingPoint">pointed pixel</see>
            is filled. If the value is not 0, then other colors may be filled as well,
            which are similar to the color of the pointed pixel within the specified
            tolerance.</para>
            
            <para>The tolerance value is specified as <see cref="T:System.Drawing.Color"/>,
            where each component (R, G and B) represents tolerance for the corresponding
            component of color. This allows to set different tolerances for red, green
            and blue components.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.PointedColorFloodFill.FillColor">
            <summary>
            Fill color.
            </summary>
            
            <remarks><para>The fill color is used to fill image's area starting from the
            <see cref="P:AForge.Imaging.Filters.PointedColorFloodFill.StartingPoint">specified point</see>.</para>
            
            <para>For grayscale images the color needs to be specified with all three
            RGB values set to the same value, (128, 128, 128) for example.</para>
            
            <para>Default value is set to <b>black</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.PointedColorFloodFill.StartingPoint">
            <summary>
            Point to start filling from.
            </summary>
            
            <remarks><para>The property allows to set the starting point, where filling is
            started from.</para>
            
            <remarks>Default value is set to <b>(0, 0)</b>.</remarks>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Erosion3x3">
            <summary>
            Erosion operator from Mathematical Morphology with 3x3 structuring element.
            </summary>
            
            <remarks><para>The filter represents an optimized version of <see cref="T:AForge.Imaging.Filters.Erosion"/>
            filter, which is aimed for grayscale image processing with 3x3 structuring element.</para>
            
            <para>See <see cref="T:AForge.Imaging.Filters.Erosion"/> filter, which represents generic version of
            erosion filter supporting custom structuring elements and wider range of image formats.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Erosion"/>
            <seealso cref="T:AForge.Imaging.Filters.BinaryErosion3x3"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Erosion3x3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Erosion3x3"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Erosion3x3.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Processing rectangle mast be at least 3x3 in size.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Erosion3x3.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.FlatFieldCorrection">
            <summary>
            Flat field correction filter.
            </summary>
            
            <remarks><para>The goal of flat-field correction is to remove artifacts from 2-D images that
            are caused by variations in the pixel-to-pixel sensitivity of the detector and/or by distortions
            in the optical path. The filter requires two images for the input - source image, which represents
            acquisition of some objects (using microscope, for example), and background image, which is taken
            without any objects presented. The source image is corrected using the formula: <b>src = bgMean * src / bg</b>,
            where <b>src</b> - source image's pixel value, <b>bg</b> - background image's pixel value, <b>bgMean</b> - mean
            value of background image.</para>
            
            <para><note>If background image is not provided, then it will be automatically generated on each filter run
            from source image. The automatically generated background image is produced running Gaussian Blur on the
            original image with (sigma value is set to 5, kernel size is set to 21). Before blurring the original image
            is resized to 1/3 of its original size and then the result of blurring is resized back to the original size.
            </note></para>
            
            <para><note>The class processes only grayscale (8 bpp indexed) and color (24 bpp) images.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            FlatFieldCorrection filter = new FlatFieldCorrection( bgImage );
            // process image
            filter.ApplyInPlace( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="img/imaging/sample4.jpg" width="480" height="387" />
            <para><b>Background image:</b></para>
            <img src="img/imaging/bg.jpg" width="480" height="387" />
            <para><b>Result image:</b></para>
            <img src="img/imaging/flat_field.jpg" width="480" height="387" />
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FlatFieldCorrection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.FlatFieldCorrection"/> class.
            </summary>
            
            <remarks><para>This constructor does not set background image, which means that background
            image will be generated on the fly on each filter run. The automatically generated background
            image is produced running Gaussian Blur on the original image with (sigma value is set to 5,
            kernel size is set to 21). Before blurring the original image is resized to 1/3 of its original size
            and then the result of blurring is resized back to the original size.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FlatFieldCorrection.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.FlatFieldCorrection"/> class.
            </summary>
            
            <param name="backgroundImage">Background image used for flat field correction.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FlatFieldCorrection.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.FlatFieldCorrection.BackgoundImage">
            <summary>
            Background image used for flat field correction.
            </summary>
            
            <remarks><para>The property sets the background image (without any objects), which will be used
            for illumination correction of an image passed to the filter.</para>
            
            <para><note>The background image must have the same size and pixel format as source image.
            Otherwise exception will be generated when filter is applied to source image.</note></para>
            
            <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.FlatFieldCorrection.UnmanagedBackgoundImage"/> property -
            only one background image is allowed: managed or unmanaged.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.FlatFieldCorrection.UnmanagedBackgoundImage">
            <summary>
            Background image used for flat field correction.
            </summary>
            
            <remarks><para>The property sets the background image (without any objects), which will be used
            for illumination correction of an image passed to the filter.</para>
            
            <para><note>The background image must have the same size and pixel format as source image.
            Otherwise exception will be generated when filter is applied to source image.</note></para>
            
            <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.FlatFieldCorrection.BackgoundImage"/> property -
            only one background image is allowed: managed or unmanaged.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.FlatFieldCorrection.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
            
             <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.HSLFiltering">
            <summary>
            Color filtering in HSL color space.
            </summary>
            
            <remarks><para>The filter operates in <b>HSL</b> color space and filters
            pixels, which color is inside/outside of the specified HSL range -
            it keeps pixels with colors inside/outside of the specified range and fills the
            rest with <see cref="P:AForge.Imaging.Filters.HSLFiltering.FillColor">specified color</see>.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            HSLFiltering filter = new HSLFiltering( );
            // set color ranges to keep
            filter.Hue = new IntRange( 335, 0 );
            filter.Saturation = new Range( 0.6f, 1 );
            filter.Luminance = new Range( 0.1f, 1 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/hsl_filtering.jpg" width="480" height="361"/>
            
            <para>Sample usage with saturation update only:</para>
            <code>
            // create filter
            HSLFiltering filter = new HSLFiltering( );
            // configure the filter
            filter.Hue = new IntRange( 340, 20 );
            filter.UpdateLuminance = false;
            filter.UpdateHue = false;
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Result image:</b></para>
            <img src="img/imaging/hsl_filtering2.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.ColorFiltering"/>
            <seealso cref="T:AForge.Imaging.Filters.YCbCrFiltering"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HSLFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.HSLFiltering"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.HSLFiltering.#ctor(AForge.IntRange,AForge.Range,AForge.Range)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.HSLFiltering"/> class.
            </summary>
            
            <param name="hue">Range of hue component.</param>
            <param name="saturation">Range of saturation component.</param>
            <param name="luminance">Range of luminance component.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HSLFiltering.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HSLFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.HSLFiltering.Hue">
            <summary>
            Range of hue component, [0, 359].
            </summary>
            
            <remarks><note>Because of hue values are cycled, the minimum value of the hue
            range may have bigger integer value than the maximum value, for example [330, 30].</note></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HSLFiltering.Saturation">
            <summary>
            Range of saturation component, [0, 1].
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.HSLFiltering.Luminance">
            <summary>
            Range of luminance component, [0, 1].
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.HSLFiltering.FillColor">
            <summary>
            Fill color used to fill filtered pixels.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.HSLFiltering.FillOutsideRange">
            <summary>
            Determines, if pixels should be filled inside or outside specified
            color range.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/>, which means
            the filter removes colors outside of the specified range.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HSLFiltering.UpdateHue">
            <summary>
            Determines, if hue value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if hue of filtered pixels should be
            updated with value from <see cref="P:AForge.Imaging.Filters.HSLFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HSLFiltering.UpdateSaturation">
            <summary>
            Determines, if saturation value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if saturation of filtered pixels should be
            updated with value from <see cref="P:AForge.Imaging.Filters.HSLFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HSLFiltering.UpdateLuminance">
            <summary>
            Determines, if luminance value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if luminance of filtered pixels should be
            updated with value from <see cref="P:AForge.Imaging.Filters.HSLFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.GaussianBlur">
             <summary>
             Gaussian blur filter.
             </summary>
             
             <remarks><para>The filter performs <see cref="T:AForge.Imaging.Filters.Convolution">convolution filter</see> using
             the kernel, which is calculate with the help of <see cref="M:AForge.Math.Gaussian.Kernel2D(System.Int32)"/>
             method and then converted to integer kernel by dividing all elements by the element with the
             smallest value. Using the kernel the convolution filter is known as Gaussian blur.</para>
             
             <para>Using <see cref="P:AForge.Imaging.Filters.GaussianBlur.Sigma"/> property it is possible to configure
             <see cref="P:AForge.Math.Gaussian.Sigma">sigma value of Gaussian function</see>.</para>
             
             <para>For the list of supported pixel formats, see the documentation to <see cref="T:AForge.Imaging.Filters.Convolution"/>
             filter.</para>
             
             <para><note>By default this filter sets <see cref="P:AForge.Imaging.Filters.Convolution.ProcessAlpha"/> property to
             <see langword="true"/>, so the alpha channel of 32 bpp and 64 bpp images is blurred as well.
             </note></para>
             
             <para>Sample usage:</para>
             <code>
             // create filter with kernel size equal to 11
             // and Gaussia sigma value equal to 4.0
             GaussianBlur filter = new GaussianBlur( 4, 11 );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
            
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/gaussian_blur.jpg" width="480" height="361"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.Convolution"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.GaussianBlur.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GaussianBlur"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GaussianBlur.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GaussianBlur"/> class.
            </summary>
            
            <param name="sigma">Gaussian sigma value.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GaussianBlur.#ctor(System.Double,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GaussianBlur"/> class.
            </summary>
            
            <param name="sigma">Gaussian sigma value.</param>
            <param name="size">Kernel size.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.GaussianBlur.Sigma">
            <summary>
            Gaussian sigma value, [0.5, 5.0].
            </summary>
            
            <remarks><para>Sigma value for Gaussian function used to calculate
            the kernel.</para>
            
            <para>Default value is set to <b>1.4</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.GaussianBlur.Size">
            <summary>
            Kernel size, [3, 21].
            </summary>
            
            <remarks><para>Size of Gaussian kernel.</para>
            
            <para>Default value is set to <b>5</b>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Edges">
             <summary>
             Simple edge detector.
             </summary>
             
             <remarks><para>The filter performs <see cref="T:AForge.Imaging.Filters.Convolution">convolution filter</see> using
             the edges kernel:</para>
             
             <code lang="none">
              0  -1   0
             -1   4  -1
              0  -1   0
             </code>
             
             <para>For the list of supported pixel formats, see the documentation to <see cref="T:AForge.Imaging.Filters.Convolution"/>
             filter.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Edges filter = new Edges( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
            
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/edges.png" width="480" height="361"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.Convolution"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Edges.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Edges"/> class.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.BaseFilter2">
            <summary>
            Base class for filters, which operate with two images of the same size and format and
            produce new image as a result.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which can
            be applied to an image producing new image as a result of image processing.</para>
            
            <para>The base class is aimed for such type of filters, which require additional image
            to process the source image. The additional image is set by <see cref="P:AForge.Imaging.Filters.BaseFilter2.OverlayImage"/>
            or <see cref="P:AForge.Imaging.Filters.BaseFilter2.UnmanagedOverlayImage"/> property and must have the same size and pixel format
            as source image. See documentation of particular inherited class for information
            about overlay image purpose.
            </para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseFilter2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BaseFilter2"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseFilter2.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BaseFilter2"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseFilter2.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BaseFilter2"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseFilter2.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BaseFilter2.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="sourceData">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
             <param name="destinationData">Destination image data</param>
             
             <remarks><para>Overlay image size and pixel format is checked by this base class, before
             passing execution to inherited class.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseFilter2.OverlayImage">
             <summary>
             Overlay image.
             </summary>
             
             <remarks>
             <para>The property sets an overlay image, which will be used as the second image required
             to process source image. See documentation of particular inherited class for information
             about overlay image purpose.
             </para>
             
             <para><note>Overlay image must have the same size and pixel format as source image.
             Otherwise exception will be generated when filter is applied to source image.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.BaseFilter2.UnmanagedOverlayImage"/> property -
             only one overlay image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BaseFilter2.UnmanagedOverlayImage">
             <summary>
             Unmanaged overlay image.
             </summary>
             
             <remarks>
             <para>The property sets an overlay image, which will be used as the second image required
             to process source image. See documentation of particular inherited class for information
             about overlay image purpose.
             </para>
             
             <para><note>Overlay image must have the same size and pixel format as source image.
             Otherwise exception will be generated when filter is applied to source image.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.BaseFilter2.OverlayImage"/> property -
             only one overlay image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.OtsuThreshold">
            <summary>
            Otsu thresholding.
            </summary>
            
            <remarks><para>The class implements Otsu thresholding, which is described in
            <b>N. Otsu, "A threshold selection method from gray-level histograms", IEEE Trans. Systems,
            Man and Cybernetics 9(1), pp. 62–66, 1979.</b></para>
            
            <para>This implementation instead of minimizing the weighted within-class variance
            does maximization of between-class variance, what gives the same result. The approach is
            described in <a href="http://sampl.ece.ohio-state.edu/EE863/2004/ECE863-G-segclust2.ppt">this presentation</a>.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            OtsuThreshold filter = new OtsuThreshold( );
            // apply the filter
            filter.ApplyInPlace( image );
            // check threshold value
            byte t = filter.ThresholdValue;
            // ...
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample11.png" width="256" height="256"/>
            <para><b>Result image (calculated threshold is 97):</b></para>
            <img src="img/imaging/otsu_threshold.png" width="256" height="256"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.IterativeThreshold"/>
            <seealso cref="T:AForge.Imaging.Filters.SISThreshold"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.OtsuThreshold.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.OtsuThreshold"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.OtsuThreshold.CalculateThreshold(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:AForge.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.OtsuThreshold.CalculateThreshold(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:AForge.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.OtsuThreshold.CalculateThreshold(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:AForge.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.OtsuThreshold.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.OtsuThreshold.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.OtsuThreshold.ThresholdValue">
            <summary>
            Threshold value.
            </summary>
            
            <remarks>The property is read only and represents the value, which
            was automaticaly calculated using Otsu algorithm.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.IterativeThreshold">
            <summary>
            Iterative threshold search and binarization.
            </summary>
            
            <remarks>
            <para>The algorithm works in the following way:
            <list type="bullet">
            <item>select any start threshold;</item>
            <item>compute average value of Background (µB) and Object (µO) values:
            1) all pixels with a value that is below threshold, belong to the Background values;
            2) all pixels greater or equal threshold, belong to the Object values.
            </item>
            <item>calculate new thresghold: (µB + µO) / 2;</item>
            <item>if |oldThreshold - newThreshold| is less than a given manimum allowed error, then stop iteration process
            and create the binary image with the new threshold.</item>
            </list>
            </para>
            
            <para>For additional information see <b>Digital Image Processing, Gonzalez/Woods. Ch.10 page:599</b>.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images for processing.</para>
            
            <para><note>Since the filter can be applied as to 8 bpp and to 16 bpp images,
            the initial value of <see cref="P:AForge.Imaging.Filters.Threshold.ThresholdValue"/> property should be set appropriately to the
            pixel format. In the case of 8 bpp images the threshold value is in the [0, 255] range, but
            in the case of 16 bpp images the threshold value is in the [0, 65535] range.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            IterativeThreshold filter = new IterativeThreshold( 2, 128 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample11.png" width="256" height="256"/>
            <para><b>Result image (calculated threshold is 102):</b></para>
            <img src="img/imaging/iterative_threshold.png" width="256" height="256"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.OtsuThreshold"/>
            <seealso cref="T:AForge.Imaging.Filters.SISThreshold"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IterativeThreshold.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.IterativeThreshold"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IterativeThreshold.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.IterativeThreshold"/> class.
            </summary>
            
            <param name="minError">Minimum allowed error, that ends the iteration process.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IterativeThreshold.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.IterativeThreshold"/> class.
            </summary>
            
            <param name="minError">Minimum allowed error, that ends the iteration process.</param>
            <param name="threshold">Initial threshold value.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IterativeThreshold.CalculateThreshold(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:AForge.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should
            8 bpp grayscale (indexed) or 16 bpp grayscale image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IterativeThreshold.CalculateThreshold(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:AForge.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should
            8 bpp grayscale (indexed) or 16 bpp grayscale image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IterativeThreshold.CalculateThreshold(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:AForge.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should
            8 bpp grayscale (indexed) or 16 bpp grayscale image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.IterativeThreshold.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.IterativeThreshold.MinimumError">
            <summary>
            Minimum error, value when iterative threshold search is stopped.
            </summary>
            
            <remarks>Default value is set to <b>0</b>.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ThresholdedEuclideanDifference">
            <summary>
            Calculate Euclidean difference between two images and threshold it.
            </summary>
            
            <remarks><para>The filter produces similar to <see cref="T:AForge.Imaging.Filters.ThresholdedDifference"/>, however it uses
            Euclidean distance for finding difference between pixel values instead of Manhattan distance. Result of this
            image processing routine may be useful in motion detection applications or finding areas of significant
            difference.</para>
            
            <para>The filter accepts 8 and 24/32color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ThresholdedEuclideanDifference filter = new ThresholdedEuclideanDifference( 60 );
            // apply the filter
            filter.OverlayImage = backgroundImage;
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="img/imaging/object.jpg" width="320" height="240"/>
            <para><b>Background image:</b></para>
            <img src="img/imaging/background.jpg" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/thresholded_euclidean_difference.png" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.ThresholdedDifference"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ThresholdedEuclideanDifference.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ThresholdedEuclideanDifference"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ThresholdedEuclideanDifference.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ThresholdedEuclideanDifference"/> class.
            </summary>
            
            <param name="threshold">Difference threshold (see <see cref="P:AForge.Imaging.Filters.ThresholdedEuclideanDifference.Threshold"/>).</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ThresholdedEuclideanDifference.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="overlay">Overlay image data.</param>
            <param name="destinationData">Destination image data</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ThresholdedEuclideanDifference.Threshold">
            <summary>
            Difference threshold.
            </summary>
            
            <remarks><para>The property specifies difference threshold. If difference between pixels of processing image
            and overlay image is greater than this value, then corresponding pixel of result image is set to white; otherwise
            black.
            </para>
            
            <para>Default value is set to <b>15</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ThresholdedEuclideanDifference.WhitePixelsCount">
             <summary>
             Number of pixels which were set to white in destination image during last image processing call.
             </summary>
            
             <remarks><para>The property may be useful to determine amount of difference between two images which,
             for example, may be treated as amount of motion in motion detection applications, etc.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ThresholdedEuclideanDifference.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Intersect">
            <summary>
            Intersect filter - get MIN of pixels in two images.
            </summary>
            
            <remarks><para>The intersect filter takes two images (source and overlay images)
            of the same size and pixel format and produces an image, where each pixel equals
            to the minimum value of corresponding pixels from provided images.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Intersect filter = new Intersect( overlayImage );
            // apply the filter
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="img/imaging/sample6.png" width="320" height="240"/>
            <para><b>Overlay image:</b></para>
            <img src="img/imaging/sample7.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/intersect.png" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Merge"/>
            <seealso cref="T:AForge.Imaging.Filters.Difference"/>
            <seealso cref="T:AForge.Imaging.Filters.Add"/>
            <seealso cref="T:AForge.Imaging.Filters.Subtract"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Intersect.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Merge"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Intersect.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Merge"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Intersect.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Intersect"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Intersect.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Intersect.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.ColorReduction.SierraColorDithering">
            <summary>
            Color dithering using Sierra error diffusion.
            </summary>
            
            <remarks><para>The image processing routine represents color dithering algorithm, which is based on
            error diffusion dithering with Sierra coefficients. Error is diffused
            on 10 neighbor pixels with next coefficients:</para>
            <code lang="none">
                    | * | 5 | 3 |
            | 2 | 4 | 5 | 4 | 2 |
                | 2 | 3 | 2 |
            
            / 32
            </code>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
            produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
            <see cref="P:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
            color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
            
            <para>Sample usage:</para>
            <code>
            // create dithering routine (use default color table)
            SierraColorDithering dithering = new SierraColorDithering( );
            // apply the dithering routine
            Bitmap newImage = dithering.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/color_sierra.png" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.ColorReduction.BurkesColorDithering"/>
            <seealso cref="T:AForge.Imaging.ColorReduction.FloydSteinbergColorDithering"/>
            <seealso cref="T:AForge.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering"/>
            <seealso cref="T:AForge.Imaging.ColorReduction.StuckiColorDithering"/>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.SierraColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ColorReduction.SierraColorDithering"/> class.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Textures.TextureTools">
            <summary>
            Texture tools.
            </summary>
            
            <remarks><para>The class represents collection of different texture tools, like
            converting a texture to/from grayscale image.</para>
            
            <para>Sample usage:</para>
            <code>
            // create texture generator
            WoodTexture textureGenerator = new WoodTexture( );
            // generate new texture
            float[,] texture = textureGenerator.Generate( 320, 240 );
            // convert it to image to visualize
            Bitmap textureImage = TextureTools.ToBitmap( texture );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Textures.TextureTools.ToBitmap(System.Single[0:,0:])">
            <summary>
            Convert texture to grayscale bitmap.
            </summary>
            
            <param name="texture">Texture to convert to bitmap.</param>
            
            <returns>Returns bitmap of the texture.</returns>
            
        </member>
        <member name="M:AForge.Imaging.Textures.TextureTools.FromBitmap(System.Drawing.Bitmap)">
            <summary>
            Convert grayscale bitmap to texture.
            </summary>
            
            <param name="image">Image to convert to texture.</param>
            
            <returns>Returns texture as 2D float array.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Only grayscale (8 bpp indexed images) are supported.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Textures.TextureTools.FromBitmap(System.Drawing.Imaging.BitmapData)">
            <summary>
            Convert grayscale bitmap to texture
            </summary>
            
            <param name="imageData">Image data to convert to texture</param>
            
            <returns>Returns texture as 2D float array.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Only grayscale (8 bpp indexed images) are supported.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Textures.TextureTools.FromBitmap(AForge.Imaging.UnmanagedImage)">
            <summary>
            Convert grayscale bitmap to texture.
            </summary>
            
            <param name="image">Image data to convert to texture.</param>
            
            <returns>Returns texture as 2D float array.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Only grayscale (8 bpp indexed images) are supported.</exception>
            
        </member>
        <member name="T:AForge.Imaging.Textures.TextileTexture">
             <summary>
             Textile texture.
             </summary>
             
             <remarks><para>The texture generator creates textures with effect of textile.</para>
             
             <para>The generator is based on the <see cref="T:AForge.Math.PerlinNoise">Perlin noise function</see>.</para>
             
             <para>Sample usage:</para>
             <code>
             // create texture generator
             TextileTexture textureGenerator = new TextileTexture( );
             // generate new texture
             float[,] texture = textureGenerator.Generate( 320, 240 );
             // convert it to image to visualize
             Bitmap textureImage = TextureTools.ToBitmap( texture );
             </code>
            
             <para><b>Result image:</b></para>
             <img src="img/imaging/textile_texture.jpg" width="320" height="240"/>
             </remarks>
             
        </member>
        <member name="M:AForge.Imaging.Textures.TextileTexture.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Textures.TextileTexture"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Textures.TextileTexture.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Textures.TextileTexture.Reset">
            <summary>
            Reset generator.
            </summary>
            
            <remarks>Regenerates internal random numbers.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.RecursiveBlobCounter">
            <summary>
            Blob counter based on recursion.
            </summary>
            
            <remarks><para>The class counts and extracts stand alone objects in
            images using recursive version of connected components labeling
            algorithm.</para>
            
            <para><note>The algorithm treats all pixels with values less or equal to <see cref="P:AForge.Imaging.RecursiveBlobCounter.BackgroundThreshold"/>
            as background, but pixels with higher values are treated as objects' pixels.</note></para>
            
            <para><note>Since this algorithm is based on recursion, it is
            required to be careful with its application to big images with big blobs,
            because in this case recursion will require big stack size and may lead
            to stack overflow. The recursive version may be applied (and may be even
            faster than <see cref="T:AForge.Imaging.BlobCounter"/>) to an image with small blobs -
            "star sky" image (or small cells, for example, etc).</note></para>
            
            <para>For blobs' searching the class supports 8 bpp indexed grayscale images and
            24/32 bpp color images. 
            See documentation about <see cref="T:AForge.Imaging.BlobCounterBase"/> for information about which
            pixel formats are supported for extraction of blobs.</para>
            
            <para>Sample usage:</para>
            <code>
            // create an instance of blob counter algorithm
            RecursiveBlobCounter bc = new RecursiveBlobCounter( );
            // process binary image
            bc.ProcessImage( image );
            Rectangle[] rects = bc.GetObjectsRectangles( );
            // process blobs
            foreach ( Rectangle rect in rects )
            {
                // ...
            }
            </code>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.BlobCounterBase">
            <summary>
            Base class for different blob counting algorithms.
            </summary>
            
            <remarks><para>The class is abstract and serves as a base for different blob counting algorithms.
            Classes, which inherit from this base class, require to implement <see cref="M:AForge.Imaging.BlobCounterBase.BuildObjectsMap(AForge.Imaging.UnmanagedImage)"/>
            method, which does actual building of object's label's map.</para>
            
            <para>For blobs' searcing usually all inherited classes accept binary images, which are actually
            grayscale thresholded images. But the exact supported format should be checked in particular class,
            inheriting from the base class. For blobs' extraction the class supports grayscale (8 bpp indexed)
            and color images (24 and 32 bpp).</para>
            
            <para>Sample usage:</para>
            <code>
            // create an instance of blob counter algorithm
            BlobCounterBase bc = new ...
            // set filtering options
            bc.FilterBlobs = true;
            bc.MinWidth  = 5;
            bc.MinHeight = 5;
            // process binary image
            bc.ProcessImage( image );
            Blob[] blobs = bc.GetObjects( image, false );
            // process blobs
            foreach ( Blob blob in blobs )
            {
                // ...
                // blob.Rectangle - blob's rectangle
                // blob.Image - blob's image
            }
            </code>
            </remarks>
            
        </member>
        <member name="F:AForge.Imaging.BlobCounterBase.objectsCount">
            <summary>
            Objects count.
            </summary>
        </member>
        <member name="F:AForge.Imaging.BlobCounterBase.objectLabels">
            <summary>
            Objects' labels.
            </summary>
        </member>
        <member name="F:AForge.Imaging.BlobCounterBase.imageWidth">
            <summary>
            Width of processed image.
            </summary>
        </member>
        <member name="F:AForge.Imaging.BlobCounterBase.imageHeight">
            <summary>
            Height of processed image.
            </summary>
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <remarks>Creates new instance of the <see cref="T:AForge.Imaging.BlobCounterBase"/> class with
            an empty objects map. Before using methods, which provide information about blobs
            or extract them, the <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>,
            <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> or <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(AForge.Imaging.UnmanagedImage)"/>
            method should be called to collect objects map.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <param name="image">Binary image to look for objects in.</param>
            
            <remarks>Creates new instance of the <see cref="T:AForge.Imaging.BlobCounterBase"/> class with
            initialized objects map built by calling <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/> method.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <param name="imageData">Binary image data to look for objects in.</param>
            
            <remarks>Creates new instance of the <see cref="T:AForge.Imaging.BlobCounterBase"/> class with
            initialized objects map built by calling <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> method.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <param name="image">Unmanaged binary image to look for objects in.</param>
            
            <remarks>Creates new instance of the <see cref="T:AForge.Imaging.BlobCounterBase"/> class with
            initialized objects map built by calling <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(AForge.Imaging.UnmanagedImage)"/> method.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Build objects map.
            </summary>
            
            <param name="image">Source binary image.</param>
            
            <remarks><para>Processes the image and builds objects map, which is used later to extracts blobs.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Build objects map.
            </summary>
            
            <param name="imageData">Source binary image data.</param>
            
            <remarks><para>Processes the image and builds objects map, which is used later to extracts blobs.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.ProcessImage(AForge.Imaging.UnmanagedImage)">
            <summary>
            Build object map from raw image data.
            </summary>
            
            <param name="image">Source unmanaged binary image data.</param>
            
            <remarks><para>Processes the image and builds objects map, which is used later to extracts blobs.</para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Thrown by some inherited classes if some image property other
            than the pixel format is not supported. See that class's documentation or the exception message for details.</exception>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.GetObjectsRectangles">
            <summary>
            Get objects' rectangles.
            </summary>
            
            <returns>Returns array of objects' rectangles.</returns>
            
            <remarks>The method returns array of objects rectangles. Before calling the
            method, the <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
            or <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(AForge.Imaging.UnmanagedImage)"/> method should be called, which will
            build objects map.</remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so objects' rectangles
            can not be collected.</exception>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.GetObjectsInformation">
            <summary>
            Get objects' information.
            </summary>
            
            <returns>Returns array of partially initialized blobs (without <see cref="P:AForge.Imaging.Blob.Image"/> property initialized).</returns>
            
            <remarks><para>By the amount of provided information, the method is between <see cref="M:AForge.Imaging.BlobCounterBase.GetObjectsRectangles"/> and
            <see cref="M:AForge.Imaging.BlobCounterBase.GetObjects(AForge.Imaging.UnmanagedImage,System.Boolean)"/> methods. The method provides array of blobs without initialized their image.
            Blob's image may be extracted later using <see cref="M:AForge.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,AForge.Imaging.Blob,System.Boolean)"/>
            or <see cref="M:AForge.Imaging.BlobCounterBase.ExtractBlobsImage(AForge.Imaging.UnmanagedImage,AForge.Imaging.Blob,System.Boolean)"/> method.
            </para></remarks>
            
            <example>
            <code>
            // create blob counter and process image
            BlobCounter bc = new BlobCounter( sourceImage );
            // specify sort order
            bc.ObjectsOrder = ObjectsOrder.Size;
            // get objects' information (blobs without image)
            Blob[] blobs = bc.GetObjectInformation( );
            // process blobs
            foreach ( Blob blob in blobs )
            {
                // check blob's properties
                if ( blob.Rectangle.Width &gt; 50 )
                {
                    // the blob looks interesting, let's extract it
                    bc.ExtractBlobsImage( sourceImage, blob );
                }
            }
            </code>
            </example>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so objects' information
            can not be collected.</exception>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.GetObjects(System.Drawing.Bitmap,System.Boolean)">
             <summary>
             Get blobs.
             </summary>
             
             <param name="image">Source image to extract objects from.</param>
             
             <returns>Returns array of blobs.</returns>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
            
             <remarks><para>The method returns array of blobs. Before calling the
             method, the <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(AForge.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so objects
             can not be collected.</exception>
             
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.GetObjects(AForge.Imaging.UnmanagedImage,System.Boolean)">
             <summary>
             Get blobs.
             </summary>
             
             <param name="image">Source unmanaged image to extract objects from.</param>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
             
             <returns>Returns array of blobs.</returns>
             
             <remarks><para>The method returns array of blobs. Before calling the
             method, the <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(AForge.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so objects
             can not be collected.</exception>
             
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,AForge.Imaging.Blob,System.Boolean)">
             <summary>
             Extract blob's image.
             </summary>
             
             <param name="image">Source image to extract blob's image from.</param>
             <param name="blob">Blob which is required to be extracted.</param>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
            
             <remarks><para>The method is used to extract image of partially initialized blob, which
             was provided by <see cref="M:AForge.Imaging.BlobCounterBase.GetObjectsInformation"/> method. Before calling the
             method, the <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(AForge.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so blob
             can not be extracted.</exception>
             
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.ExtractBlobsImage(AForge.Imaging.UnmanagedImage,AForge.Imaging.Blob,System.Boolean)">
             <summary>
             Extract blob's image.
             </summary>
             
             <param name="image">Source unmanaged image to extract blob's image from.</param>
             <param name="blob">Blob which is required to be extracted.</param>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
            
             <remarks><para>The method is used to extract image of partially initialized blob, which
             was provided by <see cref="M:AForge.Imaging.BlobCounterBase.GetObjectsInformation"/> method. Before calling the
             method, the <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(AForge.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so blob
             can not be extracted.</exception>
             
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.GetBlobsLeftAndRightEdges(AForge.Imaging.Blob,System.Collections.Generic.List{AForge.IntPoint}@,System.Collections.Generic.List{AForge.IntPoint}@)">
            <summary>
            Get list of points on the left and right edges of the blob.
            </summary>
            
            <param name="blob">Blob to collect edge points for.</param>
            <param name="leftEdge">List of points on the left edge of the blob.</param>
            <param name="rightEdge">List of points on the right edge of the blob.</param>
            
            <remarks><para>The method scans each line of the blob and finds the most left and the
            most right points for it adding them to appropriate lists. The method may be very
            useful in conjunction with different routines from <see cref="N:AForge.Math.Geometry"/>,
            which allow finding convex hull or quadrilateral's corners.</para>
            
            <para><note>Both lists of points are sorted by Y coordinate - points with smaller Y
            value go first.</note></para>
            </remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so blob
            can not be extracted.</exception>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.GetBlobsTopAndBottomEdges(AForge.Imaging.Blob,System.Collections.Generic.List{AForge.IntPoint}@,System.Collections.Generic.List{AForge.IntPoint}@)">
            <summary>
            Get list of points on the top and bottom edges of the blob.
            </summary>
            
            <param name="blob">Blob to collect edge points for.</param>
            <param name="topEdge">List of points on the top edge of the blob.</param>
            <param name="bottomEdge">List of points on the bottom edge of the blob.</param>
            
            <remarks><para>The method scans each column of the blob and finds the most top and the
            most bottom points for it adding them to appropriate lists. The method may be very
            useful in conjunction with different routines from <see cref="N:AForge.Math.Geometry"/>,
            which allow finding convex hull or quadrilateral's corners.</para>
            
            <para><note>Both lists of points are sorted by X coordinate - points with smaller X
            value go first.</note></para>
            </remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so blob
            can not be extracted.</exception>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.GetBlobsEdgePoints(AForge.Imaging.Blob)">
            <summary>
            Get list of object's edge points.
            </summary>
            
            <param name="blob">Blob to collect edge points for.</param>
            
            <returns>Returns unsorted list of blob's edge points.</returns>
            
            <remarks><para>The method scans each row and column of the blob and finds the
            most top/bottom/left/right points. The method returns similar result as if results of
            both <see cref="M:AForge.Imaging.BlobCounterBase.GetBlobsLeftAndRightEdges(AForge.Imaging.Blob,System.Collections.Generic.List{AForge.IntPoint}@,System.Collections.Generic.List{AForge.IntPoint}@)"/> and <see cref="M:AForge.Imaging.BlobCounterBase.GetBlobsTopAndBottomEdges(AForge.Imaging.Blob,System.Collections.Generic.List{AForge.IntPoint}@,System.Collections.Generic.List{AForge.IntPoint}@)"/>
            methods were combined, but each edge point occurs only once in the list.</para>
            
            <para><note>Edge points in the returned list are not ordered. This makes the list unusable
            for visualization with methods, which draw polygon or poly-line. But the returned list
            can be used with such algorithms, like convex hull search, shape analyzer, etc.</note></para>
            </remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so blob
            can not be extracted.</exception>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounterBase.BuildObjectsMap(AForge.Imaging.UnmanagedImage)">
            <summary>
            Actual objects map building.
            </summary>
            
            <param name="image">Unmanaged image to process.</param>
            
            <remarks><note>By the time this method is called bitmap's pixel format is not
            yet checked, so this should be done by the class inheriting from the base class.
            <see cref="F:AForge.Imaging.BlobCounterBase.imageWidth"/> and <see cref="F:AForge.Imaging.BlobCounterBase.imageHeight"/> members are initialized
            before the method is called, so these members may be used safely.</note></remarks>
            
        </member>
        <member name="P:AForge.Imaging.BlobCounterBase.ObjectsCount">
            <summary>
            Objects count.
            </summary>
            
            <remarks><para>Number of objects (blobs) found by <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/> method.
            </para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.BlobCounterBase.ObjectLabels">
            <summary>
            Objects' labels.
            </summary>
            
            <remarks>The array of <b>width</b> * <b>height</b> size, which holds
            labels for all objects. Background is represented with <b>0</b> value,
            but objects are represented with labels starting from <b>1</b>.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.BlobCounterBase.ObjectsOrder">
            <summary>
            Objects sort order.
            </summary>
            
            <remarks><para>The property specifies objects' sort order, which are provided
            by <see cref="M:AForge.Imaging.BlobCounterBase.GetObjectsRectangles"/>, <see cref="M:AForge.Imaging.BlobCounterBase.GetObjectsInformation"/>, etc.
            </para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.BlobCounterBase.FilterBlobs">
            <summary>
            Specifies if blobs should be filtered.
            </summary>
            
            <remarks><para>If the property is equal to <b>false</b>, then there is no any additional
            post processing after image was processed. If the property is set to <b>true</b>, then
            blobs filtering is done right after image processing routine. If <see cref="P:AForge.Imaging.BlobCounterBase.BlobsFilter"/>
            is set, then custom blobs' filtering is done, which is implemented by user. Otherwise
            blobs are filtered according to dimensions specified in <see cref="P:AForge.Imaging.BlobCounterBase.MinWidth"/>,
            <see cref="P:AForge.Imaging.BlobCounterBase.MinHeight"/>, <see cref="P:AForge.Imaging.BlobCounterBase.MaxWidth"/> and <see cref="P:AForge.Imaging.BlobCounterBase.MaxHeight"/> properties.</para>
            
            <para>Default value is set to <see langword="false"/>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.BlobCounterBase.CoupledSizeFiltering">
            <summary>
            Specifies if size filetering should be coupled or not.
            </summary>
            
            <remarks><para>In uncoupled filtering mode, objects are filtered out in the case if
            their width is smaller than <see cref="P:AForge.Imaging.BlobCounterBase.MinWidth"/> <b>or</b> height is smaller than 
            <see cref="P:AForge.Imaging.BlobCounterBase.MinHeight"/>. But in coupled filtering mode, objects are filtered out in
            the case if their width is smaller than <see cref="P:AForge.Imaging.BlobCounterBase.MinWidth"/> <b>and</b> height is
            smaller than <see cref="P:AForge.Imaging.BlobCounterBase.MinHeight"/>. In both modes the idea with filtering by objects'
            maximum size is the same as filtering by objects' minimum size.</para>
            
            <para>Default value is set to <see langword="false"/>, what means uncoupled filtering by size.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.BlobCounterBase.MinWidth">
            <summary>
            Minimum allowed width of blob.
            </summary>
            
            <remarks><para>The property specifies minimum object's width acceptable by blob counting
            routine and has power only when <see cref="P:AForge.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:AForge.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:AForge.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.BlobCounterBase.MinHeight">
            <summary>
            Minimum allowed height of blob.
            </summary>
            
            <remarks><para>The property specifies minimum object's height acceptable by blob counting
            routine and has power only when <see cref="P:AForge.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:AForge.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:AForge.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.BlobCounterBase.MaxWidth">
            <summary>
            Maximum allowed width of blob.
            </summary>
            
            <remarks><para>The property specifies maximum object's width acceptable by blob counting
            routine and has power only when <see cref="P:AForge.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:AForge.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:AForge.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.BlobCounterBase.MaxHeight">
            <summary>
            Maximum allowed height of blob.
            </summary>
            
            <remarks><para>The property specifies maximum object's height acceptable by blob counting
            routine and has power only when <see cref="P:AForge.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:AForge.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:AForge.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.BlobCounterBase.BlobsFilter">
            <summary>
            Custom blobs' filter to use.
            </summary>
            
            <remarks><para>The property specifies custom blobs' filtering routine to use. It has
            effect only in the case if <see cref="P:AForge.Imaging.BlobCounterBase.FilterBlobs"/> property is set to <see langword="true"/>.</para>
            
            <para><note>When custom blobs' filtering routine is set, it has priority over default filtering done
            with <see cref="P:AForge.Imaging.BlobCounterBase.MinWidth"/>, <see cref="P:AForge.Imaging.BlobCounterBase.MinHeight"/>, <see cref="P:AForge.Imaging.BlobCounterBase.MaxWidth"/> and <see cref="P:AForge.Imaging.BlobCounterBase.MaxHeight"/>.</note></para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.RecursiveBlobCounter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <remarks>Creates new instance of the <see cref="T:AForge.Imaging.RecursiveBlobCounter"/> class with
            an empty objects map. Before using methods, which provide information about blobs
            or extract them, the <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>,
            <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> or <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(AForge.Imaging.UnmanagedImage)"/>
            method should be called to collect objects map.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.RecursiveBlobCounter.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <param name="image">Image to look for objects in.</param>
            
        </member>
        <member name="M:AForge.Imaging.RecursiveBlobCounter.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <param name="imageData">Image data to look for objects in.</param>
            
        </member>
        <member name="M:AForge.Imaging.RecursiveBlobCounter.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <param name="image">Unmanaged image to look for objects in.</param>
            
        </member>
        <member name="M:AForge.Imaging.RecursiveBlobCounter.BuildObjectsMap(AForge.Imaging.UnmanagedImage)">
            <summary>
            Actual objects map building.
            </summary>
            
            <param name="image">Unmanaged image to process.</param>
            
            <remarks>The method supports 8 bpp indexed grayscale images and 24/32 bpp color images.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.RecursiveBlobCounter.BackgroundThreshold">
             <summary>
             Background threshold's value.
             </summary>
             
             <remarks><para>The property sets threshold value for distinguishing between background
             pixel and objects' pixels. All pixel with values less or equal to this property are
             treated as background, but pixels with higher values are treated as objects' pixels.</para>
             
             <para><note>In the case of colour images a pixel is treated as objects' pixel if <b>any</b> of its
             RGB values are higher than corresponding values of this threshold.</note></para>
             
             <para><note>For processing grayscale image, set the property with all RGB components eqaul.</note></para>
            
             <para>Default value is set to <b>(0, 0, 0)</b> - black colour.</para></remarks>
             
        </member>
        <member name="T:AForge.Imaging.ImageStatisticsHSL">
            <summary>
            Gather statistics about image in HSL color space.
            </summary>
            
            <remarks><para>The class is used to accumulate statistical values about images,
            like histogram, mean, standard deviation, etc. for each <b>HSL</b> color channel.</para>
            
            <para>The class accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // gather statistics
            ImageStatisticsHSL stat = new ImageStatisticsHSL( image );
            // get saturation channel's histogram
            ContinuousHistogram saturation = stat.Saturation;
            // check mean value of saturation channel
            if ( saturation.Mean &gt; 0.5 )
            {
                // do further processing
            }
            </code>
            </remarks>
            
            <seealso cref="T:AForge.Math.ContinuousHistogram"/>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsHSL.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsHSL.#ctor(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsHSL.#ctor(System.Drawing.Bitmap,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsHSL.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Unmanaged image to gather statistics about.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsHSL.#ctor(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsHSL.#ctor(AForge.Imaging.UnmanagedImage,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsHSL.Saturation">
            <summary>
            Histogram of saturation channel.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsHSL.Luminance">
            <summary>
            Histogram of luminance channel.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsHSL.SaturationWithoutBlack">
            <summary>
            Histogram of saturation channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about saturation channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsHSL.LuminanceWithoutBlack">
            <summary>
            Histogram of luminance channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about luminance channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsHSL.PixelsCount">
            <summary>
            Total pixels count in the processed image.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsHSL.PixelsCountWithoutBlack">
            <summary>
            Total pixels count in the processed image excluding black pixels.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Filters.FillHoles">
            <summary>
            Fill holes in objects in binary image.
            </summary>
            
            <remarks><para>The filter allows to fill black holes in white object in a binary image.
            It is possible to specify maximum holes' size to fill using <see cref="P:AForge.Imaging.Filters.FillHoles.MaxHoleWidth"/>
            and <see cref="P:AForge.Imaging.Filters.FillHoles.MaxHoleHeight"/> properties.</para>
            
            <para>The filter accepts binary image only, which are represented  as 8 bpp images.</para>
            
            <para>Sample usage:</para>
            <code>
            // create and configure the filter
            FillHoles filter = new FillHoles( );
            filter.MaxHoleHeight = 20;
            filter.MaxHoleWidth  = 20;
            filter.CoupledSizeFiltering = false;
            // apply the filter
            Bitmap result = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample19.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/filled_holes.png" width="320" height="240"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FillHoles.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.FillHoles"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.FillHoles.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.FillHoles.CoupledSizeFiltering">
            <summary>
            Specifies if size filetering should be coupled or not.
            </summary>
            
            <remarks><para>In uncoupled filtering mode, holes are filled in the case if
            their width is smaller than or equal to <see cref="P:AForge.Imaging.Filters.FillHoles.MaxHoleWidth"/> or height is smaller than 
            or equal to <see cref="P:AForge.Imaging.Filters.FillHoles.MaxHoleHeight"/>. But in coupled filtering mode, holes are filled only in
            the case if both width and height are smaller or equal to the corresponding value.</para>
            
            <para>Default value is set to <see langword="true"/>, what means coupled filtering by size.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.FillHoles.MaxHoleWidth">
             <summary>
             Maximum width of a hole to fill.
             </summary>
            
             <remarks><para>All holes, which have width greater than this value, are kept unfilled.
             See <see cref="P:AForge.Imaging.Filters.FillHoles.CoupledSizeFiltering"/> for additional information.</para>
             
             <para>Default value is set to <see cref="F:System.Int32.MaxValue"/>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.FillHoles.MaxHoleHeight">
             <summary>
             Maximum height of a hole to fill.
             </summary>
            
             <remarks><para>All holes, which have height greater than this value, are kept unfilled.
             See <see cref="P:AForge.Imaging.Filters.FillHoles.CoupledSizeFiltering"/> for additional information.</para>
             
             <para>Default value is set to <see cref="F:System.Int32.MaxValue"/>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.FillHoles.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.CanvasMove">
            <summary>
            Move canvas to the specified point.
            </summary>
            
            <remarks>
            <para>The filter moves canvas to the specified area filling unused empty areas with specified color.</para>
            
            <para>The filter accepts 8/16 bpp grayscale images and 24/32/48/64 bpp color image
            for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            CanvasMove filter = new CanvasMove( new IntPoint( -50, -50 ), Color.Green );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="img/imaging/canvas_move.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasMove.#ctor(AForge.IntPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasMove"/> class.
            </summary>
            
            <param name="movePoint">Point to move the canvas to.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasMove.#ctor(AForge.IntPoint,System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasMove"/> class.
            </summary>
            
            <param name="movePoint">Point to move the canvas.</param>
            <param name="fillColorRGB">RGB color to use for filling areas empty areas in color images.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasMove.#ctor(AForge.IntPoint,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasMove"/> class.
            </summary>
            
            <param name="movePoint">Point to move the canvas.</param>
            <param name="fillColorGray">Gray color to use for filling empty areas in grayscale images.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasMove.#ctor(AForge.IntPoint,System.Drawing.Color,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasMove"/> class.
            </summary>
            
            <param name="movePoint">Point to move the canvas.</param>
            <param name="fillColorRGB">RGB color to use for filling areas empty areas in color images.</param>
            <param name="fillColorGray">Gray color to use for filling empty areas in grayscale images.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasMove.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasMove.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasMove.FillColorRGB">
            <summary>
            RGB fill color.
            </summary>
            
            <remarks><para>The color is used to fill empty areas in color images.</para>
            
            <para>Default value is set to white - ARGB(255, 255, 255, 255).</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasMove.FillColorGray">
             <summary>
             Gray fill color.
             </summary>
             
             <remarks><para>The color is used to fill empty areas in grayscale images.</para>
             
             <para>Default value is set to white - 255.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasMove.MovePoint">
            <summary>
            Point to move the canvas to.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ReplaceChannel">
            <summary>
            Replace RGB channel of color imgae.
            </summary>
            
            <remarks><para>Replaces specified RGB channel of color image with
            specified grayscale image.</para>
            
            <para>The filter is quite useful in conjunction with <see cref="T:AForge.Imaging.Filters.ExtractChannel"/> filter
            (however may be used alone in some cases). Using the <see cref="T:AForge.Imaging.Filters.ExtractChannel"/> filter
            it is possible to extract one of RGB channel, perform some image processing with it and then
            put it back into the original color image.</para>
            
            <para>The filter accepts 24, 32, 48 and 64 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // extract red channel
            ExtractChannel extractFilter = new ExtractChannel( RGB.R );
            Bitmap channel = extractFilter.Apply( image );
            // threshold channel
            Threshold thresholdFilter = new Threshold( 230 );
            thresholdFilter.ApplyInPlace( channel );            
            // put the channel back
            ReplaceChannel replaceFilter = new ReplaceChannel( RGB.R, channel );
            replaceFilter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/replace_channel.jpg" width="480" height="361"/>
            
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.ExtractChannel"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ReplaceChannel.#ctor(System.Int16,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ReplaceChannel"/> class.
            </summary>
            
            <param name="channel">ARGB channel to replace.</param>
            <param name="channelImage">Channel image to use for replacement.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ReplaceChannel.#ctor(System.Int16,AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.YCbCrReplaceChannel"/> class.
            </summary>
            
            <param name="channel">RGB channel to replace.</param>
            <param name="channelImage">Unmanaged channel image to use for replacement.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ReplaceChannel.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Channel image size does not match source
             image size.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Channel image's format does not correspond to format of the source image.</exception>
            
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Can not replace alpha channel of none ARGB image. The
             exception is throw, when alpha channel is requested to be replaced in RGB image.</exception>
             
        </member>
        <member name="P:AForge.Imaging.Filters.ReplaceChannel.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ReplaceChannel.Channel">
            <summary>
            ARGB channel to replace.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:AForge.Imaging.RGB.R"/>.</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid channel is specified.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ReplaceChannel.ChannelImage">
             <summary>
             Grayscale image to use for channel replacement.
             </summary>
             
             <remarks>
             <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.ReplaceChannel.UnmanagedChannelImage"/> property -
             only one channel image is allowed: managed or unmanaged.</note></para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Channel image should be 8 bpp indexed or 16 bpp grayscale image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ReplaceChannel.UnmanagedChannelImage">
            <summary>
            Unmanaged grayscale image to use for channel replacement.
            </summary>
            
            <remarks>
            <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.ReplaceChannel.ChannelImage"/> property -
            only one channel image is allowed: managed or unmanaged.</note></para>
            </remarks>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Channel image should be 8 bpp indexed or 16 bpp grayscale image.</exception>
            
        </member>
        <member name="T:AForge.Imaging.Filters.GrayscaleRMY">
             <summary>
             Grayscale image using R-Y algorithm.
             </summary>
             
             <remarks>The class uses <b>R-Y</b> algorithm to convert color image
             to grayscale. The conversion coefficients are:
             <list type="bullet">
             <item>Red: 0.5;</item>
             <item>Green: 0.419;</item>
             <item>Blue: 0.081.</item>
             </list>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.Grayscale"/>
             <seealso cref="T:AForge.Imaging.Filters.GrayscaleBT709"/>
             <seealso cref="T:AForge.Imaging.Filters.GrayscaleY"/>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Grayscale">
             <summary>
             Base class for image grayscaling.
             </summary>
             
             <remarks><para>This class is the base class for image grayscaling. Other
             classes should inherit from this class and specify <b>RGB</b>
             coefficients used for color image conversion to grayscale.</para>
             
             <para>The filter accepts 24, 32, 48 and 64 bpp color images and produces
             8 (if source is 24 or 32 bpp image) or 16 (if source is 48 or 64 bpp image)
             bpp grayscale image.</para>
             
             <para>Sample usage:</para>
             <code>
             // create grayscale filter (BT709)
             Grayscale filter = new Grayscale( 0.2125, 0.7154, 0.0721 );
             // apply the filter
             Bitmap grayImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/grayscale.jpg" width="480" height="361"/>
             </remarks>
            
             <seealso cref="T:AForge.Imaging.Filters.GrayscaleBT709"/>
             <seealso cref="T:AForge.Imaging.Filters.GrayscaleRMY"/>
             <seealso cref="T:AForge.Imaging.Filters.GrayscaleY"/>
            
        </member>
        <member name="F:AForge.Imaging.Filters.Grayscale.RedCoefficient">
            <summary>
            Portion of red channel's value to use during conversion from RGB to grayscale.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.Grayscale.GreenCoefficient">
            <summary>
            Portion of green channel's value to use during conversion from RGB to grayscale.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.Grayscale.BlueCoefficient">
            <summary>
            Portion of blue channel's value to use during conversion from RGB to grayscale.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Grayscale.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Grayscale"/> class.
            </summary>
            
            <param name="cr">Red coefficient.</param>
            <param name="cg">Green coefficient.</param>
            <param name="cb">Blue coefficient.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Grayscale.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Grayscale.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.Grayscale.CommonAlgorithms">
            <summary>
            Set of predefined common grayscaling algorithms, which have aldready initialized
            grayscaling coefficients.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.Grayscale.CommonAlgorithms.BT709">
            <summary>
            Grayscale image using BT709 algorithm.
            </summary>
            
            <remarks><para>The instance uses <b>BT709</b> algorithm to convert color image
            to grayscale. The conversion coefficients are:
            <list type="bullet">
            <item>Red: 0.2125;</item>
            <item>Green: 0.7154;</item>
            <item>Blue: 0.0721.</item>
            </list></para>
            
            <para>Sample usage:</para>
            <code>
            // apply the filter
            Bitmap grayImage = Grayscale.CommonAlgorithms.BT709.Apply( image );
            </code>
            </remarks>
            
        </member>
        <member name="F:AForge.Imaging.Filters.Grayscale.CommonAlgorithms.RMY">
            <summary>
            Grayscale image using R-Y algorithm.
            </summary>
            
            <remarks><para>The instance uses <b>R-Y</b> algorithm to convert color image
            to grayscale. The conversion coefficients are:
            <list type="bullet">
            <item>Red: 0.5;</item>
            <item>Green: 0.419;</item>
            <item>Blue: 0.081.</item>
            </list></para>
            
            <para>Sample usage:</para>
            <code>
            // apply the filter
            Bitmap grayImage = Grayscale.CommonAlgorithms.RMY.Apply( image );
            </code>
            </remarks>
            
        </member>
        <member name="F:AForge.Imaging.Filters.Grayscale.CommonAlgorithms.Y">
            <summary>
            Grayscale image using Y algorithm.
            </summary>
            
            <remarks><para>The instance uses <b>Y</b> algorithm to convert color image
            to grayscale. The conversion coefficients are:
            <list type="bullet">
            <item>Red: 0.299;</item>
            <item>Green: 0.587;</item>
            <item>Blue: 0.114.</item>
            </list></para>
            
            <para>Sample usage:</para>
            <code>
            // apply the filter
            Bitmap grayImage = Grayscale.CommonAlgorithms.Y.Apply( image );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GrayscaleRMY.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GrayscaleRMY"/> class.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.ThresholdWithCarry">
            <summary>
            Threshold binarization with error carry.
            </summary>
            
            <remarks><para>The filter is similar to <see cref="T:AForge.Imaging.Filters.Threshold"/> filter in the way,
            that it also uses threshold value for image binarization. Unlike regular threshold
            filter, this filter uses cumulative pixel value in comparing with threshold value.
            If cumulative pixel value is below threshold value, then image pixel becomes black.
            If cumulative pixel value is equal or higher than threshold value, then image pixel
            becomes white and cumulative pixel value is decreased by 255. In the beginning of each
            image line the cumulative value is reset to 0.
            </para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Threshold filter = new Threshold( 100 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/grayscale.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/threshold_carry.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ThresholdWithCarry.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ThresholdWithCarry"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ThresholdWithCarry.#ctor(System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ThresholdWithCarry"/> class.
            </summary>
            
            <param name="threshold">Threshold value.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ThresholdWithCarry.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ThresholdWithCarry.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ThresholdWithCarry.ThresholdValue">
            <summary>
            Threshold value.
            </summary>
            
            <remarks>Default value is 128.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.ColorReduction.BurkesColorDithering">
            <summary>
            Color dithering using Burkes error diffusion.
            </summary>
            
            <remarks><para>The image processing routine represents color dithering algorithm, which is based on
            error diffusion dithering with Burkes coefficients. Error is diffused
            on 7 neighbor pixels with next coefficients:</para>
            <code lang="none">
                    | * | 8 | 4 |
            | 2 | 4 | 8 | 4 | 2 |
            
            / 32
            </code>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
            produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
            <see cref="P:AForge.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
            color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
            
            <para>Sample usage:</para>
            <code>
            // create color image quantization routine
            ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
            // create 8 colors table
            Color[] colorTable = ciq.CalculatePalette( image, 8 );
            // create dithering routine
            BurkesColorDithering dithering = new BurkesColorDithering( );
            dithering.ColorTable = colorTable;
            // apply the dithering routine
            Bitmap newImage = dithering.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/color_burkes.png" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.ColorReduction.FloydSteinbergColorDithering"/>
            <seealso cref="T:AForge.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering"/>
            <seealso cref="T:AForge.Imaging.ColorReduction.SierraColorDithering"/>
            <seealso cref="T:AForge.Imaging.ColorReduction.StuckiColorDithering"/>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.BurkesColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ColorReduction.BurkesColorDithering"/> class.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.MoravecCornersDetector">
            <summary>
            Moravec corners detector.
            </summary>
            
            <remarks><para>The class implements Moravec corners detector. For information about algorithm's
            details its <a href="http://www.cim.mcgill.ca/~dparks/CornerDetector/mainMoravec.htm">description</a>
            should be studied.</para>
            
            <para><note>Due to limitations of Moravec corners detector (anisotropic response, etc.) its usage is limited
            to certain cases only.</note></para>
            
            <para>The class processes only grayscale 8 bpp and color 24/32 bpp images.</para>
            
            <para>Sample usage:</para>
            <code>
            // create corner detector's instance
            MoravecCornersDetector mcd = new MoravecCornersDetector( );
            // process image searching for corners
            List&lt;IntPoint&gt; corners = scd.ProcessImage( image );
            // process points
            foreach ( IntPoint corner in corners )
            {
                // ... 
            }
            </code>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.SusanCornersDetector"/>
            
        </member>
        <member name="M:AForge.Imaging.MoravecCornersDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.MoravecCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.MoravecCornersDetector.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.MoravecCornersDetector"/> class.
            </summary>
            
            <param name="threshold">Threshold value, which is used to filter out uninteresting points.</param>
            
        </member>
        <member name="M:AForge.Imaging.MoravecCornersDetector.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.MoravecCornersDetector"/> class.
            </summary>
            
            <param name="threshold">Threshold value, which is used to filter out uninteresting points.</param>
            <param name="windowSize">Window size used to determine if point is interesting.</param>
            
        </member>
        <member name="M:AForge.Imaging.MoravecCornersDetector.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="image">Source image to process.</param>
            
            <returns>Returns array of found corners (X-Y coordinates).</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.MoravecCornersDetector.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            
            <returns>Returns array of found corners (X-Y coordinates).</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.MoravecCornersDetector.ProcessImage(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process image looking for corners.
             </summary>
             
             <param name="image">Unmanaged source image to process.</param>
             
             <returns>Returns array of found corners (X-Y coordinates).</returns>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
             
        </member>
        <member name="P:AForge.Imaging.MoravecCornersDetector.WindowSize">
            <summary>
            Window size used to determine if point is interesting, [3, 15].
            </summary>
            
            <remarks><para>The value specifies window size, which is used for initial searching of
            corners candidates and then for searching local maximums.</para>
            
            <para>Default value is set to <b>3</b>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Setting value is not odd.</exception>
            
        </member>
        <member name="P:AForge.Imaging.MoravecCornersDetector.Threshold">
            <summary>
            Threshold value, which is used to filter out uninteresting points.
            </summary>
            
            <remarks><para>The value is used to filter uninteresting points - points which have value below
            specified threshold value are treated as not corners candidates. Increasing this value decreases
            the amount of detected point.</para>
            
            <para>Default value is set to <b>500</b>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Mirror">
            <summary>
            Mirroring filter.
            </summary>
            
            <remarks><para>The filter mirrors image around X and/or Y axis (horizontal and vertical
            mirroring).</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Mirror filter = new Mirror( false, true );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="img/imaging/mirror.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Mirror.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Mirror"/> class.
            </summary>
            
            <param name="mirrorX">Specifies if mirroring should be done for X axis.</param>
            <param name="mirrorY">Specifies if mirroring should be done for Y axis</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Mirror.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Mirror.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.Mirror.MirrorX">
            <summary>
            Specifies if mirroring should be done for X axis (horizontal mirroring).
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Mirror.MirrorY">
            <summary>
            Specifies if mirroring should be done for Y axis (vertical mirroring).
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Filters.MaskedFilter">
            <summary>
            Apply filter according to the specified mask.
            </summary>
            
            <remarks><para>The image processing routine applies the specified <see cref="P:AForge.Imaging.Filters.MaskedFilter.BaseFilter"/> to
            a source image according to the specified mask - if a pixel/value in the specified mask image/array
            is set to 0, then the original pixel's value is kept; otherwise the pixel is filtered using the
            specified base filter.</para>
            
            <para>Mask can be specified as <see cref="P:AForge.Imaging.Filters.MaskedFilter.MaskImage">.NET's managed Bitmap</see>, as
            <see cref="P:AForge.Imaging.Filters.MaskedFilter.UnmanagedMaskImage">UnmanagedImage</see> or as <see cref="P:AForge.Imaging.Filters.MaskedFilter.Mask">byte array</see>.
            In the case if mask is specified as image, it must be 8 bpp grayscale image. In all case
            mask size must be the same as size of the image to process.</para>
            
            <para><note>Pixel formats accepted by this filter are specified by the <see cref="P:AForge.Imaging.Filters.MaskedFilter.BaseFilter"/>.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create the filter
            MaskedFilter maskedFilter = new MaskedFilter( new Sepia( ), maskImage );
            // apply the filter
            maskedFilter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Mask image:</b></para>
            <img src="img/imaging/mask.png" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/masked_image.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.MaskedFilter.#ctor(AForge.Imaging.Filters.IFilter,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.MaskedFilter"/> class.
            </summary>
            
            <param name="baseFiler"><see cref="P:AForge.Imaging.Filters.MaskedFilter.BaseFilter">Base filter</see> to apply to the specified source image.</param>
            <param name="maskImage"><see cref="P:AForge.Imaging.Filters.MaskedFilter.MaskImage">Mask image</see> to use.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.MaskedFilter.#ctor(AForge.Imaging.Filters.IFilter,AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.MaskedFilter"/> class.
            </summary>
            
            <param name="baseFiler"><see cref="P:AForge.Imaging.Filters.MaskedFilter.BaseFilter">Base filter</see> to apply to the specified source image.</param>
            <param name="unmanagedMaskImage"><see cref="P:AForge.Imaging.Filters.MaskedFilter.UnmanagedMaskImage">Unmanaged mask image</see> to use.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.MaskedFilter.#ctor(AForge.Imaging.Filters.IFilter,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.MaskedFilter"/> class.
            </summary>
            
            <param name="baseFiler"><see cref="P:AForge.Imaging.Filters.MaskedFilter.BaseFilter">Base filter</see> to apply to the specified source image.</param>
            <param name="mask"><see cref="P:AForge.Imaging.Filters.MaskedFilter.Mask"/> to use.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.MaskedFilter.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <exception cref="T:System.NullReferenceException">None of the possible mask properties were set. Need to provide mask before applying the filter.</exception>
             <exception cref="T:System.ArgumentException">Invalid size of provided mask. Its size must be the same as the size of the image to mask.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.MaskedFilter.BaseFilter">
             <summary>
             Base filter to apply to the source image.
             </summary>
            
             <remarks><para>The property specifies base filter which is applied to the specified source
             image (to all pixels which have corresponding none 0 value in mask image/array).</para>
             
             <para><note>The base filter must implement <see cref="T:AForge.Imaging.Filters.IFilterInformation"/> interface.</note></para>
             
             <para><note>The base filter must never change image's pixel format. For example, if source
             image's pixel format is 24 bpp color image, then it must stay the same after the base
             filter is applied.</note></para>
             
             <para><note>The base filter must never change size of the source image.</note></para>
             </remarks>
             
             <exception cref="T:System.NullReferenceException">Base filter can not be set to null.</exception>
             <exception cref="T:System.ArgumentException">The specified base filter must implement IFilterInformation interface.</exception>
             <exception cref="T:System.ArgumentException">The specified filter must never change pixel format.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.MaskedFilter.MaskImage">
            <summary>
            Mask image to apply.
            </summary>
            
            <remarks><para>The property specifies mask image to use. The image must be grayscale
            (8 bpp format) and have the same size as the source image to process.</para>
            
            <para>When the property is set, both <see cref="P:AForge.Imaging.Filters.MaskedFilter.UnmanagedMaskImage"/> and
            <see cref="P:AForge.Imaging.Filters.MaskedFilter.Mask"/> properties are set to <see langword="null"/>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">The mask image must be 8 bpp grayscale image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.MaskedFilter.UnmanagedMaskImage">
            <summary>
            Unmanaged mask image to apply.
            </summary>
            
            <remarks><para>The property specifies unmanaged mask image to use. The image must be grayscale
            (8 bpp format) and have the same size as the source image to process.</para>
            
            <para>When the property is set, both <see cref="P:AForge.Imaging.Filters.MaskedFilter.MaskImage"/> and
            <see cref="P:AForge.Imaging.Filters.MaskedFilter.Mask"/> properties are set to <see langword="null"/>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">The mask image must be 8 bpp grayscale image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.MaskedFilter.Mask">
            <summary>
            Mask to apply.
            </summary>
            
            <remarks><para>The property specifies mask array to use. Size of the array must
            be the same size as the size of the source image to process - its 0<sup>th</sup> dimension
            must be equal to image's height and its 1<sup>st</sup> dimension must be equal to width. For
            example, for 640x480 image, the mask array must be defined as:
            <code>
            byte[,] mask = new byte[480, 640];
            </code>
            </para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.MaskedFilter.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para>
            
            <para><note>The property returns format translation table from the
            <see cref="P:AForge.Imaging.Filters.MaskedFilter.BaseFilter"/>.</note></para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Jitter">
            <summary>
            Jitter filter.
            </summary>
            
            <remarks><para>The filter moves each pixel of a source image in
            random direction within a window of specified <see cref="P:AForge.Imaging.Filters.Jitter.Radius">radius</see>.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Jitter filter = new Jitter( 4 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/jitter.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Jitter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Jitter"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Jitter.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Jitter"/> class.
            </summary>
            
            <param name="radius">Jittering radius.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Jitter.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Jitter.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Jitter.Radius">
            <summary>
            Jittering radius, [1, 10]
            </summary>
            
            <remarks><para>Determines radius in which pixels can move.</para>
            
            <para>Default value is set to <b>2</b>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.CanvasFill">
            <summary>
            Fill areas iniside of the specified region.
            </summary>
            
            <remarks>
            <para>The filter fills areas inside of specified region using the specified color.</para>
            
            <para>The filter accepts 8bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            CanvasFill filter = new CanvasFill( new Rectangle(
                                    5, 5, image.Width - 10, image.Height - 10 ), Color.Red );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.CanvasCrop"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasFill.#ctor(System.Drawing.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasFill"/> class.
            </summary>
            
            <param name="region">Region to fill.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasFill.#ctor(System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasFill"/> class.
            </summary>
            
            <param name="region">Region to fill.</param>
            <param name="fillColorRGB">RGB color to use for filling areas inside of specified region in color images.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasFill.#ctor(System.Drawing.Rectangle,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasFill"/> class.
            </summary>
            
            <param name="region">Region to fill.</param>
            <param name="fillColorGray">Gray color to use for filling areas inside of specified region in grayscale images.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasFill.#ctor(System.Drawing.Rectangle,System.Drawing.Color,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasFill"/> class.
            </summary>
            
            <param name="region">Region to fill.</param>
            <param name="fillColorRGB">RGB color to use for filling areas inside of specified region in color images.</param>
            <param name="fillColorGray">Gray color to use for filling areas inside of specified region in grayscale images.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasFill.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasFill.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasFill.FillColorRGB">
            <summary>
            RGB fill color.
            </summary>
            
            <remarks><para>The color is used to fill areas out of specified region in color images.</para>
            
            <para>Default value is set to white - RGB(255, 255, 255).</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasFill.FillColorGray">
            <summary>
            Gray fill color.
            </summary>
            
            <remarks><para>The color is used to fill areas out of specified region in grayscale images.</para>
            
            <para>Default value is set to white - 255.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasFill.Region">
            <summary>
            Region to fill.
            </summary>
            
            <remarks>Pixels inside of the specified region will be filled with specified color.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.HistogramEqualization">
             <summary>
             Histogram equalization filter.
             </summary>
            
             <remarks><para>The filter does histogram equalization increasing local contrast in images. The effect
             of histogram equalization can be better seen on images, where pixel values have close contrast values.
             Through this adjustment, pixels intensities can be better distributed on the histogram. This allows for
             areas of lower local contrast to gain a higher contrast without affecting the global contrast.
             </para>
             
             <para>The filter accepts 8 bpp grayscale images and 24/32 bpp
             color images for processing.</para>
             
             <para><note>For color images the histogram equalization is applied to each color plane separately.</note></para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             HistogramEqualization filter = new HistogramEqualization( );
             // process image
             filter.ApplyInPlace( sourceImage );
             </code>
             
             <para><b>Source image:</b></para>
             <img src="img/imaging/sample5.jpg" width="480" height="387" />
             <para><b>Result image:</b></para>
             <img src="img/imaging/equalized.jpg" width="480" height="387" />
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HistogramEqualization.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.HistogramEqualization"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.HistogramEqualization.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HistogramEqualization.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.ExtractChannel">
            <summary>
            Extract RGB channel from image.
            </summary>
            
            <remarks><para>Extracts specified channel of color image and returns
            it as grayscale image.</para>
            
            <para>The filter accepts 24, 32, 48 and 64 bpp color images and produces
            8 (if source is 24 or 32 bpp image) or 16 (if source is 48 or 64 bpp image)
            bpp grayscale image.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ExtractChannel filter = new ExtractChannel( RGB.G );
            // apply the filter
            Bitmap channelImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/extract_channel.jpg" width="480" height="361"/>
            
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.ReplaceChannel"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ExtractChannel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ExtractChannel"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ExtractChannel.#ctor(System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ExtractChannel"/> class.
            </summary>
            
            <param name="channel">ARGB channel to extract.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ExtractChannel.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Can not extract alpha channel from none ARGB image. The
            exception is throw, when alpha channel is requested from RGB image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ExtractChannel.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ExtractChannel.Channel">
            <summary>
            ARGB channel to extract.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:AForge.Imaging.RGB.R"/>.</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid channel is specified.</exception>
            
        </member>
        <member name="T:AForge.Imaging.Filters.FloydSteinbergDithering">
            <summary>
            Dithering using Floyd-Steinberg error diffusion.
            </summary>
            
            <remarks><para>The filter represents binarization filter, which is based on
            error diffusion dithering with <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering">Floyd-Steinberg</a>
            coefficients. Error is diffused on 4 neighbor pixels with next coefficients:</para>
            
            <code lang="none">
                | * | 7 |
            | 3 | 5 | 1 |
            
            / 16
            </code>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            FloydSteinbergDithering filter = new FloydSteinbergDithering( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/grayscale.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/floyd_steinberg.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.BurkesDithering"/>
            <seealso cref="T:AForge.Imaging.Filters.JarvisJudiceNinkeDithering"/>
            <seealso cref="T:AForge.Imaging.Filters.SierraDithering"/>
            <seealso cref="T:AForge.Imaging.Filters.StuckiDithering"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FloydSteinbergDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.FloydSteinbergDithering"/> class.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Image">
            <summary>
            Core image relatad methods.
            </summary>
            
            <remarks>All methods of this class are static and represent general routines
            used by different image processing classes.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Image.IsGrayscale(System.Drawing.Bitmap)">
            <summary>
            Check if specified 8 bpp image is grayscale.
            </summary>
            
            <param name="image">Image to check.</param>
            
            <returns>Returns <b>true</b> if the image is grayscale or <b>false</b> otherwise.</returns>
            
            <remarks>The methods checks if the image is a grayscale image of 256 gradients.
            The method first examines if the image's pixel format is
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            and then it examines its palette to check if the image is grayscale or not.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Image.CreateGrayscaleImage(System.Int32,System.Int32)">
            <summary>
            Create and initialize new 8 bpp grayscale image.
            </summary>
            
            <param name="width">Image width.</param>
            <param name="height">Image height.</param>
            
            <returns>Returns the created grayscale image.</returns>
            
            <remarks>The method creates new 8 bpp grayscale image and initializes its palette.
            Grayscale image is represented as
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            image with palette initialized to 256 gradients of gray color.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Image.SetGrayscalePalette(System.Drawing.Bitmap)">
            <summary>
            Set pallete of the 8 bpp indexed image to grayscale.
            </summary>
            
            <param name="image">Image to initialize.</param>
            
            <remarks>The method initializes palette of
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            image with 256 gradients of gray color.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Provided image is not 8 bpp indexed image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Image.Clone(System.Drawing.Bitmap,System.Drawing.Imaging.PixelFormat)">
             <summary>
             Clone image.
             </summary>
             
             <param name="source">Source image.</param>
             <param name="format">Pixel format of result image.</param>
             
             <returns>Returns clone of the source image with specified pixel format.</returns>
            
             <remarks>The original <see cref="M:System.Drawing.Bitmap.Clone(System.Drawing.Rectangle,System.Drawing.Imaging.PixelFormat)">Bitmap.Clone()</see>
             does not produce the desired result - it does not create a clone with specified pixel format.
             More of it, the original method does not create an actual clone - it does not create a copy
             of the image. That is why this method was implemented to provide the functionality.</remarks> 
            
        </member>
        <member name="M:AForge.Imaging.Image.Clone(System.Drawing.Bitmap)">
            <summary>
            Clone image.
            </summary>
            
            <param name="source">Source image.</param>
            
            <returns>Return clone of the source image.</returns>
            
            <remarks>The original <see cref="M:System.Drawing.Bitmap.Clone(System.Drawing.Rectangle,System.Drawing.Imaging.PixelFormat)">Bitmap.Clone()</see>
            does not produce the desired result - it does not create an actual clone (it does not create a copy
            of the image). That is why this method was implemented to provide the functionality.</remarks> 
            
        </member>
        <member name="M:AForge.Imaging.Image.Clone(System.Drawing.Imaging.BitmapData)">
             <summary>
             Clone image.
             </summary>
             
             <param name="sourceData">Source image data.</param>
            
             <returns>Clones image from source image data. The message does not clone pallete in the
             case if the source image has indexed pixel format.</returns>
             
        </member>
        <member name="M:AForge.Imaging.Image.FormatImage(System.Drawing.Bitmap@)">
             <summary>
             Format an image.
             </summary>
             
             <param name="image">Source image to format.</param>
             
             <remarks><para>Formats the image to one of the formats, which are supported
             by the <b>AForge.Imaging</b> library. The image is left untouched in the
             case if it is already of
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format24bppRgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppRgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppArgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format48bppRgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format64bppArgb</see>
             format or it is <see cref="M:AForge.Imaging.Image.IsGrayscale(System.Drawing.Bitmap)">grayscale</see>, otherwise the image
             is converted to <see cref="T:System.Drawing.Imaging.PixelFormat">Format24bppRgb</see>
             format.</para>
             
             <para><note>The method is deprecated and <see cref="M:AForge.Imaging.Image.Clone(System.Drawing.Bitmap,System.Drawing.Imaging.PixelFormat)"/> method should
             be used instead with specifying desired pixel format.</note></para>
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Image.FromFile(System.String)">
            <summary>
            Load bitmap from file.
            </summary>
            
            <param name="fileName">File name to load bitmap from.</param>
            
            <returns>Returns loaded bitmap.</returns>
            
            <remarks><para>The method is provided as an alternative of <see cref="M:System.Drawing.Image.FromFile(System.String)"/>
            method to solve the issues of locked file. The standard .NET's method locks the source file until
            image's object is disposed, so the file can not be deleted or overwritten. This method workarounds the issue and
            does not lock the source file.</para>
            
            <para>Sample usage:</para>
            <code>
            Bitmap image = AForge.Imaging.Image.FromFile( "test.jpg" );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Image.Convert16bppTo8bpp(System.Drawing.Bitmap)">
            <summary>
            Convert bitmap with 16 bits per plane to a bitmap with 8 bits per plane.
            </summary>
            
            <param name="bimap">Source image to convert.</param>
            
            <returns>Returns new image which is a copy of the source image but with 8 bits per plane.</returns>
            
            <remarks><para>The routine does the next pixel format conversions:
            <list type="bullet">
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format16bppGrayScale">Format16bppGrayScale</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format8bppIndexed">Format8bppIndexed</see> with grayscale palette;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb">Format48bppRgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format24bppRgb">Format24bppRgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppArgb">Format64bppArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppArgb">Format32bppArgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppPArgb">Format64bppPArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppPArgb">Format32bppPArgb</see>.</item>
            </list>
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Invalid pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Image.Convert8bppTo16bpp(System.Drawing.Bitmap)">
            <summary>
            Convert bitmap with 8 bits per plane to a bitmap with 16 bits per plane.
            </summary>
            
            <param name="bimap">Source image to convert.</param>
            
            <returns>Returns new image which is a copy of the source image but with 16 bits per plane.</returns>
            
            <remarks><para>The routine does the next pixel format conversions:
            <list type="bullet">
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format8bppIndexed">Format8bppIndexed</see> (grayscale palette assumed) to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format16bppGrayScale">Format16bppGrayScale</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format24bppRgb">Format24bppRgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb">Format48bppRgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppArgb">Format32bppArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppArgb">Format64bppArgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppPArgb">Format32bppPArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppPArgb">Format64bppPArgb</see>.</item>
            </list>
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Invalid pixel format of the source image.</exception>
            
        </member>
        <member name="T:AForge.Imaging.Filters.YCbCrLinear">
            <summary>
            Linear correction of YCbCr channels.
            </summary>
            
            <remarks><para>The filter operates in <b>YCbCr</b> color space and provides
            with the facility of linear correction of its channels - mapping specified channels'
            input ranges to specified output ranges.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            YCbCrLinear filter = new YCbCrLinear( );
            // configure the filter
            filter.InCb = new Range( -0.276f, 0.163f );
            filter.InCr = new Range( -0.202f, 0.500f );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/ycbcr_linear.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.HSLLinear"/>
            <seealso cref="T:AForge.Imaging.Filters.YCbCrLinear"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.YCbCrLinear.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.YCbCrLinear"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.YCbCrLinear.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrLinear.InY">
             <summary>
             Y component's input range.
             </summary>
             
             <remarks>Y component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrLinear.InCb">
             <summary>
             Cb component's input range.
             </summary>
             
             <remarks>Cb component is measured in the range of [-0.5, 0.5].</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrLinear.InCr">
             <summary>
             Cr component's input range.
             </summary>
             
             <remarks>Cr component is measured in the range of [-0.5, 0.5].</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrLinear.OutY">
             <summary>
             Y component's output range.
             </summary>
             
             <remarks>Y component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrLinear.OutCb">
             <summary>
             Cb component's output range.
             </summary>
             
             <remarks>Cb component is measured in the range of [-0.5, 0.5].</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrLinear.OutCr">
             <summary>
             Cr component's output range.
             </summary>
             
             <remarks>Cr component is measured in the range of [-0.5, 0.5].</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrLinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.ResizeBilinear">
             <summary>
             Resize image using bilinear interpolation algorithm.
             </summary>
             
             <remarks><para>The class implements image resizing filter using bilinear
             interpolation algorithm.</para>
             
             <para>The filter accepts 8 grayscale images and 24/32 bpp
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             ResizeBilinear filter = new ResizeBilinear( 400, 300 );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample9.png" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/resize_bilinear.png" width="400" height="300"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.ResizeNearestNeighbor"/>
             <seealso cref="T:AForge.Imaging.Filters.ResizeBicubic"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ResizeBilinear.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ResizeBilinear"/> class.
            </summary>
            
            <param name="newWidth">Width of the new image.</param>
            <param name="newHeight">Height of the new image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ResizeBilinear.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ResizeBilinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.OilPainting">
            <summary>
            Oil painting filter.
            </summary>
            
            <remarks><para>Processing source image the filter changes each pixels' value
            to the value of pixel with the most frequent intensity within window of the
            <see cref="P:AForge.Imaging.Filters.OilPainting.BrushSize">specified size</see>. Going through the window the filters
            finds which intensity of pixels is the most frequent. Then it updates value
            of the pixel in the center of the window to the value with the most frequent
            intensity. The update procedure creates the effect of oil painting.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            OilPainting filter = new OilPainting( 15 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/oil_painting.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.OilPainting.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.OilPainting"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.OilPainting.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.OilPainting"/> class.
            </summary>
            
            <param name="brushSize">Brush size.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.OilPainting.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.OilPainting.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.OilPainting.BrushSize">
            <summary>
            Brush size, [3, 21].
            </summary>
            
            <remarks><para>Window size to search for most frequent pixels' intensity.</para>
            
            <para>Default value is set to <b>5</b>.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ExtractNormalizedRGBChannel">
            <summary>
            Extract normalized RGB channel from color image.
            </summary>
            
            <remarks><para>Extracts specified normalized RGB channel of color image and returns
            it as grayscale image.</para>
            
            <para><note>Normalized RGB color space is defined as:
            <code lang="none">
            r = R / (R + G + B ),
            g = G / (R + G + B ),
            b = B / (R + G + B ),
            </code>
            where <b>R</b>, <b>G</b> and <b>B</b> are components of RGB color space and
            <b>r</b>, <b>g</b> and <b>b</b> are components of normalized RGB color space.
            </note></para>
            
            <para>The filter accepts 24, 32, 48 and 64 bpp color images and produces
            8 (if source is 24 or 32 bpp image) or 16 (if source is 48 or 64 bpp image)
            bpp grayscale image.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ExtractNormalizedRGBChannel filter = new ExtractNormalizedRGBChannel( RGB.G );
            // apply the filter
            Bitmap channelImage = filter.Apply( image );
            </code>
            
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.ExtractChannel"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ExtractNormalizedRGBChannel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ExtractNormalizedRGBChannel"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ExtractNormalizedRGBChannel.#ctor(System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ExtractNormalizedRGBChannel"/> class.
            </summary>
            
            <param name="channel">Normalized RGB channel to extract.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ExtractNormalizedRGBChannel.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ExtractNormalizedRGBChannel.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ExtractNormalizedRGBChannel.Channel">
            <summary>
            Normalized RGB channel to extract.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:AForge.Imaging.RGB.R"/>.</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid channel is specified.</exception>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BinaryDilatation3x3">
            <summary>
            Binary dilatation operator from Mathematical Morphology with 3x3 structuring element.
            </summary>
            
            <remarks><para>The filter represents an optimized version of <see cref="T:AForge.Imaging.Filters.Dilatation"/>
            filter, which is aimed for binary images (containing black and white pixels) processed
            with 3x3 structuring element. This makes this filter ideal for growing objects in binary
            images – it puts white pixel to the destination image in the case if there is at least
            one white neighbouring pixel in the source image.</para>
            
            <para>See <see cref="T:AForge.Imaging.Filters.Dilatation"/> filter, which represents generic version of
            dilatation filter supporting custom structuring elements and wider range of image formats.</para>
            
            <para>The filter accepts 8 bpp grayscale (binary) images for processing.</para>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Dilatation"/>
            <seealso cref="T:AForge.Imaging.Filters.Dilatation3x3"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BinaryDilatation3x3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BinaryDilatation3x3"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BinaryDilatation3x3.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Processing rectangle mast be at least 3x3 in size.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BinaryDilatation3x3.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.SobelEdgeDetector">
            <summary>
            Sobel edge detector.
            </summary>
            
            <remarks><para>The filter searches for objects' edges by applying Sobel operator.</para>
            
            <para>Each pixel of the result image is calculated as approximated absolute gradient
            magnitude for corresponding pixel of the source image:
            <code lang="none">
            |G| = |Gx| + |Gy] ,
            </code>
            where Gx and Gy are calculate utilizing Sobel convolution kernels:
            <code lang="none">
               Gx         Gy
            -1 0 +1    +1 +2 +1
            -2 0 +2     0  0  0
            -1 0 +1    -1 -2 -1
            </code>
            Using the above kernel the approximated magnitude for pixel <b>x</b> is calculate using
            the next equation:
            <code lang="none">
            P1 P2 P3
            P8  x P4
            P7 P6 P5
            
            |G| = |P1 + 2P2 + P3 - P7 - 2P6 - P5| +
                  |P3 + 2P4 + P5 - P1 - 2P8 - P7|
            </code>
            </para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SobelEdgeDetector filter = new SobelEdgeDetector( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample2.jpg" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/sobel_edges.png" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.DifferenceEdgeDetector"/>
            <seealso cref="T:AForge.Imaging.Filters.HomogenityEdgeDetector"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SobelEdgeDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SobelEdgeDetector"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SobelEdgeDetector.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SobelEdgeDetector.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.SobelEdgeDetector.ScaleIntensity">
            <summary>
            Scale intensity or not.
            </summary>
            
            <remarks><para>The property determines if edges' pixels intensities of the result image
            should be scaled in the range of the lowest and the highest possible intensity
            values.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Sharpen">
            <summary>
            Sharpen filter
            </summary>
            
            <remarks><para>The filter performs <see cref="T:AForge.Imaging.Filters.Convolution">convolution filter</see> using
            the sharpen kernel:</para>
            
            <code lang="none">
             0  -1   0
            -1   5  -1
             0  -1   0
            </code>
            
            <para>For the list of supported pixel formats, see the documentation to <see cref="T:AForge.Imaging.Filters.Convolution"/>
            filter.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Sharpen filter = new Sharpen( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/sharpen.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Convolution"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Sharpen.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Sharpen"/> class.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.Sepia">
             <summary>
             Sepia filter - old brown photo.
             </summary>
            
             <remarks><para>The filter makes an image look like an old brown photo. The main
             idea of the algorithm:
             <list type="bullet">
             <item>transform to YIQ color space;</item>
             <item>modify it;</item>
             <item>transform back to RGB.</item>
             </list></para>
             
             <para>
             <b>1) RGB -> YIQ</b>:
             <code lang="none">
            	Y = 0.299 * R + 0.587 * G + 0.114 * B
            	I = 0.596 * R - 0.274 * G - 0.322 * B
            	Q = 0.212 * R - 0.523 * G + 0.311 * B
            	</code>
            	</para>
            	
             <para>
             <b>2) update</b>:
             <code lang="none">
            	I = 51
            	Q = 0
            	</code>
            	</para>
            	
             <para>
            	<b>3) YIQ -> RGB</b>:
             <code lang="none">
            	R = 1.0 * Y + 0.956 * I + 0.621 * Q
            	G = 1.0 * Y - 0.272 * I - 0.647 * Q
            	B = 1.0 * Y - 1.105 * I + 1.702 * Q
            	</code>
            	</para>
             
             <para>The filter accepts 24/32 bpp color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Sepia filter = new Sepia( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="img/imaging/sepia.jpg" width="480" height="361" />
             </remarks> 
            
        </member>
        <member name="M:AForge.Imaging.Filters.Sepia.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Sepia"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Sepia.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Sepia.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.Invert">
             <summary>
             Invert image.
             </summary>
             
             <remarks><para>The filter inverts colored and grayscale images.</para>
            
             <para>The filter accepts 8, 16 bpp grayscale and 24, 48 bpp color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Invert filter = new Invert( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="img/imaging/invert.jpg" width="480" height="361" />
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Invert.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Invert"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Invert.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Invert.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.EuclideanColorFiltering">
             <summary>
             Euclidean color filtering.
             </summary>
             
             <remarks><para>The filter filters pixels, which color is inside/outside
             of RGB sphere with specified center and radius - it keeps pixels with
             colors inside/outside of the specified sphere and fills the rest with
             <see cref="P:AForge.Imaging.Filters.EuclideanColorFiltering.FillColor">specified color</see>.</para>
             
             <para>The filter accepts 24 and 32 bpp color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             EuclideanColorFiltering filter = new EuclideanColorFiltering( );
             // set center colol and radius
             filter.CenterColor = new RGB( 215, 30, 30 );
             filter.Radius = 100;
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
            
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/euclidean_filtering.jpg" width="480" height="361"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.ColorFiltering"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.EuclideanColorFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.EuclideanColorFiltering"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.EuclideanColorFiltering.#ctor(AForge.Imaging.RGB,System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.EuclideanColorFiltering"/> class.
            </summary>
            
            <param name="center">RGB sphere's center.</param>
            <param name="radius">RGB sphere's radius.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.EuclideanColorFiltering.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.EuclideanColorFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.EuclideanColorFiltering.Radius">
            <summary>
            RGB sphere's radius, [0, 450].
            </summary>
            
            <remarks>Default value is 100.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.EuclideanColorFiltering.CenterColor">
            <summary>
            RGB sphere's center.
            </summary>
            
            <remarks>Default value is (255, 255, 255) - white color.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.EuclideanColorFiltering.FillColor">
            <summary>
            Fill color used to fill filtered pixels.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.EuclideanColorFiltering.FillOutside">
            <summary>
            Determines, if pixels should be filled inside or outside specified
            RGB sphere.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/>, which means
            the filter removes colors outside of the specified range.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.ExhaustiveTemplateMatching">
            <summary>
            Exhaustive template matching.
            </summary>
            
            <remarks><para>The class implements exhaustive template matching algorithm,
            which performs complete scan of source image, comparing each pixel with corresponding
            pixel of template.</para>
            
            <para>The class processes only grayscale 8 bpp and color 24 bpp images.</para>
            
            <para>Sample usage:</para>
            <code>
            // create template matching algorithm's instance
            ExhaustiveTemplateMatching tm = new ExhaustiveTemplateMatching( 0.9f );
            // find all matchings with specified above similarity
            TemplateMatch[] matchings = tm.ProcessImage( sourceImage, templateImage );
            // highlight found matchings
            BitmapData data = sourceImage.LockBits(
                new Rectangle( 0, 0, sourceImage.Width, sourceImage.Height ),
                ImageLockMode.ReadWrite, sourceImage.PixelFormat );
            foreach ( TemplateMatch m in matchings )
            {
                Drawing.Rectangle( data, m.Rectangle, Color.White );
                // do something else with matching
            }
            sourceImage.UnlockBits( data );
            </code>
            
            <para>The class also can be used to get similarity level between two image of the same
            size, which can be useful to get information about how different/similar are images:</para>
            <code>
            // create template matching algorithm's instance
            // use zero similarity to make sure algorithm will provide anything
            ExhaustiveTemplateMatching tm = new ExhaustiveTemplateMatching( 0 );
            // compare two images
            TemplateMatch[] matchings = tm.ProcessImage( image1, image2 );
            // check similarity level
            if ( matchings[0].Similarity > 0.95f )
            {
                // do something with quite similar images
            }
            </code>
            
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveTemplateMatching.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ExhaustiveTemplateMatching"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveTemplateMatching.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ExhaustiveTemplateMatching"/> class.
            </summary>
            
            <param name="similarityThreshold">Similarity threshold.</param>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveTemplateMatching.ProcessImage(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="template">Template image to search for.</param>
            
            <returns>Returns array of found template matches. The array is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Template image is bigger than source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveTemplateMatching.ProcessImage(System.Drawing.Bitmap,System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="template">Template image to search for.</param>
            <param name="searchZone">Rectangle in source image to search template for.</param>
            
            <returns>Returns array of found template matches. The array is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Template image is bigger than source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveTemplateMatching.ProcessImage(System.Drawing.Imaging.BitmapData,System.Drawing.Imaging.BitmapData)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            <param name="templateData">Template image to search for.</param>
            
            <returns>Returns array of found template matches. The array is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Template image is bigger than source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveTemplateMatching.ProcessImage(System.Drawing.Imaging.BitmapData,System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            <param name="templateData">Template image to search for.</param>
            <param name="searchZone">Rectangle in source image to search template for.</param>
            
            <returns>Returns array of found template matches. The array is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Template image is bigger than source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveTemplateMatching.ProcessImage(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process image looking for matchings with specified template.
             </summary>
             
             <param name="image">Unmanaged source image to process.</param>
             <param name="template">Unmanaged template image to search for.</param>
             
             <returns>Returns array of found template matches. The array is sorted by similarity
             of found matches in descending order.</returns>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Template image is bigger than source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveTemplateMatching.ProcessImage(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process image looking for matchings with specified template.
             </summary>
             
             <param name="image">Unmanaged source image to process.</param>
             <param name="template">Unmanaged template image to search for.</param>
             <param name="searchZone">Rectangle in source image to search template for.</param>
             
             <returns>Returns array of found template matches. The array is sorted by similarity
             of found matches in descending order.</returns>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Template image is bigger than search zone.</exception>
            
        </member>
        <member name="P:AForge.Imaging.ExhaustiveTemplateMatching.SimilarityThreshold">
            <summary>
            Similarity threshold, [0..1].
            </summary>
            
            <remarks><para>The property sets the minimal acceptable similarity between template
            and potential found candidate. If similarity is lower than this value,
            then object is not treated as matching with template.
            </para>
            
            <para>Default value is set to <b>0.9</b>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.ExhaustiveBlockMatching">
            <summary>
            Block matching implementation with the exhaustive search algorithm.
            </summary>
            
            <remarks><para>The class implements exhaustive search block matching algorithm
            (see documentation for <see cref="T:AForge.Imaging.IBlockMatching"/> for information about
            block matching algorithms). Exhaustive search algorithm tests each possible
            location of block within search window trying to find a match with minimal
            difference.</para>
            
            <para><note>Because of the exhaustive nature of the algorithm, high performance
            should not be expected in the case if big number of reference points is provided
            or big block size and search radius are specified. Minimizing theses values increases
            performance. But too small block size and search radius may affect quality.</note></para>
            
            <para><note>The class processes only grayscale (8 bpp indexed) and color (24 bpp) images.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // collect reference points using corners detector (for example)
            SusanCornersDetector scd = new SusanCornersDetector( 30, 18 );
            List&lt;IntPoint&gt; points = scd.ProcessImage( sourceImage );
            
            // create block matching algorithm's instance
            ExhaustiveBlockMatching bm = new ExhaustiveBlockMatching( 8, 12 );
            // process images searching for block matchings
            List&lt;BlockMatch&gt; matches = bm.ProcessImage( sourceImage, points, searchImage );
            
            // draw displacement vectors
            BitmapData data = sourceImage.LockBits(
                new Rectangle( 0, 0, sourceImage.Width, sourceImage.Height ),
                ImageLockMode.ReadWrite, sourceImage.PixelFormat );
            
            foreach ( BlockMatch match in matches )
            {
                // highlight the original point in source image
                Drawing.FillRectangle( data,
                    new Rectangle( match.SourcePoint.X - 1, match.SourcePoint.Y - 1, 3, 3 ),
                    Color.Yellow );
                // draw line to the point in search image
                Drawing.Line( data, match.SourcePoint, match.MatchPoint, Color.Red );
            
                // check similarity
                if ( match.Similarity &gt; 0.98f )
                {
                    // process block with high similarity somehow special
                }
            }
            
            sourceImage.UnlockBits( data );
            </code>
            
            <para><b>Test image 1 (source):</b></para>
            <img src="img/imaging/ebm_sample1.png" width="217" height="192"/>
            <para><b>Test image 2 (search):</b></para>
            <img src="img/imaging/ebm_sample2.png" width="217" height="192"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/ebm_result.png" width="217" height="192"/>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.IBlockMatching">
            <summary>
            Block matching interface.
            </summary>
            
            <remarks><para>The interface specifies set of methods, which should be implemented by different
            block matching algorithms.</para>
            
            <para>Block matching algorithms work with two images - source and search image - and
            a set of reference points. For each provided reference point, the algorithm takes
            a block from source image (reference point is a coordinate of block's center) and finds
            the best match for it in search image providing its coordinate (search is done within
            search window of specified size). In other words, block matching algorithm tries to
            find new coordinates in search image of specified reference points in source image.
            </para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.IBlockMatching.ProcessImage(System.Drawing.Bitmap,System.Collections.Generic.List{AForge.IntPoint},System.Drawing.Bitmap)">
            <summary>
            Process images matching blocks between them.
            </summary>
            
            <param name="sourceImage">Source image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImage">Image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches.</returns>
            
        </member>
        <member name="M:AForge.Imaging.IBlockMatching.ProcessImage(System.Drawing.Imaging.BitmapData,System.Collections.Generic.List{AForge.IntPoint},System.Drawing.Imaging.BitmapData)">
            <summary>
            Process images matching blocks between them.
            </summary>
            
            <param name="sourceImageData">Source image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImageData">Image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches.</returns>
            
        </member>
        <member name="M:AForge.Imaging.IBlockMatching.ProcessImage(AForge.Imaging.UnmanagedImage,System.Collections.Generic.List{AForge.IntPoint},AForge.Imaging.UnmanagedImage)">
            <summary>
            Process images matching blocks between them.
            </summary>
            
            <param name="sourceImage">Source unmanaged image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImage">Unmanaged image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches.</returns>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveBlockMatching.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ExhaustiveBlockMatching"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.ExhaustiveBlockMatching.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ExhaustiveBlockMatching"/> class.
            </summary>
            
            <param name="blockSize">Block size to search for.</param>
            <param name="searchRadius">Search radius.</param>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveBlockMatching.ProcessImage(System.Drawing.Bitmap,System.Collections.Generic.List{AForge.IntPoint},System.Drawing.Bitmap)">
            <summary>
            Process images matching blocks between hem.
            </summary>
            
            <param name="sourceImage">Source image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImage">Image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches. The list is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Source and search images sizes must match.</exception>
            <exception cref="T:System.ArgumentException">Source images can be grayscale (8 bpp indexed) or color (24 bpp) image only.</exception>
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Source and search images must have same pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveBlockMatching.ProcessImage(System.Drawing.Imaging.BitmapData,System.Collections.Generic.List{AForge.IntPoint},System.Drawing.Imaging.BitmapData)">
            <summary>
            Process images matching blocks between them.
            </summary>
            
            <param name="sourceImageData">Source image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImageData">Image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches. The list is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Source and search images sizes must match.</exception>
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source images can be grayscale (8 bpp indexed) or color (24 bpp) image only.</exception>
            <exception cref="T:System.ArgumentException">Source and search images must have same pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ExhaustiveBlockMatching.ProcessImage(AForge.Imaging.UnmanagedImage,System.Collections.Generic.List{AForge.IntPoint},AForge.Imaging.UnmanagedImage)">
            <summary>
            Process images matching blocks between them.
            </summary>
            
            <param name="sourceImage">Source unmanaged image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImage">Unmanaged image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches. The list is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Source and search images sizes must match.</exception>
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source images can be grayscale (8 bpp indexed) or color (24 bpp) image only.</exception>
            <exception cref="T:System.ArgumentException">Source and search images must have same pixel format.</exception>
            
        </member>
        <member name="P:AForge.Imaging.ExhaustiveBlockMatching.SearchRadius">
            <summary>
            Search radius.
            </summary>
            
            <remarks><para>The value specifies the shift from reference point in all
            four directions, used to search for the best matching block.</para>
            
            <para>Default value is set to <b>12</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.ExhaustiveBlockMatching.BlockSize">
            <summary>
            Block size to search for.
            </summary>
            
            <remarks><para>The value specifies block size to search for. For each provided
            reference pointer, a square block of this size is taken from the source image
            (reference point becomes the coordinate of block's center) and the best match
            is searched in second image within specified <see cref="P:AForge.Imaging.ExhaustiveBlockMatching.SearchRadius">search
            radius</see>.</para>
            
            <para>Default value is set to <b>16</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.ExhaustiveBlockMatching.SimilarityThreshold">
            <summary>
            Similarity threshold, [0..1].
            </summary>
            
            <remarks><para>The property sets the minimal acceptable similarity between blocks
            in source and search images. If similarity is lower than this value,
            then the candidate block in search image is not treated as a match for the block
            in source image.
            </para>
            
            <para>Default value is set to <b>0.9</b>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.UnsupportedImageFormatException">
            <summary>
            Unsupported image format exception.
            </summary>
            
            <remarks><para>The unsupported image format exception is thrown in the case when
            user passes an image of certain format to an image processing routine, which does
            not support the format. Check documentation of the image processing routine
            to discover which formats are supported by the routine.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.UnsupportedImageFormatException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.UnsupportedImageFormatException"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.UnsupportedImageFormatException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.UnsupportedImageFormatException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:AForge.Imaging.UnsupportedImageFormatException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.UnsupportedImageFormatException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            <param name="paramName">Name of the invalid parameter.</param>
            
        </member>
        <member name="T:AForge.Imaging.InvalidImagePropertiesException">
            <summary>
            Invalid image properties exception.
            </summary>
            
            <remarks><para>The invalid image properties exception is thrown in the case when
            user provides an image with certain properties, which are treated as invalid by
            particular image processing routine. Another case when this exception is
            thrown is the case when user tries to access some properties of an image (or
            of a recently processed image by some routine), which are not valid for that image.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.InvalidImagePropertiesException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.InvalidImagePropertiesException"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.InvalidImagePropertiesException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.InvalidImagePropertiesException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:AForge.Imaging.InvalidImagePropertiesException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.InvalidImagePropertiesException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            <param name="paramName">Name of the invalid parameter.</param>
            
        </member>
        <member name="T:AForge.Imaging.ComplexImage">
            <summary>
            Complex image.
            </summary>
            
            <remarks><para>The class is used to keep image represented in complex numbers sutable for Fourier
            transformations.</para>
            
            <para>Sample usage:</para>
            <code>
            // create complex image
            ComplexImage complexImage = ComplexImage.FromBitmap( image );
            // do forward Fourier transformation
            complexImage.ForwardFourierTransform( );
            // get complex image as bitmat
            Bitmap fourierImage = complexImage.ToBitmap( );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample3.jpg" width="256" height="256" />
            <para><b>Fourier image:</b></para>
            <img src="img/imaging/fourier.jpg" width="256" height="256" />
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.ComplexImage.#ctor(System.Int32,System.Int32)">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.ComplexImage"/> class.
             </summary>
             
             <param name="width">Image width.</param>
             <param name="height">Image height.</param>
             
             <remarks>The constractor is protected, what makes it imposible to instantiate this
             class directly. To create an instance of this class <see cref="M:AForge.Imaging.ComplexImage.FromBitmap(System.Drawing.Bitmap)"/> or
             <see cref="M:AForge.Imaging.ComplexImage.FromBitmap(System.Drawing.Imaging.BitmapData)"/> method should be used.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.ComplexImage.Clone">
            <summary>
            Clone the complex image.
            </summary>
            
            <returns>Returns copy of the complex image.</returns>
            
        </member>
        <member name="M:AForge.Imaging.ComplexImage.FromBitmap(System.Drawing.Bitmap)">
            <summary>
            Create complex image from grayscale bitmap.
            </summary>
            
            <param name="image">Source grayscale bitmap (8 bpp indexed).</param>
            
            <returns>Returns an instance of complex image.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Image width and height should be power of 2.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ComplexImage.FromBitmap(System.Drawing.Imaging.BitmapData)">
            <summary>
            Create complex image from grayscale bitmap.
            </summary>
            
            <param name="imageData">Source image data (8 bpp indexed).</param>
            
            <returns>Returns an instance of complex image.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Image width and height should be power of 2.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ComplexImage.ToBitmap">
            <summary>
            Convert complex image to bitmap.
            </summary>
            
            <returns>Returns grayscale bitmap.</returns>
            
        </member>
        <member name="M:AForge.Imaging.ComplexImage.ForwardFourierTransform">
            <summary>
            Applies forward fast Fourier transformation to the complex image.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.ComplexImage.BackwardFourierTransform">
            <summary>
            Applies backward fast Fourier transformation to the complex image.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ComplexImage.Width">
            <summary>
            Image width.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ComplexImage.Height">
            <summary>
            Image height.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ComplexImage.FourierTransformed">
            <summary>
            Status of the image - Fourier transformed or not.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ComplexImage.Data">
            <summary>
            Complex image's data.
            </summary>
            
            <remarks>Return's 2D array of [<b>height</b>, <b>width</b>] size, which keeps image's
            complex data.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.RGB">
            <summary>
            RGB components.
            </summary>
            
            <remarks><para>The class encapsulates <b>RGB</b> color components.</para>
            <para><note><see cref="T:System.Drawing.Imaging.PixelFormat">PixelFormat.Format24bppRgb</see>
            actually means BGR format.</note></para>
            </remarks>
            
        </member>
        <member name="F:AForge.Imaging.RGB.R">
            <summary>
            Index of red component.
            </summary>
        </member>
        <member name="F:AForge.Imaging.RGB.G">
            <summary>
            Index of green component.
            </summary>
        </member>
        <member name="F:AForge.Imaging.RGB.B">
            <summary>
            Index of blue component.
            </summary>
        </member>
        <member name="F:AForge.Imaging.RGB.A">
            <summary>
            Index of alpha component for ARGB images.
            </summary>
        </member>
        <member name="F:AForge.Imaging.RGB.Red">
            <summary>
            Red component.
            </summary>
        </member>
        <member name="F:AForge.Imaging.RGB.Green">
            <summary>
            Green component.
            </summary>
        </member>
        <member name="F:AForge.Imaging.RGB.Blue">
            <summary>
            Blue component.
            </summary>
        </member>
        <member name="F:AForge.Imaging.RGB.Alpha">
            <summary>
            Alpha component.
            </summary>
        </member>
        <member name="M:AForge.Imaging.RGB.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.RGB"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.RGB.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.RGB"/> class.
            </summary>
            
            <param name="red">Red component.</param>
            <param name="green">Green component.</param>
            <param name="blue">Blue component.</param>
            
        </member>
        <member name="M:AForge.Imaging.RGB.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.RGB"/> class.
            </summary>
            
            <param name="red">Red component.</param>
            <param name="green">Green component.</param>
            <param name="blue">Blue component.</param>
            <param name="alpha">Alpha component.</param>
            
        </member>
        <member name="M:AForge.Imaging.RGB.#ctor(System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.RGB"/> class.
            </summary>
            
            <param name="color">Initialize from specified <see cref="T:System.Drawing.Color">color.</see></param>
            
        </member>
        <member name="P:AForge.Imaging.RGB.Color">
            <summary>
            <see cref="T:System.Drawing.Color">Color</see> value of the class.
            </summary>
        </member>
        <member name="T:AForge.Imaging.HSL">
            <summary>
            HSL components.
            </summary>
            
            <remarks>The class encapsulates <b>HSL</b> color components.</remarks>
            
        </member>
        <member name="F:AForge.Imaging.HSL.Hue">
            <summary>
            Hue component.
            </summary>
            
            <remarks>Hue is measured in the range of [0, 359].</remarks>
            
        </member>
        <member name="F:AForge.Imaging.HSL.Saturation">
            <summary>
            Saturation component.
            </summary>
            
            <remarks>Saturation is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="F:AForge.Imaging.HSL.Luminance">
            <summary>
            Luminance value.
            </summary>
            
            <remarks>Luminance is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="M:AForge.Imaging.HSL.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.HSL"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.HSL.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.HSL"/> class.
            </summary>
            
            <param name="hue">Hue component.</param>
            <param name="saturation">Saturation component.</param>
            <param name="luminance">Luminance component.</param>
            
        </member>
        <member name="M:AForge.Imaging.HSL.FromRGB(AForge.Imaging.RGB,AForge.Imaging.HSL)">
            <summary>
            Convert from RGB to HSL color space.
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            <param name="hsl">Destination color in <b>HSL</b> color space.</param>
            
            <remarks><para>See <a href="http://en.wikipedia.org/wiki/HSI_color_space#Conversion_from_RGB_to_HSL_or_HSV">HSL and HSV Wiki</a>
            for information about the algorithm to convert from RGB to HSL.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.HSL.FromRGB(AForge.Imaging.RGB)">
            <summary>
            Convert from RGB to HSL color space.
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            
            <returns>Returns <see cref="T:AForge.Imaging.HSL"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="M:AForge.Imaging.HSL.ToRGB(AForge.Imaging.HSL,AForge.Imaging.RGB)">
            <summary>
            Convert from HSL to RGB color space.
            </summary>
            
            <param name="hsl">Source color in <b>HSL</b> color space.</param>
            <param name="rgb">Destination color in <b>RGB</b> color space.</param>
            
        </member>
        <member name="M:AForge.Imaging.HSL.ToRGB">
            <summary>
            Convert the color to <b>RGB</b> color space.
            </summary>
            
            <returns>Returns <see cref="T:AForge.Imaging.RGB"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="T:AForge.Imaging.YCbCr">
            <summary>
            YCbCr components.
            </summary>
            
            <remarks>The class encapsulates <b>YCbCr</b> color components.</remarks>
            
        </member>
        <member name="F:AForge.Imaging.YCbCr.YIndex">
            <summary>
            Index of <b>Y</b> component.
            </summary>
        </member>
        <member name="F:AForge.Imaging.YCbCr.CbIndex">
            <summary>
            Index of <b>Cb</b> component.
            </summary>
        </member>
        <member name="F:AForge.Imaging.YCbCr.CrIndex">
            <summary>
            Index of <b>Cr</b> component.
            </summary>
        </member>
        <member name="F:AForge.Imaging.YCbCr.Y">
            <summary>
            <b>Y</b> component.
            </summary>
        </member>
        <member name="F:AForge.Imaging.YCbCr.Cb">
            <summary>
            <b>Cb</b> component.
            </summary>
        </member>
        <member name="F:AForge.Imaging.YCbCr.Cr">
            <summary>
            <b>Cr</b> component.
            </summary>
        </member>
        <member name="M:AForge.Imaging.YCbCr.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.YCbCr"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.YCbCr.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.YCbCr"/> class.
            </summary>
            
            <param name="y"><b>Y</b> component.</param>
            <param name="cb"><b>Cb</b> component.</param>
            <param name="cr"><b>Cr</b> component.</param>
            
        </member>
        <member name="M:AForge.Imaging.YCbCr.FromRGB(AForge.Imaging.RGB,AForge.Imaging.YCbCr)">
            <summary>
            Convert from RGB to YCbCr color space (Rec 601-1 specification). 
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            <param name="ycbcr">Destination color in <b>YCbCr</b> color space.</param>
            
        </member>
        <member name="M:AForge.Imaging.YCbCr.FromRGB(AForge.Imaging.RGB)">
            <summary>
            Convert from RGB to YCbCr color space (Rec 601-1 specification).
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            
            <returns>Returns <see cref="T:AForge.Imaging.YCbCr"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="M:AForge.Imaging.YCbCr.ToRGB(AForge.Imaging.YCbCr,AForge.Imaging.RGB)">
            <summary>
            Convert from YCbCr to RGB color space.
            </summary>
            
            <param name="ycbcr">Source color in <b>YCbCr</b> color space.</param>
            <param name="rgb">Destination color in <b>RGB</b> color spacs.</param>
            
        </member>
        <member name="M:AForge.Imaging.YCbCr.ToRGB">
            <summary>
            Convert the color to <b>RGB</b> color space.
            </summary>
            
            <returns>Returns <see cref="T:AForge.Imaging.RGB"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="T:AForge.Imaging.ColorReduction.OrderedColorDithering">
            <summary>
            Color dithering with a thresold matrix (ordered dithering).
            </summary>
            
            <remarks><para>The class implements ordered color dithering as described on
            <a href="http://en.wikipedia.org/wiki/Ordered_dithering">Wikipedia</a>.
            The algorithm achieves dithering by applying a <see cref="P:AForge.Imaging.ColorReduction.OrderedColorDithering.ThresholdMatrix">threshold map</see> on
            the pixels displayed, causing some of the pixels to be rendered at a different color, depending on
            how far in between the color is of available <see cref="P:AForge.Imaging.ColorReduction.OrderedColorDithering.ColorTable">color entries</see>.</para>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
            produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
            <see cref="P:AForge.Imaging.ColorReduction.OrderedColorDithering.ColorTable">color table</see> - 4 bpp result for
            color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
            
            <para>Sample usage:</para>
            <code>
            // create color image quantization routine
            ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
            // create 256 colors table
            Color[] colorTable = ciq.CalculatePalette( image, 256 );
            // create dithering routine
            OrderedColorDithering dithering = new OrderedColorDithering( );
            dithering.ColorTable = colorTable;
            // apply the dithering routine
            Bitmap newImage = dithering.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/ordered_color_dithering.png" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.OrderedColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ColorReduction.OrderedColorDithering"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.OrderedColorDithering.#ctor(System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ColorReduction.OrderedColorDithering"/> class.
            </summary>
            
            <param name="matrix">Threshold matrix (see <see cref="P:AForge.Imaging.ColorReduction.OrderedColorDithering.ThresholdMatrix"/> property).</param>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.OrderedColorDithering.Apply(System.Drawing.Bitmap)">
            <summary>
            Perform color dithering for the specified image.
            </summary>
            
            <param name="sourceImage">Source image to do color dithering for.</param>
            
            <returns>Returns color dithered image. See <see cref="P:AForge.Imaging.ColorReduction.OrderedColorDithering.ColorTable"/> for information about format of
            the result image.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. It must 24 or 32 bpp color image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.OrderedColorDithering.Apply(AForge.Imaging.UnmanagedImage)">
            <summary>
            Perform color dithering for the specified image.
            </summary>
            
            <param name="sourceImage">Source image to do color dithering for.</param>
            
            <returns>Returns color dithered image. See <see cref="P:AForge.Imaging.ColorReduction.OrderedColorDithering.ColorTable"/> for information about format of
            the result image.</returns>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. It must 24 or 32 bpp color image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.ColorReduction.OrderedColorDithering.ThresholdMatrix">
            <summary>
            Threshold matrix - values to add source image's values.
            </summary>
            
            <remarks><para>The property keeps a threshold matrix, which is applied to values of a source image
            to dither. By adding these values to the source image the algorithm produces the effect when pixels
            of the same color in source image may have different color in the result image (which depends on pixel's
            position). This threshold map is also known as an index matrix or Bayer matrix.</para>
            
            <para>By default the property is inialized with the below matrix:
            <code lang="none">
             2   18    6   22
            26   10   30   14
             8   24    4   20
            32   16   28   12
            </code>
            </para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.ColorReduction.OrderedColorDithering.ColorTable">
            <summary>
            Color table to use for image dithering. Must contain 2-256 colors.
            </summary>
            
            <remarks><para>Color table size determines format of the resulting image produced by this
            image processing routine. If color table contains 16 color or less, then result image will have
            4 bpp indexed pixel format. If color table contains more than 16 colors, then result image will
            have 8 bpp indexed pixel format.</para>
            
            <para>By default the property is initialized with default 16 colors, which are:
            Black, Dark Blue, Dark Green, Dark Cyan, Dark Red, Dark Magenta, Dark Khaki, Light Gray,
            Gray, Blue, Green, Cyan, Red, Magenta, Yellow and White.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Color table length must be in the [2, 256] range.</exception>
            
        </member>
        <member name="P:AForge.Imaging.ColorReduction.OrderedColorDithering.UseCaching">
            <summary>
            Use color caching during color dithering or not.
            </summary>
            
            <remarks><para>The property  specifies if internal cache of already processed colors should be used or not.
            For each pixel in the original image the color dithering routine does search in target color palette to find
            the best matching color. To avoid doing the search again and again for already processed colors, the class may
            use internal dictionary which maps colors of original image to indexes in target color palette.
            </para>
            
            <para><note>The property provides a trade off. On one hand it may speedup color dithering routine, but on another
            hand it increases memory usage. Also cache usage may not be efficient for very small target color tables.</note></para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.BlockMatch">
            <summary>
            Block match class keeps information about found block match. The class is
            used with block matching algorithms implementing <see cref="T:AForge.Imaging.IBlockMatching"/>
            interface.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.BlockMatch.#ctor(AForge.IntPoint,AForge.IntPoint,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.BlockMatch"/> class.
            </summary>
            
            <param name="sourcePoint">Reference point in source image.</param>
            <param name="matchPoint">Match point in search image (point of a found match).</param>
            <param name="similarity">Similarity between blocks in source and search images, [0..1].</param>
            
        </member>
        <member name="P:AForge.Imaging.BlockMatch.SourcePoint">
            <summary>
            Reference point in source image.
            </summary>
        </member>
        <member name="P:AForge.Imaging.BlockMatch.MatchPoint">
            <summary>
            Match point in search image (point of a found match).
            </summary>
        </member>
        <member name="P:AForge.Imaging.BlockMatch.Similarity">
            <summary>
            Similarity between blocks in source and search images, [0..1].
            </summary>
        </member>
        <member name="T:AForge.Imaging.Blob">
            <summary>
            Image's blob.
            </summary>
            
            <remarks><para>The class represents a blob - part of another images. The
            class encapsulates the blob itself and information about its position
            in parent image.</para>
            
            <para><note>The class is not responsible for blob's image disposing, so it should be
            done manually when it is required.</note></para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Blob.#ctor(System.Int32,System.Drawing.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Blob"/> class.
            </summary>
            
            <param name="id">Blob's ID in the original image.</param>
            <param name="rect">Blob's rectangle in the original image.</param>
            
            <remarks><para>This constructor leaves <see cref="P:AForge.Imaging.Blob.Image"/> property not initialized. The blob's
            image may be extracted later using <see cref="M:AForge.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,AForge.Imaging.Blob,System.Boolean)"/>
            or <see cref="M:AForge.Imaging.BlobCounterBase.ExtractBlobsImage(AForge.Imaging.UnmanagedImage,AForge.Imaging.Blob,System.Boolean)"/> method.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Blob.#ctor(AForge.Imaging.Blob)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Blob"/> class.
            </summary>
            
            <param name="source">Source blob to copy.</param>
            
            <remarks><para>This copy constructor leaves <see cref="P:AForge.Imaging.Blob.Image"/> property not initialized. The blob's
            image may be extracted later using <see cref="M:AForge.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,AForge.Imaging.Blob,System.Boolean)"/>
            or <see cref="M:AForge.Imaging.BlobCounterBase.ExtractBlobsImage(AForge.Imaging.UnmanagedImage,AForge.Imaging.Blob,System.Boolean)"/> method.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Blob.Image">
             <summary>
             Blob's image.
             </summary>
            
             <remarks><para>The property keeps blob's image. In the case if it equals to <b>null</b>,
             the image may be extracted using <see cref="M:AForge.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,AForge.Imaging.Blob,System.Boolean)"/>
             or <see cref="M:AForge.Imaging.BlobCounterBase.ExtractBlobsImage(AForge.Imaging.UnmanagedImage,AForge.Imaging.Blob,System.Boolean)"/> method.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Blob.OriginalSize">
            <summary>
            Blob's image size.
            </summary>
            
            <remarks><para>The property specifies size of the <see cref="P:AForge.Imaging.Blob.Image">blob's image</see>.
            If the property is set to <see langword="true"/>, the blob's image size equals to the
            size of original image. If the property is set to <see langword="false"/>, the blob's
            image size equals to size of actual blob.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Blob.Rectangle">
            <summary>
            Blob's rectangle in the original image.
            </summary>
            
            <remarks><para>The property specifies position of the blob in the original image
            and its size.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Blob.ID">
            <summary>
            Blob's ID in the original image.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Blob.Area">
            <summary>
            Blob's area.
            </summary>
            
            <remarks><para>The property equals to blob's area measured in number of pixels
            contained by the blob.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Blob.Fullness">
            <summary>
            Blob's fullness, [0, 1].
            </summary>
            
            <remarks><para>The property equals to blob's fullness, which is calculated
            as <b>Area / ( Width * Height )</b>. If it equals to <b>1</b>, then
            it means that entire blob's rectangle is filled by blob's pixel (no
            blank areas), which is true only for rectangles. If it equals to <b>0.5</b>,
            for example, then it means that only half of the bounding rectangle is filled
            by blob's pixels.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Blob.CenterOfGravity">
            <summary>
            Blob's center of gravity point.
            </summary>
            
            <remarks><para>The property keeps center of gravity point, which is calculated as
            mean value of X and Y coordinates of blob's points.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Blob.ColorMean">
            <summary>
            Blob's mean color.
            </summary>
            
            <remarks><para>The property keeps mean color of pixels comprising the blob.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Blob.ColorStdDev">
            <summary>
            Blob color's standard deviation.
            </summary>
            
            <remarks><para>The property keeps standard deviation of pixels' colors comprising the blob.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.HoughCircle">
            <summary>
            Hough circle.
            </summary>
            
            <remarks>Represents circle of Hough transform.</remarks>
            
            <seealso cref="T:AForge.Imaging.HoughCircleTransformation"/>
            
        </member>
        <member name="F:AForge.Imaging.HoughCircle.X">
            <summary>
            Circle center's X coordinate.
            </summary>
        </member>
        <member name="F:AForge.Imaging.HoughCircle.Y">
            <summary>
            Circle center's Y coordinate.
            </summary>
        </member>
        <member name="F:AForge.Imaging.HoughCircle.Radius">
            <summary>
            Circle's radius.
            </summary>
        </member>
        <member name="F:AForge.Imaging.HoughCircle.Intensity">
            <summary>
            Line's absolute intensity.
            </summary>
        </member>
        <member name="F:AForge.Imaging.HoughCircle.RelativeIntensity">
            <summary>
            Line's relative intensity.
            </summary>
        </member>
        <member name="M:AForge.Imaging.HoughCircle.#ctor(System.Int32,System.Int32,System.Int32,System.Int16,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.HoughCircle"/> class.
            </summary>
            
            <param name="x">Circle's X coordinate.</param>
            <param name="y">Circle's Y coordinate.</param>
            <param name="radius">Circle's radius.</param>
            <param name="intensity">Circle's absolute intensity.</param>
            <param name="relativeIntensity">Circle's relative intensity.</param>
            
        </member>
        <member name="M:AForge.Imaging.HoughCircle.CompareTo(System.Object)">
            <summary>
            Compare the object with another instance of this class.
            </summary>
            
            <param name="value">Object to compare with.</param>
            
            <returns><para>A signed number indicating the relative values of this instance and <b>value</b>: 1) greater than zero - 
            this instance is greater than <b>value</b>; 2) zero - this instance is equal to <b>value</b>;
            3) greater than zero - this instance is less than <b>value</b>.</para>
            
            <para><note>The sort order is descending.</note></para></returns>
            
            <remarks>
            <para><note>Object are compared using their <see cref="F:AForge.Imaging.HoughCircle.Intensity">intensity</see> value.</note></para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.HoughCircleTransformation">
             <summary>
             Hough circle transformation.
             </summary>
            
             <remarks><para>The class implements Hough circle transformation, which allows to detect
             circles of specified radius in an image.</para>
             
             <para>The class accepts binary images for processing, which are represented by 8 bpp grayscale images.
             All black pixels (0 pixel's value) are treated as background, but pixels with different value are
             treated as circles' pixels.</para>
             
             <para>Sample usage:</para>
             <code>
             HoughCircleTransformation circleTransform = new HoughCircleTransformation( 35 );
             // apply Hough circle transform
             circleTransform.ProcessImage( sourceImage );
             Bitmap houghCirlceImage = circleTransform.ToBitmap( );
             // get circles using relative intensity
             HoughCircle[] circles = circleTransform.GetCirclesByRelativeIntensity( 0.5 );
             
             foreach ( HoughCircle circle in circles )
             {
                 // ...
             }
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample8.jpg" width="400" height="300"/>
             <para><b>Hough circle transformation image:</b></para>
             <img src="img/imaging/hough_circles.jpg" width="400" height="300"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.HoughLineTransformation"/>
             
        </member>
        <member name="M:AForge.Imaging.HoughCircleTransformation.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.HoughCircleTransformation"/> class.
            </summary>
            
            <param name="radiusToDetect">Circles' radius to detect.</param>
            
        </member>
        <member name="M:AForge.Imaging.HoughCircleTransformation.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source image to process.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HoughCircleTransformation.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HoughCircleTransformation.ProcessImage(AForge.Imaging.UnmanagedImage)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source unmanaged image to process.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HoughCircleTransformation.ToBitmap">
            <summary>
            Сonvert Hough map to bitmap. 
            </summary>
            
            <returns>Returns 8 bppp grayscale bitmap, which shows Hough map.</returns>
            
            <exception cref="T:System.ApplicationException">Hough transformation was not yet done by calling
            ProcessImage() method.</exception>
            
        </member>
        <member name="M:AForge.Imaging.HoughCircleTransformation.GetMostIntensiveCircles(System.Int32)">
            <summary>
            Get specified amount of circles with highest intensity.
            </summary>
            
            <param name="count">Amount of circles to get.</param>
            
            <returns>Returns arrary of most intesive circles. If there are no circles detected,
            the returned array has zero length.</returns>
            
        </member>
        <member name="M:AForge.Imaging.HoughCircleTransformation.GetCirclesByRelativeIntensity(System.Double)">
            <summary>
            Get circles with relative intensity higher then specified value.
            </summary>
            
            <param name="minRelativeIntensity">Minimum relative intesity of circles.</param>
            
            <returns>Returns arrary of most intesive circles. If there are no circles detected,
            the returned array has zero length.</returns>
            
        </member>
        <member name="P:AForge.Imaging.HoughCircleTransformation.MinCircleIntensity">
             <summary>
             Minimum circle's intensity in Hough map to recognize a circle.
             </summary>
            
             <remarks><para>The value sets minimum intensity level for a circle. If a value in Hough
             map has lower intensity, then it is not treated as a circle.</para>
             
             <para>Default value is set to <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.HoughCircleTransformation.LocalPeakRadius">
            <summary>
            Radius for searching local peak value.
            </summary>
            
            <remarks><para>The value determines radius around a map's value, which is analyzed to determine
            if the map's value is a local maximum in specified area.</para>
            
            <para>Default value is set to <b>4</b>. Minimum value is <b>1</b>. Maximum value is <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.HoughCircleTransformation.MaxIntensity">
            <summary>
            Maximum found intensity in Hough map.
            </summary>
            
            <remarks><para>The property provides maximum found circle's intensity.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.HoughCircleTransformation.CirclesCount">
            <summary>
            Found circles count.
            </summary>
            
            <remarks><para>The property provides total number of found circles, which intensity is higher (or equal to),
            than the requested <see cref="P:AForge.Imaging.HoughCircleTransformation.MinCircleIntensity">minimum intensity</see>.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.QuadrilateralTransformationBilinear">
            <summary>
            Performs quadrilateral transformation using bilinear algorithm for interpolation.
            </summary>
            
            <remarks><para>The class is deprecated and <see cref="T:AForge.Imaging.Filters.SimpleQuadrilateralTransformation"/> should be used instead.</para>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.SimpleQuadrilateralTransformation"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.#ctor(System.Collections.Generic.List{AForge.IntPoint},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.QuadrilateralTransformationBilinear"/> class.
            </summary>
            
            <param name="sourceCorners">Corners of the source quadrilateral area.</param>
            <param name="newWidth">Width of the new transformed image.</param>
            <param name="newHeight">Height of the new transformed image.</param>
            
            <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.AutomaticSizeCalculaton"/> to
            <see langword="false"/>, which means that destination image will have width and
            height as specified by user.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.#ctor(System.Collections.Generic.List{AForge.IntPoint})">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.QuadrilateralTransformationBilinear"/> class.
             </summary>
             
             <param name="sourceCorners">Corners of the source quadrilateral area.</param>
             
             <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.AutomaticSizeCalculaton"/> to
             <see langword="true"/>, which means that destination image will have width and
             height automatically calculated based on <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.SourceCorners"/> property.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.CalculateNewImageSize(AForge.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
            <exception cref="T:System.ArgumentException">The specified quadrilateral's corners are outside of the given image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.AutomaticSizeCalculaton">
            <summary>
            Automatic calculation of destination image or not.
            </summary>
            
            <remarks><para>The property specifies how to calculate size of destination (transformed)
            image. If the property is set to <see langword="false"/>, then <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.NewWidth"/>
            and <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.NewHeight"/> properties have effect and destination image's size is
            specified by user. If the property is set to <see langword="true"/>, then setting the above
            mentioned properties does not have any effect, but destionation image's size is
            automatically calculated from <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.SourceCorners"/> property - width and height
            come from length of longest edges.
            </para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.SourceCorners">
            <summary>
            Quadrilateral's corners in source image.
            </summary>
            
            <remarks><para>The property specifies four corners of the quadrilateral area
            in the source image to be transformed.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.NewWidth">
            <summary>
            Width of the new transformed image.
            </summary>
            
            <remarks><para>The property defines width of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's width
            is calculated automatically based on <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.SourceCorners"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.NewHeight">
            <summary>
            Height of the new transformed image.
            </summary>
            
            <remarks><para>The property defines height of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's height
            is calculated automatically based on <see cref="P:AForge.Imaging.Filters.QuadrilateralTransformationBilinear.SourceCorners"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BackwardQuadrilateralTransformation">
            <summary>
            Performs backward quadrilateral transformation into an area in destination image.
            </summary>
            
            <remarks><para>The class implements backward quadrilateral transformation algorithm,
            which allows to transform any rectangular image into any quadrilateral area
            in a given destination image. The idea of the algorithm is based on homogeneous
            transformation and its math is described by Paul Heckbert in his
            "<a href="http://graphics.cs.cmu.edu/courses/15-463/2008_fall/Papers/proj.pdf">Projective Mappings for Image Warping</a>" paper.
            </para>
            
            <para>The image processing routines implements similar math to <see cref="T:AForge.Imaging.Filters.QuadrilateralTransformation"/>,
            but performs it in backward direction.</para>
            
            <para>The image processing filter accepts 8 grayscale images and 24/32 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // define quadrilateral's corners
            List&lt;IntPoint&gt; corners = new List&lt;IntPoint&gt;( );
            corners.Add( new IntPoint(  99,  99 ) );
            corners.Add( new IntPoint( 156,  79 ) );
            corners.Add( new IntPoint( 184, 126 ) );
            corners.Add( new IntPoint( 122, 150 ) );
            // create filter
            BackwardQuadrilateralTransformation filter =
                new BackwardQuadrilateralTransformation( sourceImage, corners );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="img/imaging/icon.png" width="128" height="128"/>
            <para><b>Destination image:</b></para>
            <img src="img/imaging/sample18.jpg" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/backward_quadrilateral.jpg" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.QuadrilateralTransformation"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BackwardQuadrilateralTransformation"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BackwardQuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceImage">Source image to be transformed into specified quadrilateral
            (see <see cref="P:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.SourceImage"/>).</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BackwardQuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceUnmanagedImage">Source unmanaged image to be transformed into specified quadrilateral
            (see <see cref="P:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.SourceUnmanagedImage"/>).</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.#ctor(System.Drawing.Bitmap,System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BackwardQuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceImage">Source image to be transformed into specified quadrilateral
            (see <see cref="P:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.SourceImage"/>).</param>
            <param name="destinationQuadrilateral">Quadrilateral in destination image to transform into.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.#ctor(AForge.Imaging.UnmanagedImage,System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BackwardQuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceUnmanagedImage">Source unmanaged image to be transformed into specified quadrilateral
            (see <see cref="P:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.SourceUnmanagedImage"/>).</param>
            <param name="destinationQuadrilateral">Quadrilateral in destination image to transform into.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Image data to process by the filter.</param>
            
             <exception cref="T:System.NullReferenceException">Destination quadrilateral was not set.</exception>
             
        </member>
        <member name="P:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
             documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.SourceImage">
             <summary>
             Source image to be transformed into specified quadrilateral.
             </summary>
             
             <remarks><para>The property sets the source image, which will be transformed
             to the specified quadrilateral and put into destination image the filter is applied to.</para>
             
             <para><note>The source image must have the same pixel format as a destination image the filter
             is applied to. Otherwise exception will be generated when filter is applied.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.SourceUnmanagedImage"/> property -
             only one source image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.SourceUnmanagedImage">
             <summary>
             Source unmanaged image to be transformed into specified quadrilateral.
             </summary>
             
             <remarks><para>The property sets the source image, which will be transformed
             to the specified quadrilateral and put into destination image the filter is applied to.</para>
             
             <para><note>The source image must have the same pixel format as a destination image the filter
             is applied to. Otherwise exception will be generated when filter is applied.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.SourceImage"/> property -
             only one source image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.DestinationQuadrilateral">
             <summary>
             Quadrilateral in destination image to transform into.
             </summary>
             
             <remarks><para>The property specifies 4 corners of a quadrilateral area
             in destination image where the source image will be transformed into.
             </para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BackwardQuadrilateralTransformation.UseInterpolation">
            <summary>
            Specifies if bilinear interpolation should be used or not.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/> - interpolation
            is used.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ImageWarp">
             <summary>
             Image warp effect filter.
             </summary>
             
             <remarks><para>The image processing filter implements a warping filter, which
             sets pixels in destination image to values from source image taken with specified offset
             (see <see cref="P:AForge.Imaging.Filters.ImageWarp.WarpMap"/>).
             </para>
             
             <para>The filter accepts 8 bpp grayscale images and 24/32
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // build warp map
             int width  = image.Width;
             int height = image.Height;
             
             IntPoint[,] warpMap = new IntPoint[height, width];
            
             int size = 8;
             int maxOffset = -size + 1;
            
             for ( int y = 0; y &lt; height; y++ )
             {
                 for ( int x = 0; x &lt; width; x++ )
                 {
                     int dx = ( x / size ) * size - x;
                     int dy = ( y / size ) * size - y;
            
                     if ( dx + dy &lt;= maxOffset )
                     {
                         dx = ( x / size + 1 ) * size - 1 - x;
                     }
            
                     warpMap[y, x] = new IntPoint( dx, dy );
                 }
             }
             // create filter
             ImageWarp filter = new ImageWarp( warpMap );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/image_warp.png" width="480" height="361"/>
             </remarks>
             
        </member>
        <member name="M:AForge.Imaging.Filters.ImageWarp.#ctor(AForge.IntPoint[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ImageWarp"/> class.
            </summary>
            
            <param name="warpMap">Map used for warping images (see <see cref="P:AForge.Imaging.Filters.ImageWarp.WarpMap"/>).</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ImageWarp.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ImageWarp.WarpMap">
            <summary>
            Map used for warping images.
            </summary>
            
            <remarks><para>The property sets displacement map used for warping images.
            The map sets offsets of pixels in source image, which are used to set values in destination
            image. In other words, each pixel in destination image is set to the same value
            as pixel in source image with corresponding offset (coordinates of pixel in source image
            are calculated as sum of destination coordinate and corresponding value from warp map).
            </para>
            
            <para><note>The map array is accessed using [y, x] indexing, i.e.
            first dimension in the map array corresponds to Y axis of image.</note></para>
            
            <para><note>If the map is smaller or bigger than the image to process, then only minimum
            overlapping area of the image is processed. This allows to prepare single big map and reuse
            it for a set of images for creating similar effects.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ImageWarp.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.HorizontalRunLengthSmoothing">
             <summary>
             Horizontal run length smoothing algorithm.
             </summary>
             
             <remarks><para>The class implements horizontal run length smoothing algorithm, which
             is described in: <b>K.Y. Wong, R.G. Casey and F.M. Wahl, "Document analysis system,"
             IBM J. Res. Devel., Vol. 26, NO. 6,111). 647-656, 1982.</b></para>
             
             <para>Unlike the original description of this algorithm, this implementation must be applied
             to inverted binary images containing document, i.e. white text on black background. So this
             implementation fills horizontal black gaps between white pixels.</para>
             
             <para><note>This algorithm is usually used together with <see cref="T:AForge.Imaging.Filters.VerticalRunLengthSmoothing"/>,
             <see cref="T:AForge.Imaging.Filters.Intersect"/> and then further analysis of white blobs.</note></para>
             
             <para>The filter accepts 8 bpp grayscale images, which are supposed to be binary inverted documents.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             HorizontalRunLengthSmoothing hrls = new HorizontalRunLengthSmoothing( 32 );
             // apply the filter
             hrls.ApplyInPlace( image );
             </code>
            
             <para><b>Source image:</b></para>
             <img src="img/imaging/sample24.png" width="480" height="320"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/hrls.png" width="480" height="320"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.VerticalRunLengthSmoothing"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.HorizontalRunLengthSmoothing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.HorizontalRunLengthSmoothing"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HorizontalRunLengthSmoothing.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.HorizontalRunLengthSmoothing"/> class.
            </summary>
            
            <param name="maxGapSize">Maximum gap size to fill (see <see cref="P:AForge.Imaging.Filters.HorizontalRunLengthSmoothing.MaxGapSize"/>).</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HorizontalRunLengthSmoothing.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HorizontalRunLengthSmoothing.MaxGapSize">
             <summary>
             Maximum gap size to fill (in pixels).
             </summary>
             
             <remarks><para>The property specifies maximum horizontal gap between white pixels to fill.
             If number of black pixels between some white pixels is bigger than this value, then those
             black pixels are left as is; otherwise the gap is filled with white pixels.
             </para>
             
             <para>Default value is set to <b>10</b>. Minimum value is 1. Maximum value is 1000.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HorizontalRunLengthSmoothing.ProcessGapsWithImageBorders">
            <summary>
            Process gaps between objects and image borders or not.
            </summary>
            
            <remarks><para>The property sets if gaps between image borders and objects must be treated as
            gaps between objects and also filled.</para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HorizontalRunLengthSmoothing.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ExtractBiggestBlob">
            <summary>
            Extract the biggest blob from image.
            </summary>
            
            <remarks><para>The filter locates the biggest blob in the source image and extracts it.
            The filter also can use the source image for the biggest blob's location only, but extract it from
            another image, which is set using <see cref="P:AForge.Imaging.Filters.ExtractBiggestBlob.OriginalImage"/> property. The original image 
            usually is the source of the processed image.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32 color images for processing as source image passed to
            <see cref="M:AForge.Imaging.Filters.ExtractBiggestBlob.Apply(System.Drawing.Bitmap)"/> method and also for the <see cref="P:AForge.Imaging.Filters.ExtractBiggestBlob.OriginalImage"/>.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ExtractBiggestBlob filter = new ExtractBiggestBlob( );
            // apply the filter
            Bitmap biggestBlobsImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample2.jpg" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/biggest_blob.jpg" width="141" height="226"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ExtractBiggestBlob.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to get biggest blob from.</param>
             
             <returns>Returns image of the biggest blob.</returns>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the original image.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Source and original images must have the same size.</exception>
             <exception cref="T:System.ArgumentException">The source image does not contain any blobs.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ExtractBiggestBlob.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to get biggest blob from.</param>
             
             <returns>Returns image of the biggest blob.</returns>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the original image.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Source and original images must have the same size.</exception>
             <exception cref="T:System.ArgumentException">The source image does not contain any blobs.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ExtractBiggestBlob.Apply(AForge.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image (not implemented).
            </summary>
            
            <param name="image">Image in unmanaged memory.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <exception cref="T:System.NotImplementedException">The method is not implemented.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ExtractBiggestBlob.Apply(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image (not implemented).
            </summary>
            
            <param name="sourceImage">Source image to be processed.</param>
            <param name="destinationImage">Destination image to store filter's result.</param>
            
            <exception cref="T:System.NotImplementedException">The method is not implemented.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ExtractBiggestBlob.BlobPosition">
            <summary>
            Position of the extracted blob.
            </summary>
            
            <remarks><para>After applying the filter this property keeps position of the extracted
            blob in the source image.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ExtractBiggestBlob.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ExtractBiggestBlob.OriginalImage">
            <summary>
            Original image, which is the source of the processed image where the biggest blob is searched for.
            </summary>
            
            <remarks><para>The property may be set to <see langword="null"/>. In this case the biggest blob
            is extracted from the image, which is passed to <see cref="M:AForge.Imaging.Filters.ExtractBiggestBlob.Apply(System.Drawing.Bitmap)"/> image.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Dilatation3x3">
            <summary>
            Dilatation operator from Mathematical Morphology with 3x3 structuring element.
            </summary>
            
            <remarks><para>The filter represents an optimized version of <see cref="T:AForge.Imaging.Filters.Dilatation"/>
            filter, which is aimed for grayscale image processing with 3x3 structuring element.</para>
            
            <para>See <see cref="T:AForge.Imaging.Filters.Dilatation"/> filter, which represents generic version of
            dilatation filter supporting custom structuring elements and wider range of image formats.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Dilatation"/>
            <seealso cref="T:AForge.Imaging.Filters.BinaryDilatation3x3"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Dilatation3x3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Dilatation3x3"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Dilatation3x3.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Processing rectangle mast be at least 3x3 in size.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Dilatation3x3.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.GrayscaleBT709">
             <summary>
             Grayscale image using BT709 algorithm.
             </summary>
             
             <remarks>The class uses <b>BT709</b> algorithm to convert color image
             to grayscale. The conversion coefficients are:
             <list type="bullet">
             <item>Red: 0.2125;</item>
             <item>Green: 0.7154;</item>
             <item>Blue: 0.0721.</item>
             </list>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.Grayscale"/>
             <seealso cref="T:AForge.Imaging.Filters.GrayscaleRMY"/>
             <seealso cref="T:AForge.Imaging.Filters.GrayscaleY"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GrayscaleBT709.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GrayscaleBT709"/> class.
            </summary>
        </member>
        <member name="T:AForge.Imaging.ObjectsOrder">
            <summary>
            Possible object orders.
            </summary>
            
            <remarks>The enumeration defines possible sorting orders of objects, found by blob
            counting classes.</remarks>
            
        </member>
        <member name="F:AForge.Imaging.ObjectsOrder.None">
            <summary>
            Unsorted order (as it is collected by algorithm).
            </summary>
        </member>
        <member name="F:AForge.Imaging.ObjectsOrder.Size">
            <summary>
            Objects are sorted by size in descending order (bigger objects go first).
            Size is calculated as <b>Width * Height</b>.
            </summary>
        </member>
        <member name="F:AForge.Imaging.ObjectsOrder.Area">
            <summary>
            Objects are sorted by area in descending order (bigger objects go first).
            </summary>
        </member>
        <member name="F:AForge.Imaging.ObjectsOrder.YX">
            <summary>
            Objects are sorted by Y coordinate, then by X coordinate in ascending order
            (smaller coordinates go first).
            </summary>
        </member>
        <member name="F:AForge.Imaging.ObjectsOrder.XY">
            <summary>
            Objects are sorted by X coordinate, then by Y coordinate in ascending order
            (smaller coordinates go first).
            </summary>
        </member>
        <member name="T:AForge.Imaging.BlobCounter">
            <summary>
            Blob counter - counts objects in image, which are separated by black background.
            </summary>
            
            <remarks><para>The class counts and extracts stand alone objects in
            images using connected components labeling algorithm.</para>
            
            <para><note>The algorithm treats all pixels with values less or equal to <see cref="P:AForge.Imaging.BlobCounter.BackgroundThreshold"/>
            as background, but pixels with higher values are treated as objects' pixels.</note></para>
            
            <para>For blobs' searching the class supports 8 bpp indexed grayscale images and
            24/32 bpp color images that are at least two pixels wide. Images that are one
            pixel wide can be processed if they are rotated first, or they can be processed
            with <see cref="T:AForge.Imaging.RecursiveBlobCounter"/>.
            See documentation about <see cref="T:AForge.Imaging.BlobCounterBase"/> for information about which
            pixel formats are supported for extraction of blobs.</para>
            
            <para>Sample usage:</para>
            <code>
            // create an instance of blob counter algorithm
            BlobCounter bc = new BlobCounter( );
            // process binary image
            bc.ProcessImage( image );
            Rectangle[] rects = bc.GetObjectsRectangles( );
            // process blobs
            foreach ( Rectangle rect in rects )
            {
                // ...
            }
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.BlobCounter"/> class.
            </summary>
            
            <remarks>Creates new instance of the <see cref="T:AForge.Imaging.BlobCounter"/> class with
            an empty objects map. Before using methods, which provide information about blobs
            or extract them, the <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>,
            <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> or <see cref="M:AForge.Imaging.BlobCounterBase.ProcessImage(AForge.Imaging.UnmanagedImage)"/>
            method should be called to collect objects map.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounter.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.BlobCounter"/> class.
            </summary>
            
            <param name="image">Image to look for objects in.</param>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounter.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.BlobCounter"/> class.
            </summary>
            
            <param name="imageData">Image data to look for objects in.</param>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounter.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.BlobCounter"/> class.
            </summary>
            
            <param name="image">Unmanaged image to look for objects in.</param>
            
        </member>
        <member name="M:AForge.Imaging.BlobCounter.BuildObjectsMap(AForge.Imaging.UnmanagedImage)">
            <summary>
            Actual objects map building.
            </summary>
            
            <param name="image">Unmanaged image to process.</param>
            
            <remarks>The method supports 8 bpp indexed grayscale images and 24/32 bpp color images.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Cannot process images that are one pixel wide. Rotate the image
            or use <see cref="T:AForge.Imaging.RecursiveBlobCounter"/>.</exception>
            
        </member>
        <member name="P:AForge.Imaging.BlobCounter.BackgroundThreshold">
             <summary>
             Background threshold's value.
             </summary>
             
             <remarks><para>The property sets threshold value for distinguishing between background
             pixel and objects' pixels. All pixel with values less or equal to this property are
             treated as background, but pixels with higher values are treated as objects' pixels.</para>
             
             <para><note>In the case of colour images a pixel is treated as objects' pixel if <b>any</b> of its
             RGB values are higher than corresponding values of this threshold.</note></para>
             
             <para><note>For processing grayscale image, set the property with all RGB components eqaul.</note></para>
            
             <para>Default value is set to <b>(0, 0, 0)</b> - black colour.</para></remarks>
             
        </member>
        <member name="T:AForge.Imaging.ImageStatisticsYCbCr">
            <summary>
            Gather statistics about image in YCbCr color space.
            </summary>
            
            <remarks><para>The class is used to accumulate statistical values about images,
            like histogram, mean, standard deviation, etc. for each <b>YCbCr</b> color channel.</para>
            
            <para>The class accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // gather statistics
            ImageStatisticsYCbCr stat = new ImageStatisticsYCbCr( image );
            // get Y channel's histogram
            ContinuousHistogram y = stat.Y;
            // check mean value of Y channel
            if ( y.Mean &gt; 0.5 )
            {
                // do further processing
            }
            </code>
            </remarks>
            
            <seealso cref="T:AForge.Math.ContinuousHistogram"/>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsYCbCr.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsYCbCr.#ctor(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsYCbCr.#ctor(System.Drawing.Bitmap,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsYCbCr.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Unmanaged image to gather statistics about.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsYCbCr.#ctor(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ImageStatisticsYCbCr.#ctor(AForge.Imaging.UnmanagedImage,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsYCbCr.Y">
            <summary>
            Histogram of Y channel.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsYCbCr.Cb">
            <summary>
            Histogram of Cb channel.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsYCbCr.Cr">
            <summary>
            Histogram of Cr channel.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsYCbCr.YWithoutBlack">
            <summary>
            Histogram of Y channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about Y channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsYCbCr.CbWithoutBlack">
            <summary>
            Histogram of Cb channel excluding black pixels
            </summary>
            
            <remarks><para>The property keeps statistics about Cb channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsYCbCr.CrWithoutBlack">
            <summary>
            Histogram of Cr channel excluding black pixels
            </summary>
            
            <remarks><para>The property keeps statistics about Cr channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsYCbCr.PixelsCount">
            <summary>
            Total pixels count in the processed image.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ImageStatisticsYCbCr.PixelsCountWithoutBlack">
            <summary>
            Total pixels count in the processed image excluding black pixels.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Filters.YCbCrFiltering">
            <summary>
            Color filtering in YCbCr color space.
            </summary>
            
            <remarks><para>The filter operates in <b>YCbCr</b> color space and filters
            pixels, which color is inside/outside of the specified YCbCr range - 
            it keeps pixels with colors inside/outside of the specified range and fills the
            rest with <see cref="P:AForge.Imaging.Filters.YCbCrFiltering.FillColor">specified color</see>.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            YCbCrFiltering filter = new YCbCrFiltering( );
            // set color ranges to keep
            filter.Cb = new Range( -0.2f, 0.0f );
            filter.Cr = new Range( 0.26f, 0.5f );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/ycbcr_filtering.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.ColorFiltering"/>
            <seealso cref="T:AForge.Imaging.Filters.HSLFiltering"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.YCbCrFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.YCbCrFiltering"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.YCbCrFiltering.#ctor(AForge.Range,AForge.Range,AForge.Range)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.YCbCrFiltering"/> class.
            </summary>
            
            <param name="yRange">Range of Y component.</param>
            <param name="cbRange">Range of Cb component.</param>
            <param name="crRange">Range of Cr component.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.YCbCrFiltering.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrFiltering.Y">
            <summary>
            Range of Y component, [0, 1].
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrFiltering.Cb">
            <summary>
            Range of Cb component, [-0.5, 0.5].
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrFiltering.Cr">
            <summary>
            Range of Cr component, [-0.5, 0.5].
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrFiltering.FillColor">
            <summary>
            Fill color used to fill filtered pixels.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrFiltering.FillOutsideRange">
            <summary>
            Determines, if pixels should be filled inside or outside specified
            color range.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/>, which means
            the filter removes colors outside of the specified range.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrFiltering.UpdateY">
            <summary>
            Determines, if Y value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if Y channel of filtered pixels should be
            updated with value from <see cref="P:AForge.Imaging.Filters.YCbCrFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrFiltering.UpdateCb">
            <summary>
            Determines, if Cb value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if Cb channel of filtered pixels should be
            updated with value from <see cref="P:AForge.Imaging.Filters.YCbCrFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.YCbCrFiltering.UpdateCr">
            <summary>
            Determines, if Cr value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if Cr channel of filtered pixels should be
            updated with value from <see cref="P:AForge.Imaging.Filters.YCbCrFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BilateralSmoothing">
             <summary>
             Bilateral filter implementation - edge preserving smoothing and noise reduction that uses chromatic and spatial factors.
             </summary>
             
             <remarks>
             <para>Bilateral filter conducts "selective" Gaussian smoothing of areas of same color (domains) which removes noise and contrast artifacts
             while preserving sharp edges.</para>
             
             <para>Two major parameters <see cref="P:AForge.Imaging.Filters.BilateralSmoothing.SpatialFactor"/> and <see cref="P:AForge.Imaging.Filters.BilateralSmoothing.ColorFactor"/> define the result of the filter. 
             By changing these parameters you may achieve either only noise reduction with little change to the
             image or get nice looking effect to the entire image.</para>
            
             <para>Although the filter can use parallel processing large <see cref="P:AForge.Imaging.Filters.BilateralSmoothing.KernelSize"/> values
             (greater than 25) on high resolution images may decrease speed of processing. Also on high
             resolution images small <see cref="P:AForge.Imaging.Filters.BilateralSmoothing.KernelSize"/> values (less than 9) may not provide noticeable
             results.</para>
             
             <para>More details on the algorithm can be found by following this
             <a href="http://saplin.blogspot.com/2012/01/bilateral-image-filter-edge-preserving.html">link</a>.</para>
             
             <para>The filter accepts 8 bpp grayscale images and 24/32 bpp color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             BilateralSmoothing filter = new BilateralSmoothing( );
             filter.KernelSize    = 7;
             filter.SpatialFactor = 10;
             filter.ColorFactor   = 60;
             filter.ColorPower    = 0.5;
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample13.png" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/bilateral.jpg" width="480" height="361"/>
             </remarks>
             
        </member>
        <member name="M:AForge.Imaging.Filters.BilateralSmoothing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BilateralSmoothing"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BilateralSmoothing.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BilateralSmoothing.LimitKernelSize">
            <summary>
            Specifies if exception must be thrown in the case a large
            <see cref="P:AForge.Imaging.Filters.BilateralSmoothing.KernelSize">kernel size</see> is used which may lead
            to significant performance issues.
            </summary>
            
            <remarks>
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BilateralSmoothing.EnableParallelProcessing">
            <summary>
            Enable or not parallel processing on multi-core CPUs.
            </summary>
            
            <remarks><para>If the property is set to <see langword="true"/>, then this image processing
            routine will run in parallel on the systems with multiple core/CPUs. The <see cref="M:AForge.Parallel.For(System.Int32,System.Int32,AForge.Parallel.ForLoopBody)"/>
            is used to make it parallel.</para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BilateralSmoothing.KernelSize">
            <summary>
            Size of a square for limiting surrounding pixels that take part in calculations, [3, 255].
            </summary>
            
            <remarks><para>The greater the value the more is the general power of the filter. Small values
            (less than 9) on high resolution images (3000 pixels wide) do not give significant results.
            Large values increase the number of calculations and degrade performance.</para>
            
            <para><note>The value of this property must be an odd integer in the [3, 255] range if
            <see cref="P:AForge.Imaging.Filters.BilateralSmoothing.LimitKernelSize"/> is set to <see langword="false"/> or in the [3, 25] range
            otherwise.</note></para>
            
            <para>Default value is set to <b>9</b>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentOutOfRangeException">The specified value is out of range (see
            eception message for details).</exception>
            <exception cref="T:System.ArgumentException">The value of this must be an odd integer.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BilateralSmoothing.SpatialFactor">
            <summary>
            Determines smoothing power within a color domain (neighbor pixels of similar color), >= 1.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>10</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BilateralSmoothing.SpatialPower">
            <summary>
            Exponent power, used in Spatial function calculation, >= 1.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>2</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BilateralSmoothing.ColorFactor">
            <summary>
            Determines the variance of color for a color domain, >= 1.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>50</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BilateralSmoothing.ColorPower">
            <summary>
            Exponent power, used in Color function calculation, >= 1.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>2</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BilateralSmoothing.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
             documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Opening">
             <summary>
             Opening operator from Mathematical Morphology.
             </summary>
             
             <remarks><para>Opening morphology operator equals to <see cref="T:AForge.Imaging.Filters.Erosion">erosion</see> followed
             by <see cref="T:AForge.Imaging.Filters.Dilatation">dilatation</see>.</para>
             
             <para>Applied to binary image, the filter may be used for removing small object keeping big objects
             unchanged. Since erosion is used first, it removes all small objects. Then dilatation restores big
             objects, which were not removed by erosion.</para>
             
             <para>See documentation to <see cref="T:AForge.Imaging.Filters.Erosion"/> and <see cref="T:AForge.Imaging.Filters.Dilatation"/> classes for more
             information and list of supported pixel formats.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Opening filter = new Opening( );
             // apply the filter
             filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample12.png" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/opening.png" width="320" height="240"/>
             </remarks>
            
             <seealso cref="T:AForge.Imaging.Filters.Erosion"/>
             <seealso cref="T:AForge.Imaging.Filters.Dilatation"/>
             <seealso cref="T:AForge.Imaging.Filters.Closing"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Opening"/> class.
            </summary>
            
            <remarks><para>Initializes new instance of the <see cref="T:AForge.Imaging.Filters.Opening"/> class using
            default structuring element for both <see cref="T:AForge.Imaging.Filters.Erosion"/> and <see cref="T:AForge.Imaging.Filters.Dilatation"/>
            classes - 3x3 structuring element with all elements equal to 1.
            </para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Opening"/> class.
            </summary>
            
            <param name="se">Structuring element.</param>
            
            <remarks><para>See documentation to <see cref="T:AForge.Imaging.Filters.Erosion"/> and <see cref="T:AForge.Imaging.Filters.Dilatation"/>
            classes for information about structuring element constraints.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.Apply(System.Drawing.Imaging.BitmapData)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="imageData">Source image to apply filter to.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The filter accepts bitmap data as input and returns the result
            of image processing filter as new image. The source image data are kept
            unchanged.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.Apply(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.Apply(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:AForge.Imaging.Filters.Opening.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.ApplyInPlace(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an unmanaged image.
             </summary>
             
             <param name="image">Unmanaged image to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source unmanaged image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.ApplyInPlace(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.ApplyInPlace(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
             <summary>
             Apply filter to an image or its part.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Opening.ApplyInPlace(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an unmanaged image or its part.
            </summary>
            
            <param name="image">Unmanaged image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Opening.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.Dilatation">
            <summary>
            Dilatation operator from Mathematical Morphology.
            </summary>
            
            <remarks><para>The filter assigns maximum value of surrounding pixels to each pixel of
            the result image. Surrounding pixels, which should be processed, are specified by
            structuring element: 1 - to process the neighbor, -1 - to skip it.</para>
            
            <para>The filter especially useful for binary image processing, where it allows to grow
            separate objects or join objects.</para>
            
            <para>For processing image with 3x3 structuring element, there are different optimizations
            available, like <see cref="T:AForge.Imaging.Filters.Dilatation3x3"/> and <see cref="T:AForge.Imaging.Filters.BinaryDilatation3x3"/>.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24 and 48 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Dilatation filter = new Dilatation( );
            // apply the filter
            filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample12.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/dilatation.png" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Erosion"/>
            <seealso cref="T:AForge.Imaging.Filters.Closing"/>
            <seealso cref="T:AForge.Imaging.Filters.Opening"/>
            <seealso cref="T:AForge.Imaging.Filters.Dilatation3x3"/>
            <seealso cref="T:AForge.Imaging.Filters.BinaryDilatation3x3"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Dilatation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Dilatation"/> class.
            </summary>
            
            <remarks><para>Initializes new instance of the <see cref="T:AForge.Imaging.Filters.Dilatation"/> class using
            default structuring element - 3x3 structuring element with all elements equal to 1.
            </para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Dilatation.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Dilatation"/> class.
            </summary>
            
            <param name="se">Structuring element.</param>
            
            <remarks><para>Structuring elemement for the dilatation morphological operator
            must be square matrix with odd size in the range of [3, 99].</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid size of structuring element.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Dilatation.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Dilatation.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.FiltersSequence">
            <summary>
            Filters' collection to apply to an image in sequence.
            </summary>
            
            <remarks><para>The class represents collection of filters, which need to be applied
            to an image in sequence. Using the class user may specify set of filters, which will
            be applied to source image one by one in the order user defines them.</para>
            
            <para>The class itself does not define which pixel formats are accepted for the source
            image and which pixel formats may be produced by the filter. Format of acceptable source
            and possible output is defined by filters, which added to the sequence.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter, which is binarization sequence
            FiltersSequence filter = new FiltersSequence(
                new GrayscaleBT709( ),
                new Threshold( )
            );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FiltersSequence.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.FiltersSequence"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FiltersSequence.#ctor(AForge.Imaging.Filters.IFilter[])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.FiltersSequence"/> class.
            </summary>
            
            <param name="filters">Sequence of filters to apply.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FiltersSequence.Add(AForge.Imaging.Filters.IFilter)">
            <summary>
            Add new filter to the sequence.
            </summary>
            
            <param name="filter">Filter to add to the sequence.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FiltersSequence.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:System.ApplicationException">No filters were added into the filters' sequence.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FiltersSequence.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:System.ApplicationException">No filters were added into the filters' sequence.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FiltersSequence.Apply(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:System.ApplicationException">No filters were added into the filters' sequence.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.FiltersSequence.Apply(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have width, height and pixel format as it is expected by
             the final filter in the sequence.</note></para>
             </remarks>
             
             <exception cref="T:System.ApplicationException">No filters were added into the filters' sequence.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.FiltersSequence.Item(System.Int32)">
            <summary>
            Get filter at the specified index.
            </summary>
            
            <param name="index">Index of filter to get.</param>
            
            <returns>Returns filter at specified index.</returns>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ContrastCorrection">
             <summary>
             Contrast adjusting in RGB color space.
             </summary>
             
             <remarks><para>The filter operates in <b>RGB</b> color space and adjusts
             pixels' contrast value by increasing RGB values of bright pixel and decreasing
             RGB values of dark pixels (or vise versa if contrast needs to be decreased).
             The filter is based on <see cref="T:AForge.Imaging.Filters.LevelsLinear"/>
             filter and simply sets all input ranges to (<see cref="P:AForge.Imaging.Filters.ContrastCorrection.Factor"/>, 255-<see cref="P:AForge.Imaging.Filters.ContrastCorrection.Factor"/>) and
             all output range to (0, 255) in the case if the factor value is positive.
             If the factor value is negative, then all input ranges are set to
             (0, 255 ) and all output ranges are set to
             (-<see cref="P:AForge.Imaging.Filters.ContrastCorrection.Factor"/>, 255_<see cref="P:AForge.Imaging.Filters.ContrastCorrection.Factor"/>).</para>
             
             <para>See <see cref="T:AForge.Imaging.Filters.LevelsLinear"/> documentation forr more information about the base filter.</para>
             
             <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter
             ContrastCorrection filter = new ContrastCorrection( 15 );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/contrast_correction.jpg" width="480" height="361"/>
             </remarks>
            
             <seealso cref="T:AForge.Imaging.Filters.LevelsLinear"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.ContrastCorrection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ContrastCorrection"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ContrastCorrection.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ContrastCorrection"/> class.
            </summary>
            
            <param name="factor">Contrast <see cref="P:AForge.Imaging.Filters.ContrastCorrection.Factor">adjusting factor</see>.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ContrastCorrection.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ContrastCorrection.Factor">
            <summary>
            Contrast adjusting factor, [-127, 127].
            </summary>
            
            <remarks><para>Factor which is used to adjust contrast. Factor values greater than
            0 increase contrast making light areas lighter and dark areas darker. Factor values
            less than 0 decrease contrast - decreasing variety of contrast.</para>
            
            <para>Default value is set to <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ContrastCorrection.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
             documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Textures.MarbleTexture">
             <summary>
             Marble texture.
             </summary>
             
             <remarks><para>The texture generator creates textures with effect of marble.
             The <see cref="P:AForge.Imaging.Textures.MarbleTexture.XPeriod"/> and <see cref="P:AForge.Imaging.Textures.MarbleTexture.YPeriod"/> properties allow to control the look
             of marble texture in X/Y directions.</para>
             
             <para>The generator is based on the <see cref="T:AForge.Math.PerlinNoise">Perlin noise function</see>.</para>
             
             <para>Sample usage:</para>
             <code>
             // create texture generator
             MarbleTexture textureGenerator = new MarbleTexture( );
             // generate new texture
             float[,] texture = textureGenerator.Generate( 320, 240 );
             // convert it to image to visualize
             Bitmap textureImage = TextureTools.ToBitmap( texture );
             </code>
            
             <para><b>Result image:</b></para>
             <img src="img/imaging/marble_texture.jpg" width="320" height="240"/>
             </remarks>
             
        </member>
        <member name="M:AForge.Imaging.Textures.MarbleTexture.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Textures.MarbleTexture"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Textures.MarbleTexture.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Textures.MarbleTexture"/> class.
            </summary>
            
            <param name="xPeriod">X period value.</param>
            <param name="yPeriod">Y period value.</param>
            
        </member>
        <member name="M:AForge.Imaging.Textures.MarbleTexture.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Textures.MarbleTexture.Reset">
            <summary>
            Reset generator.
            </summary>
            
            <remarks>Regenerates internal random numbers.</remarks>
             
        </member>
        <member name="P:AForge.Imaging.Textures.MarbleTexture.XPeriod">
            <summary>
            X period value, ≥ 2.
            </summary>
            
            <remarks>Default value is set to <b>5</b>.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Textures.MarbleTexture.YPeriod">
            <summary>
            Y period value, ≥ 2.
            </summary>
            
            <remarks>Default value is set to <b>10</b>.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.TransformToPolar">
            <summary>
            Transform rectangle image into circle (to polar coordinates).
            </summary>
            
            <remarks><para>The image processing routine does transformation of the source image into
            circle (polar transformation). The produced effect is similar to GIMP's "Polar Coordinates"
            distortion filter (or its equivalent in Photoshop).
            </para>
            
            <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            TransformToPolar filter = new TransformToPolar( );
            filter.OffsetAngle = 0;
            filter.CirlceDepth = 1;
            filter.UseOriginalImageSize = false;
            filter.NewSize = new Size( 200, 200 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample21.png" width="320" height="160"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/polar.png" width="200" height="200"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.TransformFromPolar"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TransformToPolar.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.TransformToPolar"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TransformToPolar.CalculateNewImageSize(AForge.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TransformToPolar.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformToPolar.CirlceDepth">
            <summary>
            Circularity coefficient of the mapping, [0, 1].
            </summary>
            
            <remarks><para>The property specifies circularity coefficient of the mapping to be done.
            If the coefficient is set to 1, then the mapping will produce ideal circle. If the coefficient
            is set to 0, then the mapping will occupy entire area of the destination image (circle will
            be extended into direction of edges). Changing the property from 0 to 1 user may balance
            circularity of the produced output.
            </para>
            
            <para>Default value is set to <b>1</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformToPolar.OffsetAngle">
            <summary>
            Offset angle used to shift mapping, [-360, 360] degrees.
            </summary>
            
            <remarks><para>The property specifies offset angle, which can be used to shift
            mapping in counter clockwise direction. For example, if user sets this property to 30, then
            start of polar mapping is shifted by 30 degrees in counter clockwise direction.</para>
            
            <para>Default value is set to <b>0</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformToPolar.MapBackwards">
             <summary>
             Specifies direction of mapping.
             </summary>
            
             <remarks><para>The property specifies direction of mapping source image's X axis. If the
             property is set to <see langword="false"/>, the image is mapped in clockwise direction;
             otherwise in counter clockwise direction.</para>
             
             <para>Default value is set to <see langword="false"/>.</para>
             </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformToPolar.MapFromTop">
            <summary>
            Specifies if top of the source image should go to center or edge of the result image.
            </summary>
            
            <remarks><para>The property specifies position of the source image's top line in the destination
            image. If the property is set to <see langword="true"/>, then it goes to the center of the result image;
            otherwise it goes to the edge.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformToPolar.FillColor">
            <summary>
            Fill color to use for unprocessed areas.
            </summary>
            
            <remarks><para>The property specifies fill color, which is used to fill unprocessed areas.
            In the case if <see cref="P:AForge.Imaging.Filters.TransformToPolar.CirlceDepth"/> is greater than 0, then there will be some areas on
            the image's edge, which are not filled by the produced "circular" image, but are filled by
            the specified color.
            </para>
            
            <para>Default value is set to <see cref="P:System.Drawing.Color.White"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformToPolar.NewSize">
            <summary>
            Size of destination image.
            </summary>
            
            <remarks><para>The property specifies size of result image produced by this image
            processing routine in the case if <see cref="P:AForge.Imaging.Filters.TransformToPolar.UseOriginalImageSize"/> property
            is set to <see langword="false"/>.</para>
            
            <para><note>Both width and height must be in the [1, 10000] range.</note></para>
            
            <para>Default value is set to <b>200 x 200</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformToPolar.UseOriginalImageSize">
            <summary>
            Use source image size for destination or not.
            </summary>
            
            <remarks><para>The property specifies if the image processing routine should create destination
            image of the same size as original image or of the size specified by <see cref="P:AForge.Imaging.Filters.TransformToPolar.NewSize"/>
            property.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformToPolar.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.TransformFromPolar">
            <summary>
            Transform polar image into rectangle.
            </summary>
            
            <remarks>The image processing routine is oposite transformation to the one done by <see cref="T:AForge.Imaging.Filters.TransformToPolar"/>
            routine, i.e. transformation from polar image into rectangle. The produced effect is similar to GIMP's
            "Polar Coordinates" distortion filter (or its equivalent in Photoshop).
            
            <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            TransformFromPolar filter = new TransformFromPolar( );
            filter.OffsetAngle = 0;
            filter.CirlceDepth = 1;
            filter.UseOriginalImageSize = false;
            filter.NewSize = new Size( 360, 120 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample22.png" width="240" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/from_polar.png" width="360" height="120"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.TransformToPolar"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TransformFromPolar.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.TransformFromPolar"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TransformFromPolar.CalculateNewImageSize(AForge.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TransformFromPolar.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformFromPolar.CirlceDepth">
            <summary>
            Circularity coefficient of the mapping, [0, 1].
            </summary>
            
            <remarks><para>The property specifies circularity coefficient of the mapping to be done.
            If the coefficient is set to 1, then destination image will be produced by mapping
            ideal circle from the source image, which is placed in source image's centre and its
            radius equals to the minimum distance from centre to the image’s edge. If the coefficient
            is set to 0, then the mapping will use entire area of the source image (circle will
            be extended into direction of edges). Changing the property from 0 to 1 user may balance
            circularity of the produced output.</para>
            
            <para>Default value is set to <b>1</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformFromPolar.OffsetAngle">
            <summary>
            Offset angle used to shift mapping, [-360, 360] degrees.
            </summary>
            
            <remarks><para>The property specifies offset angle, which can be used to shift
            mapping in clockwise direction. For example, if user sets this property to 30, then
            start of polar mapping is shifted by 30 degrees in clockwise direction.</para>
            
            <para>Default value is set to <b>0</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformFromPolar.MapBackwards">
             <summary>
             Specifies direction of mapping.
             </summary>
            
             <remarks><para>The property specifies direction of mapping source image. If the
             property is set to <see langword="false"/>, the image is mapped in clockwise direction;
             otherwise in counter clockwise direction.</para>
             
             <para>Default value is set to <see langword="false"/>.</para>
             </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformFromPolar.MapFromTop">
            <summary>
            Specifies if centre of the source image should to top or bottom of the result image.
            </summary>
            
            <remarks><para>The property specifies position of the source image's centre in the destination image.
            If the property is set to <see langword="true"/>, then it goes to the top of the result image;
            otherwise it goes to the bottom.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformFromPolar.NewSize">
            <summary>
            Size of destination image.
            </summary>
            
            <remarks><para>The property specifies size of result image produced by this image
            processing routine in the case if <see cref="P:AForge.Imaging.Filters.TransformFromPolar.UseOriginalImageSize"/> property
            is set to <see langword="false"/>.</para>
            
            <para><note>Both width and height must be in the [1, 10000] range.</note></para>
            
            <para>Default value is set to <b>200 x 200</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformFromPolar.UseOriginalImageSize">
            <summary>
            Use source image size for destination or not.
            </summary>
            
            <remarks><para>The property specifies if the image processing routine should create destination
            image of the same size as original image or of the size specified by <see cref="P:AForge.Imaging.Filters.TransformFromPolar.NewSize"/>
            property.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TransformFromPolar.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.RotateBicubic">
             <summary>
             Rotate image using bicubic interpolation.
             </summary>
             
             <remarks><para>The class implements image rotation filter using bicubic
             interpolation algorithm. It uses bicubic kernel W(x) as described on
             <a href="http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm">Wikipedia</a>
             (coefficient <b>a</b> is set to <b>-0.5</b>).</para>
             
             <para><note>Rotation is performed in counterclockwise direction.</note></para>
             
             <para>The filter accepts 8 bpp grayscale images and 24 bpp
             color images for processing.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter - rotate for 30 degrees keeping original image size
             RotateBicubic filter = new RotateBicubic( 30, true );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample9.png" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/rotate_bicubic.png" width="320" height="240"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.RotateBilinear"/>
             <seealso cref="T:AForge.Imaging.Filters.RotateNearestNeighbor"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.RotateBicubic.#ctor(System.Double)">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.RotateBicubic"/> class.
             </summary>
             
             <param name="angle">Rotation angle.</param>
             
             <remarks><para>This constructor sets <see cref="P:AForge.Imaging.Filters.BaseRotateFilter.KeepSize"/> property
             to <see langword="false"/>.</para>
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.RotateBicubic.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.RotateBicubic"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            <param name="keepSize">Keep image size or not.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.RotateBicubic.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="sourceData">Source image data.</param>
             <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.RotateBicubic.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.VerticalRunLengthSmoothing">
            <summary>
            Vertical run length smoothing algorithm.
            </summary>
            
            <remarks><para>The class implements vertical run length smoothing algorithm, which
            is described in: <b>K.Y. Wong, R.G. Casey and F.M. Wahl, "Document analysis system,"
            IBM J. Res. Devel., Vol. 26, NO. 6,111). 647-656, 1982.</b></para>
            
            <para>Unlike the original description of this algorithm, this implementation must be applied
            to inverted binary images containing document, i.e. white text on black background. So this
            implementation fills vertical black gaps between white pixels.</para>
            
            <para><note>This algorithm is usually used together with <see cref="T:AForge.Imaging.Filters.HorizontalRunLengthSmoothing"/>,
            <see cref="T:AForge.Imaging.Filters.Intersect"/> and then further analysis of white blobs.</note></para>
            
            <para>The filter accepts 8 bpp grayscale images, which are supposed to be binary inverted documents.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            VerticalRunLengthSmoothing vrls = new VerticalRunLengthSmoothing( 32 );
            // apply the filter
            vrls.ApplyInPlace( image );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="img/imaging/sample24.png" width="480" height="320"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/vrls.png" width="480" height="320"/>
            </remarks>
            
            <see cref="T:AForge.Imaging.Filters.HorizontalRunLengthSmoothing"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.VerticalRunLengthSmoothing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.VerticalRunLengthSmoothing"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.VerticalRunLengthSmoothing.#ctor(System.Int32)">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.VerticalRunLengthSmoothing"/> class.
             </summary>
             
             <param name="maxGapSize">Maximum gap size to fill (see <see cref="P:AForge.Imaging.Filters.VerticalRunLengthSmoothing.MaxGapSize"/>).</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.VerticalRunLengthSmoothing.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.VerticalRunLengthSmoothing.MaxGapSize">
             <summary>
             Maximum gap size to fill (in pixels).
             </summary>
             
             <remarks><para>The property specifies maximum vertical gap between white pixels to fill.
             If number of black pixels between some white pixels is bigger than this value, then those
             black pixels are left as is; otherwise the gap is filled with white pixels.
             </para>
             
             <para>Default value is set to <b>10</b>. Minimum value is 1. Maximum value is 1000.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.VerticalRunLengthSmoothing.ProcessGapsWithImageBorders">
            <summary>
            Process gaps between objects and image borders or not.
            </summary>
            
            <remarks><para>The property sets if gaps between image borders and objects must be treated as
            gaps between objects and also filled.</para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.VerticalRunLengthSmoothing.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.SaltAndPepperNoise">
            <summary>
            Salt and pepper noise.
            </summary>
            
            <remarks><para>The filter adds random salt and pepper noise - sets
            maximum or minimum values to randomly selected pixels.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SaltAndPepperNoise filter = new SaltAndPepperNoise( 10 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="img/imaging/salt_noise.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SaltAndPepperNoise.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SaltAndPepperNoise"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SaltAndPepperNoise.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SaltAndPepperNoise"/> class.
            </summary>
            
            <param name="noiseAmount">Amount of noise to generate in percents, [0, 100].</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SaltAndPepperNoise.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.SaltAndPepperNoise.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.SaltAndPepperNoise.NoiseAmount">
            <summary>
            Amount of noise to generate in percents, [0, 100].
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Filters.AdditiveNoise">
            <summary>
            Additive noise filter.
            </summary>
            
            <remarks><para>The filter adds random value to each pixel of the source image.
            The distribution of random values can be specified by <see cref="P:AForge.Imaging.Filters.AdditiveNoise.Generator">random generator</see>.
            </para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create random generator
            IRandomNumberGenerator generator = new UniformGenerator( new Range( -50, 50 ) );
            // create filter
            AdditiveNoise filter = new AdditiveNoise( generator );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/additive_noise.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.AdditiveNoise.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.AdditiveNoise"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.AdditiveNoise.#ctor(AForge.Math.Random.IRandomNumberGenerator)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.AdditiveNoise"/> class.
            </summary>
            
            <param name="generator">Random number genertor used to add noise.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.AdditiveNoise.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.AdditiveNoise.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.AdditiveNoise.Generator">
            <summary>
            Random number genertor used to add noise.
            </summary>
            
            <remarks>Default generator is uniform generator in the range of (-10, 10).</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Closing">
            <summary>
            Closing operator from Mathematical Morphology.
            </summary>
            
            <remarks><para>Closing morphology operator equals to <see cref="T:AForge.Imaging.Filters.Dilatation">dilatation</see> followed
            by <see cref="T:AForge.Imaging.Filters.Erosion">erosion</see>.</para>
            
            <para>Applied to binary image, the filter may be used connect or fill objects. Since dilatation is used
            first, it may connect/fill object areas. Then erosion restores objects. But since dilatation may connect
            something before, erosion may not remove after that because of the formed connection.</para>
            
            <para>See documentation to <see cref="T:AForge.Imaging.Filters.Erosion"/> and <see cref="T:AForge.Imaging.Filters.Dilatation"/> classes for more
            information and list of supported pixel formats.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Closing filter = new Closing( );
            // apply the filter
            filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample12.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/closing.png" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Erosion"/>
            <seealso cref="T:AForge.Imaging.Filters.Dilatation"/>
            <seealso cref="T:AForge.Imaging.Filters.Opening"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Closing"/> class.
            </summary>
            
            <remarks><para>Initializes new instance of the <see cref="T:AForge.Imaging.Filters.Closing"/> class using
            default structuring element for both <see cref="T:AForge.Imaging.Filters.Erosion"/> and <see cref="T:AForge.Imaging.Filters.Dilatation"/>
            classes - 3x3 structuring element with all elements equal to 1.
            </para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Closing"/> class.
            </summary>
            
            <param name="se">Structuring element.</param>
            
            <remarks><para>See documentation to <see cref="T:AForge.Imaging.Filters.Erosion"/> and <see cref="T:AForge.Imaging.Filters.Dilatation"/>
            classes for information about structuring element constraints.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.Apply(System.Drawing.Imaging.BitmapData)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="imageData">Source image to apply filter to.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The filter accepts bitmap data as input and returns the result
            of image processing filter as new image. The source image data are kept
            unchanged.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.Apply(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.Apply(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:AForge.Imaging.Filters.Closing.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:AForge.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.ApplyInPlace(AForge.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an unmanaged image.
             </summary>
             
             <param name="image">Unmanaged image to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source unmanaged image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.ApplyInPlace(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.ApplyInPlace(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
             <summary>
             Apply filter to an image or its part.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Closing.ApplyInPlace(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an unmanaged image or its part.
            </summary>
            
            <param name="image">Unmanaged image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Closing.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.HueModifier">
             <summary>
             Hue modifier.
             </summary>
             
             <remarks><para>The filter operates in <b>HSL</b> color space and updates
             pixels' hue values setting it to the specified value (luminance and
             saturation are kept unchanged). The result of the filter looks like the image
             is observed through a glass of the given color.</para>
            
             <para>The filter accepts 24 and 32 bpp color images for processing.</para>
             <para>Sample usage:</para>
             <code>
             // create filter
             HueModifier filter = new HueModifier( 180 );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="img/imaging/hue_modifier.jpg" width="480" height="361" />
             </remarks>
             
        </member>
        <member name="M:AForge.Imaging.Filters.HueModifier.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.HueModifier"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HueModifier.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.HueModifier"/> class.
            </summary>
            
            <param name="hue">Hue value to set.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.HueModifier.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.HueModifier.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.HueModifier.Hue">
            <summary>
            Hue value to set, [0, 359].
            </summary>
            
            <remarks><para>Default value is set to <b>0</b>.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BayerPattern">
            <summary>
            Set of Bayer patterns supported by <see cref="T:AForge.Imaging.Filters.BayerFilterOptimized"/>.
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.BayerPattern.GRBG">
            <summary>
            Pattern:<br /><br />
            G R<br />
            B G
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.BayerPattern.BGGR">
            <summary>
            Pattern:<br /><br />
            B G<br />
            G R
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.BayerFilterOptimized">
            <summary>
            Optimized Bayer fileter image processing routine.
            </summary>
            
            <remarks><para>The class implements <a href="http://en.wikipedia.org/wiki/Bayer_filter">Bayer filter</a>
            routine, which creates color image out of grayscale image produced by image sensor built with
            Bayer color matrix.</para>
            
            <para>This class does all the same as <see cref="T:AForge.Imaging.Filters.BayerFilter"/> class. However this version is
            optimized for some well known patterns defined in <see cref="T:AForge.Imaging.Filters.BayerPattern"/> enumeration.
            Also this class processes images with even width and height only. Image size must be at least 2x2 pixels.
            </para>
            
            <para>The filter accepts 8 bpp grayscale images and produces 24 bpp RGB image.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            BayerFilter filter = new BayerFilter( );
            // apply the filter
            Bitmap rgbImage = filter.Apply( image );
            </code>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.BayerFilter"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BayerFilterOptimized.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BayerFilterOptimized"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BayerFilterOptimized.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BayerFilterOptimized.Pattern">
            <summary>
            Bayer pattern of source images to decode.
            </summary>
            
            <remarks><para>The property specifies Bayer pattern of source images to be
            decoded into color images.</para>
            
            <para>Default value is set to <see cref="F:AForge.Imaging.Filters.BayerPattern.GRBG"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BayerFilterOptimized.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ColorRemapping">
            <summary>
            Color remapping.
            </summary>
            
            <remarks><para>The filter allows to remap colors of the image. Unlike <see cref="T:AForge.Imaging.Filters.LevelsLinear"/> filter
            the filter allow to do non-linear remapping. For each pixel of specified image the filter changes
            its values (value of each color plane) to values, which are stored in remapping arrays by corresponding
            indexes. For example, if pixel's RGB value equals to (32, 96, 128), the filter will change it to
            (<see cref="P:AForge.Imaging.Filters.ColorRemapping.RedMap"/>[32], <see cref="P:AForge.Imaging.Filters.ColorRemapping.GreenMap"/>[96], <see cref="P:AForge.Imaging.Filters.ColorRemapping.BlueMap"/>[128]).</para>
            
            <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create map
            byte[] map = new byte[256];
            for ( int i = 0; i &lt; 256; i++ )
            {
                map[i] = (byte) Math.Min( 255, Math.Pow( 2, (double) i / 32 ) );
            }
            // create filter
            ColorRemapping filter = new ColorRemapping( map, map, map );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/color_remapping.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ColorRemapping.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ColorRemapping"/> class.
            </summary>
            
            <remarks>Initializes the filter without any remapping. All
            pixel values are mapped to the same values.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ColorRemapping.#ctor(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ColorRemapping"/> class.
            </summary>
            
            <param name="redMap">Red map.</param>
            <param name="greenMap">Green map.</param>
            <param name="blueMap">Blue map.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ColorRemapping.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ColorRemapping"/> class.
            </summary>
            
            <param name="grayMap">Gray map.</param>
            
            <remarks>This constructor is supposed for grayscale images.</remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ColorRemapping.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ColorRemapping.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ColorRemapping.RedMap">
            <summary>
            Remapping array for red color plane.
            </summary>
            
            <remarks><para>The remapping array should contain 256 remapping values. The remapping occurs
            by changing pixel's red value <b>r</b> to <see cref="P:AForge.Imaging.Filters.ColorRemapping.RedMap"/>[r].</para></remarks>
            
            <exception cref="T:System.ArgumentException">A map should be array with 256 value.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ColorRemapping.GreenMap">
            <summary>
            Remapping array for green color plane.
            </summary>
            
            <remarks><para>The remapping array should contain 256 remapping values. The remapping occurs
            by changing pixel's green value <b>g</b> to <see cref="P:AForge.Imaging.Filters.ColorRemapping.GreenMap"/>[g].</para></remarks>
            
            <exception cref="T:System.ArgumentException">A map should be array with 256 value.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ColorRemapping.BlueMap">
            <summary>
            Remapping array for blue color plane.
            </summary>
            
            <remarks><para>The remapping array should contain 256 remapping values. The remapping occurs
            by changing pixel's blue value <b>b</b> to <see cref="P:AForge.Imaging.Filters.ColorRemapping.BlueMap"/>[b].</para></remarks>
            
            <exception cref="T:System.ArgumentException">A map should be array with 256 value.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ColorRemapping.GrayMap">
            <summary>
            Remapping array for gray color.
            </summary>
            
            <remarks><para>The remapping array should contain 256 remapping values. The remapping occurs
            by changing pixel's value <b>g</b> to <see cref="P:AForge.Imaging.Filters.ColorRemapping.GrayMap"/>[g].</para>
            
            <para>The gray map is for grayscale images only.</para></remarks>
            
            <exception cref="T:System.ArgumentException">A map should be array with 256 value.</exception>
            
        </member>
        <member name="T:AForge.Imaging.Filters.OrderedDithering">
            <summary>
            Binarization with thresholds matrix.
            </summary>
            
            <remarks><para>Idea of the filter is the same as idea of <see cref="T:AForge.Imaging.Filters.Threshold"/> filter -
            change pixel value to white, if its intensity is equal or higher than threshold value, or
            to black otherwise. But instead of using single threshold value for all pixel, the filter
            uses matrix of threshold values. Processing image is divided to adjacent windows of matrix
            size each. For pixels binarization inside of each window, corresponding threshold values are
            used from specified threshold matrix.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create binarization matrix
            byte[,] matrix = new byte[4, 4]
            {
                {  95, 233, 127, 255 },
                { 159,  31, 191,  63 },
                { 111, 239,  79, 207 },
                { 175,  47, 143,  15 }
            };
            // create filter
            OrderedDithering filter = new OrderedDithering( matrix );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/grayscale.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/ordered_dithering.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.BayerDithering"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.OrderedDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.OrderedDithering"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.OrderedDithering.#ctor(System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.OrderedDithering"/> class.
            </summary>
            
            <param name="matrix">Thresholds matrix.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.OrderedDithering.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.OrderedDithering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.BayerDithering">
            <summary>
            Ordered dithering using Bayer matrix.
            </summary>
            
            <remarks><para>The filter represents <see cref="T:AForge.Imaging.Filters.OrderedDithering"/> filter initialized
            with the next threshold matrix:</para>
            <code>
            byte[,] matrix = new byte[4, 4]
            {
            	{   0, 192,  48, 240 },
            	{ 128,  64, 176, 112 },
            	{  32, 224,  16, 208 },
            	{ 160,  96, 144,  80 }
            };
            </code>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            BayerDithering filter = new BayerDithering( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/grayscale.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/bayer_dithering.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BayerDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BayerDithering"/> class.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.VerticalIntensityStatistics">
             <summary>
             Vertical intensity statistics.
             </summary>
             
             <remarks><para>The class provides information about vertical distribution
             of pixel intensities, which may be used to locate objects, their centers, etc.
             </para>
             
             <para>The class accepts grayscale (8 bpp indexed and 16 bpp) and color (24, 32, 48 and 64 bpp) images.
             In the case of 32 and 64 bpp color images, the alpha channel is not processed - statistics is not
             gathered for this channel.</para>
             
             <para>Sample usage:</para>
             <code>
             // collect statistics
             VerticalIntensityStatistics vis = new VerticalIntensityStatistics( sourceImage );
             // get gray histogram (for grayscale image)
             Histogram histogram = vis.Gray;
             // output some histogram's information
             System.Diagnostics.Debug.WriteLine( "Mean = " + histogram.Mean );
             System.Diagnostics.Debug.WriteLine( "Min = " + histogram.Min );
             System.Diagnostics.Debug.WriteLine( "Max = " + histogram.Max );
             </code>
             
             <para><b>Sample grayscale image with its vertical intensity histogram:</b></para>
             <img src="img/imaging/ver_histogram.jpg" width="450" height="240"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.HorizontalIntensityStatistics"/>
            
        </member>
        <member name="M:AForge.Imaging.VerticalIntensityStatistics.#ctor(System.Drawing.Bitmap)">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.VerticalIntensityStatistics"/> class.
             </summary>
             
             <param name="image">Source image.</param>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:AForge.Imaging.VerticalIntensityStatistics.#ctor(System.Drawing.Imaging.BitmapData)">
             <summary>
             Initializes a new instance of the <see cref="T:AForge.Imaging.VerticalIntensityStatistics"/> class.
             </summary>
             
             <param name="imageData">Source image data.</param>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:AForge.Imaging.VerticalIntensityStatistics.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.HorizontalIntensityStatistics"/> class.
            </summary>
            
            <param name="image">Source unmanaged image.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.VerticalIntensityStatistics.ProcessImage(AForge.Imaging.UnmanagedImage)">
            <summary>
            Gather vertical intensity statistics for specified image.
            </summary>
            
            <param name="image">Source image.</param>
            
        </member>
        <member name="P:AForge.Imaging.VerticalIntensityStatistics.Red">
            <summary>
            Histogram for red channel.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.VerticalIntensityStatistics.Green">
            <summary>
            Histogram for green channel.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.VerticalIntensityStatistics.Blue">
            <summary>
            Histogram for blue channel.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.VerticalIntensityStatistics.Gray">
            <summary>
            Histogram for gray channel (intensities).
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.VerticalIntensityStatistics.IsGrayscale">
            <summary>
            Value wich specifies if the processed image was color or grayscale.
            </summary>
            
            <remarks><para>If the property equals to <b>true</b>, then the <see cref="P:AForge.Imaging.VerticalIntensityStatistics.Gray"/>
            property should be used to retrieve histogram for the processed grayscale image.
            Otherwise <see cref="P:AForge.Imaging.VerticalIntensityStatistics.Red"/>, <see cref="P:AForge.Imaging.VerticalIntensityStatistics.Green"/> and <see cref="P:AForge.Imaging.VerticalIntensityStatistics.Blue"/> property
            should be used to retrieve histogram for particular RGB channel of the processed
            color image.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.TexturedMerge">
            <summary>
            Merge two images using factors from texture.
            </summary>
            
            <remarks><para>The filter is similar to <see cref="T:AForge.Imaging.Filters.Morph"/> filter in its idea, but
            instead of using single value for balancing amount of source's and overlay's image
            values (see <see cref="P:AForge.Imaging.Filters.Morph.SourcePercent"/>), the filter uses texture, which determines
            the amount to take from source image and overlay image.</para>
            
            <para>The filter uses specified texture to adjust values using the next formula:<br/>
            <b>dst = src * textureValue + ovr * ( 1.0 - textureValue )</b>,<br/>
            where <b>src</b> is value of pixel in a source image, <b>ovr</b> is value of pixel in
            overlay image, <b>dst</b> is value of pixel in a destination image and
            <b>textureValue</b> is corresponding value from provided texture (see <see cref="P:AForge.Imaging.Filters.TexturedMerge.TextureGenerator"/> or
            <see cref="P:AForge.Imaging.Filters.TexturedMerge.Texture"/>).</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images for processing.</para>
            
            <para>Sample usage #1:</para>
            <code>
            // create filter
            TexturedMerge filter = new TexturedMerge( new TextileTexture( ) );
            // create an overlay image to merge with
            filter.OverlayImage = new Bitmap( image.Width, image.Height,
                    PixelFormat.Format24bppRgb );
            // fill the overlay image with solid color
            PointedColorFloodFill fillFilter = new PointedColorFloodFill( Color.DarkKhaki );
            fillFilter.ApplyInPlace( filter.OverlayImage );
            // apply the merge filter
            filter.ApplyInPlace( image );
            </code>
            
            <para>Sample usage #2:</para>
            <code>
            // create filter
            TexturedMerge filter = new TexturedMerge( new CloudsTexture( ) );
            // create 2 images with modified Hue
            HueModifier hm1 = new HueModifier( 50 );
            HueModifier hm2 = new HueModifier( 200 );
            filter.OverlayImage = hm2.Apply( image );
            hm1.ApplyInPlace( image );
            // apply the merge filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image #1:</b></para>
            <img src="img/imaging/textured_merge1.jpg" width="480" height="361"/>
            <para><b>Result image #2:</b></para>
            <img src="img/imaging/textured_merge2.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TexturedMerge.#ctor(System.Single[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.TexturedMerge"/> class.
            </summary>
            
            <param name="texture">Generated texture.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TexturedMerge.#ctor(AForge.Imaging.Textures.ITextureGenerator)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.TexturedMerge"/> class.
            </summary>
            
            <param name="generator">Texture generator.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.TexturedMerge.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TexturedMerge.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
            
             <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TexturedMerge.Texture">
            <summary>
            Generated texture.
            </summary>
            
            <remarks><para>Two dimensional array of texture intensities.</para>
            
            <para><note>In the case if image passed to the filter is smaller or
            larger than the specified texture, than image's region is processed, which equals to the
            minimum overlapping area.</note></para>
            
            <para><note>The <see cref="P:AForge.Imaging.Filters.TexturedMerge.TextureGenerator"/> property has priority over this property - if
            generator is specified than the static generated texture is not used.</note></para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.TexturedMerge.TextureGenerator">
            <summary>
            Texture generator.
            </summary>
            
            <remarks><para>Generator used to generate texture.</para>
            
            <para><note>The property has priority over the <see cref="P:AForge.Imaging.Filters.TexturedMerge.Texture"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.CanvasCrop">
            <summary>
            Fill areas outiside of specified region.
            </summary>
            
            <remarks>
            <para>The filter fills areas outside of specified region using the specified color.</para>
            
            <para>The filter accepts 8bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            CanvasCrop filter = new CanvasCrop( new Rectangle(
                                    5, 5, image.Width - 10, image.Height - 10 ), Color.Red );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/canvas_crop.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.CanvasFill"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasCrop.#ctor(System.Drawing.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasCrop"/> class.
            </summary>
            
            <param name="region">Region to keep.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasCrop.#ctor(System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasCrop"/> class.
            </summary>
            
            <param name="region">Region to keep.</param>
            <param name="fillColorRGB">RGB color to use for filling areas outside of specified region in color images.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasCrop.#ctor(System.Drawing.Rectangle,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasCrop"/> class.
            </summary>
            
            <param name="region">Region to keep.</param>
            <param name="fillColorGray">Gray color to use for filling areas outside of specified region in grayscale images.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasCrop.#ctor(System.Drawing.Rectangle,System.Drawing.Color,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CanvasCrop"/> class.
            </summary>
            
            <param name="region">Region to keep.</param>
            <param name="fillColorRGB">RGB color to use for filling areas outside of specified region in color images.</param>
            <param name="fillColorGray">Gray color to use for filling areas outside of specified region in grayscale images.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CanvasCrop.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasCrop.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasCrop.FillColorRGB">
            <summary>
            RGB fill color.
            </summary>
            
            <remarks><para>The color is used to fill areas out of specified region in color images.</para>
            
            <para>Default value is set to white - RGB(255, 255, 255).</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasCrop.FillColorGray">
            <summary>
            Gray fill color.
            </summary>
            
            <remarks><para>The color is used to fill areas out of specified region in grayscale images.</para>
            
            <para>Default value is set to white - 255.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CanvasCrop.Region">
            <summary>
            Region to keep.
            </summary>
            
            <remarks>Pixels inside of the specified region will keep their values, but
            pixels outside of the region will be filled with specified color.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Erosion">
            <summary>
            Erosion operator from Mathematical Morphology.
            </summary>
            
            <remarks><para>The filter assigns minimum value of surrounding pixels to each pixel of
            the result image. Surrounding pixels, which should be processed, are specified by
            structuring element: 1 - to process the neighbor, -1 - to skip it.</para>
            
            <para>The filter especially useful for binary image processing, where it removes pixels, which
            are not surrounded by specified amount of neighbors. It gives ability to remove noisy pixels
            (stand-alone pixels) or shrink objects.</para>
            
            <para>For processing image with 3x3 structuring element, there are different optimizations
            available, like <see cref="T:AForge.Imaging.Filters.Erosion3x3"/> and <see cref="T:AForge.Imaging.Filters.BinaryErosion3x3"/>.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24 and 48 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Erosion filter = new Erosion( );
            // apply the filter
            filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample12.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/erosion.png" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Dilatation"/>
            <seealso cref="T:AForge.Imaging.Filters.Closing"/>
            <seealso cref="T:AForge.Imaging.Filters.Opening"/>
            <seealso cref="T:AForge.Imaging.Filters.Erosion3x3"/>
            <seealso cref="T:AForge.Imaging.Filters.BinaryErosion3x3"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Erosion.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Erosion"/> class.
            </summary>
            
            <remarks><para>Initializes new instance of the <see cref="T:AForge.Imaging.Filters.Erosion"/> class using
            default structuring element - 3x3 structuring element with all elements equal to 1.
            </para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Erosion.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Erosion"/> class.
            </summary>
            
            <param name="se">Structuring element.</param>
            
            <remarks><para>Structuring elemement for the erosion morphological operator
            must be square matrix with odd size in the range of [3, 99].</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid size of structuring element.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Erosion.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Erosion.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.BottomHat">
             <summary>
             Bottop-hat operator from Mathematical Morphology.
             </summary>
             
             <remarks><para>Bottom-hat morphological operator <see cref="T:AForge.Imaging.Filters.Subtract">subtracts</see>
             input image from the result of <see cref="T:AForge.Imaging.Filters.Closing">morphological closing</see> on the
             the input image.</para>
             
             <para>Applied to binary image, the filter allows to get all object parts, which were
             added by <see cref="T:AForge.Imaging.Filters.Closing">closing</see> filter, but were not removed after that due
             to formed connections/fillings.</para>
             
             <para>The filter accepts 8 and 16 bpp grayscale images and 24 and 48 bpp
             color images for processing.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter
             BottomHat filter = new BottomHat( );
             // apply the filter
             filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample12.png" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/bottomhat.png" width="320" height="240"/>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.TopHat"/>
             
        </member>
        <member name="M:AForge.Imaging.Filters.BottomHat.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BottomHat"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BottomHat.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BottomHat"/> class.
            </summary>
            
            <param name="se">Structuring element to pass to <see cref="T:AForge.Imaging.Filters.Closing"/> operator.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BottomHat.ProcessFilter(AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BottomHat.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.GrayscaleY">
             <summary>
             Grayscale image using Y algorithm.
             </summary>
             
             <remarks>The class uses <b>Y</b> algorithm to convert color image
             to grayscale. The conversion coefficients are:
             <list type="bullet">
             <item>Red: 0.299;</item>
             <item>Green: 0.587;</item>
             <item>Blue: 0.114.</item>
             </list>
             </remarks>
             
             <seealso cref="T:AForge.Imaging.Filters.Grayscale"/>
             <seealso cref="T:AForge.Imaging.Filters.GrayscaleBT709"/>
             <seealso cref="T:AForge.Imaging.Filters.GrayscaleRMY"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.GrayscaleY.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.GrayscaleY"/> class.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.ContrastStretch">
            <summary>
            Contrast stretching filter.
            </summary>
            
            <remarks><para>Contrast stretching (or as it is often called normalization) is a simple image enhancement
            technique that attempts to improve the contrast in an image by 'stretching' the range of intensity values
            it contains to span a desired range of values, e.g. the full range of pixel values that the image type
            concerned allows. It differs from the more sophisticated <see cref="T:AForge.Imaging.Filters.HistogramEqualization">histogram equalization</see>
            in that it can only apply a linear scaling function to the image pixel values.</para>
            
            <para>The result of this filter may be achieved by using <see cref="T:AForge.Imaging.ImageStatistics"/> class, which allows to
            get pixels' intensities histogram, and <see cref="T:AForge.Imaging.Filters.LevelsLinear"/> filter, which does linear correction
            of pixel's intensities.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ContrastStretch filter = new ContrastStretch( );
            // process image
            filter.ApplyInPlace( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="img/imaging/sample5.jpg" width="480" height="387"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/contrast_stretch.jpg" width="480" height="387"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ContrastStretch.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ContrastStretch"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.ContrastStretch.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ContrastStretch.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.ChannelFiltering">
            <summary>
            Channels filters.
            </summary>
            
            <remarks><para>The filter does color channels' filtering by clearing (filling with
            specified values) values, which are inside/outside of the specified value's
            range. The filter allows to fill certain ranges of RGB color channels with specified
            value.</para>
            
            <para>The filter is similar to <see cref="T:AForge.Imaging.Filters.ColorFiltering"/>, but operates with not
            entire pixels, but with their RGB values individually. This means that pixel itself may
            not be filtered (will be kept), but one of its RGB values may be filtered if they are
            inside/outside of specified range.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ChannelFiltering filter = new ChannelFiltering( );
            // set channels' ranges to keep
            filter.Red   = new IntRange(   0, 255 );
            filter.Green = new IntRange( 100, 255 );
            filter.Blue  = new IntRange( 100, 255 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/channel_filtering.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.ColorFiltering"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ChannelFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ChannelFiltering"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ChannelFiltering.#ctor(AForge.IntRange,AForge.IntRange,AForge.IntRange)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ChannelFiltering"/> class.
            </summary>
            
            <param name="red">Red channel's filtering range.</param>
            <param name="green">Green channel's filtering range.</param>
            <param name="blue">Blue channel's filtering range.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ChannelFiltering.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ChannelFiltering.CalculateMap(AForge.IntRange,System.Byte,System.Boolean,System.Byte[])">
            <summary>
            Calculate filtering map.
            </summary>
            
            <param name="range">Filtering range.</param>
            <param name="fill">Fillter value.</param>
            <param name="fillOutsideRange">Fill outside or inside the range.</param>
            <param name="map">Filtering map.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ChannelFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ChannelFiltering.Red">
            <summary>
            Red channel's range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ChannelFiltering.FillRed">
            <summary>
            Red fill value.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ChannelFiltering.Green">
            <summary>
            Green channel's range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ChannelFiltering.FillGreen">
            <summary>
            Green fill value.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ChannelFiltering.Blue">
            <summary>
            Blue channel's range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ChannelFiltering.FillBlue">
            <summary>
            Blue fill value.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.ChannelFiltering.RedFillOutsideRange">
            <summary>
            Determines, if red channel should be filled inside or outside filtering range.
            </summary>
            
            <remarks>Default value is set to <see langword="true"/>.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ChannelFiltering.GreenFillOutsideRange">
            <summary>
            Determines, if green channel should be filled inside or outside filtering range.
            </summary>
            
            <remarks>Default value is set to <see langword="true"/>.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ChannelFiltering.BlueFillOutsideRange">
             <summary>
             Determines, if blue channel should be filled inside or outside filtering range.
             </summary>
             
             <remarks>Default value is set to <see langword="true"/>.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BayerFilter">
            <summary>
            Generic Bayer fileter image processing routine.
            </summary>
            
            <remarks><para>The class implements <a href="http://en.wikipedia.org/wiki/Bayer_filter">Bayer filter</a>
            routine, which creates color image out of grayscale image produced by image sensor built with
            Bayer color matrix.</para>
            
            <para>This Bayer filter implementation is made generic by allowing user to specify used
            <see cref="P:AForge.Imaging.Filters.BayerFilter.BayerPattern">Bayer pattern</see>. This makes it slower. For optimized version
            of the Bayer filter see <see cref="T:AForge.Imaging.Filters.BayerFilterOptimized"/> class, which implements Bayer filter
            specifically optimized for some well known patterns.</para>
            
            <para>The filter accepts 8 bpp grayscale images and produces 24 bpp RGB image.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            BayerFilter filter = new BayerFilter( );
            // apply the filter
            Bitmap rgbImage = filter.Apply( image );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="img/imaging/sample23.png" width="640" height="480"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/bayer_filter.jpg" width="640" height="480"/>
            </remarks>
            
            <see cref="T:AForge.Imaging.Filters.BayerFilterOptimized"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BayerFilter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BayerFilter"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BayerFilter.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BayerFilter.PerformDemosaicing">
            <summary>
            Specifies if demosaicing must be done or not.
            </summary>
            
            <remarks><para>The property specifies if color demosaicing must be done or not.
            If the property is set to <see langword="false"/>, then pixels of the result color image
            are colored according to the <see cref="P:AForge.Imaging.Filters.BayerFilter.BayerPattern">Bayer pattern</see> used, i.e. every pixel
            of the source grayscale image is copied to corresponding color plane of the result image.
            If the property is set to <see langword="true"/>, then pixels of the result image
            are set to color, which is obtained by averaging color components from the 3x3 window - pixel
            itself plus 8 surrounding neighbors.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BayerFilter.BayerPattern">
            <summary>
            Specifies Bayer pattern used for decoding color image.
            </summary>
            
            <remarks><para>The property specifies 2x2 array of RGB color indexes, which set the
            Bayer patter used for decoding color image.</para>
            
            <para>By default the property is set to:
            <code>
            new int[2, 2] { { RGB.G, RGB.R }, { RGB.B, RGB.G } }
            </code>,
            which corresponds to
            <code lang="none">
            G R
            B G
            </code>
            pattern.
            </para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.BayerFilter.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.MoveTowards">
             <summary>
             Move towards filter.
             </summary>
             
             <remarks><para>The result of this filter is an image, which is based on source image,
             but updated in the way to decrease diffirence with overlay image - source image is
             moved towards overlay image. The update equation is defined in the next way:
             <b>res = src + Min( Abs( ovr - src ), step ) * Sign( ovr - src )</b>.</para>
             
             <para>The bigger is <see cref="P:AForge.Imaging.Filters.MoveTowards.StepSize">step size</see> value the more resulting
             image will look like overlay image. For example, in the case if step size is equal
             to 255 (or 65535 for images with 16 bits per channel), the resulting image will be
             equal to overlay image regardless of source image's pixel values. In the case if step
             size is set to 1, the resulting image will very little differ from the source image.
             But, in the case if the filter is applied repeatedly to the resulting image again and
             again, it will become equal to overlay image in maximum 255 (65535 for images with 16
             bits per channel) iterations.</para>
             
             <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             MoveTowards filter = new MoveTowards( overlayImage, 20 );
             // apply the filter
             Bitmap resultImage = filter.Apply( sourceImage );
             </code>
            
             <para><b>Source image:</b></para>
             <img src="img/imaging/sample6.png" width="320" height="240"/>
             <para><b>Overlay image:</b></para>
             <img src="img/imaging/sample7.png" width="320" height="240"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/move_towards.png" width="320" height="240"/>
             </remarks>
             
        </member>
        <member name="M:AForge.Imaging.Filters.MoveTowards.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.MoveTowards"/> class
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.MoveTowards.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.MoveTowards"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.MoveTowards.#ctor(System.Drawing.Bitmap,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.MoveTowards"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            <param name="stepSize">Step size.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.MoveTowards.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.MoveTowards"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.MoveTowards.#ctor(AForge.Imaging.UnmanagedImage,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.MoveTowards"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            <param name="stepSize">Step size.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.MoveTowards.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.MoveTowards.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.MoveTowards.StepSize">
             <summary>
             Step size, [0, 65535].
             </summary>
            
             <remarks>
             <para>The property defines the maximum amount of changes per pixel in the source image.</para>
             
             <para>Default value is set to 1.</para>
             </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Drawing">
            <summary>
            Drawing primitives.
            </summary>
            
            <remarks><para>The class allows to do drawing of some primitives directly on
            locked image data or unmanaged image.</para>
            
            <para><note>All methods of this class support drawing only on color 24/32 bpp images and
            on grayscale 8 bpp indexed images.</note></para>
            
            <para><note>When it comes to alpha blending for 24/32 bpp images, all calculations are done
            as described on <a href="http://en.wikipedia.org/wiki/Alpha_compositing#Description">Wikipeadia</a>
            (see "over" operator).</note></para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Drawing.FillRectangle(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Fill rectangle on the specified image.
            </summary>
            
            <param name="imageData">Source image data to draw on.</param>
            <param name="rectangle">Rectangle's coordinates to fill.</param>
            <param name="color">Rectangle's color.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Drawing.FillRectangle(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Fill rectangle on the specified image.
            </summary>
            
            <param name="image">Source image to draw on.</param>
            <param name="rectangle">Rectangle's coordinates to fill.</param>
            <param name="color">Rectangle's color.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Drawing.Rectangle(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Draw rectangle on the specified image.
            </summary>
            
            <param name="imageData">Source image data to draw on.</param>
            <param name="rectangle">Rectangle's coordinates to draw.</param>
            <param name="color">Rectangle's color.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Drawing.Rectangle(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Draw rectangle on the specified image.
            </summary>
            
            <param name="image">Source image to draw on.</param>
            <param name="rectangle">Rectangle's coordinates to draw.</param>
            <param name="color">Rectangle's color.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Drawing.Line(System.Drawing.Imaging.BitmapData,AForge.IntPoint,AForge.IntPoint,System.Drawing.Color)">
            <summary>
            Draw a line on the specified image.
            </summary>
            
            <param name="imageData">Source image data to draw on.</param>
            <param name="point1">The first point to connect.</param>
            <param name="point2">The second point to connect.</param>
            <param name="color">Line's color.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Drawing.Line(AForge.Imaging.UnmanagedImage,AForge.IntPoint,AForge.IntPoint,System.Drawing.Color)">
            <summary>
            Draw a line on the specified image.
            </summary>
            
            <param name="image">Source image to draw on.</param>
            <param name="point1">The first point to connect.</param>
            <param name="point2">The second point to connect.</param>
            <param name="color">Line's color.</param>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:AForge.Imaging.Drawing.Polygon(System.Drawing.Imaging.BitmapData,System.Collections.Generic.List{AForge.IntPoint},System.Drawing.Color)">
            <summary>
            Draw a polygon on the specified image.
            </summary>
            
            <param name="imageData">Source image data to draw on.</param>
            <param name="points">Points of the polygon to draw.</param>
            <param name="color">Polygon's color.</param>
            
            <remarks><para>The method draws a polygon by connecting all points from the
            first one to the last one and then connecting the last point with the first one.
            </para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Drawing.Polygon(AForge.Imaging.UnmanagedImage,System.Collections.Generic.List{AForge.IntPoint},System.Drawing.Color)">
            <summary>
            Draw a polygon on the specified image.
            </summary>
            
            <param name="image">Source image to draw on.</param>
            <param name="points">Points of the polygon to draw.</param>
            <param name="color">Polygon's color.</param>
            
            <remarks><para>The method draws a polygon by connecting all points from the
            first one to the last one and then connecting the last point with the first one.
            </para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Drawing.Polyline(System.Drawing.Imaging.BitmapData,System.Collections.Generic.List{AForge.IntPoint},System.Drawing.Color)">
            <summary>
            Draw a polyline on the specified image.
            </summary>
            
            <param name="imageData">Source image data to draw on.</param>
            <param name="points">Points of the polyline to draw.</param>
            <param name="color">polyline's color.</param>
            
            <remarks><para>The method draws a polyline by connecting all points from the
            first one to the last one. Unlike <see cref="M:AForge.Imaging.Drawing.Polygon(System.Drawing.Imaging.BitmapData,System.Collections.Generic.List{AForge.IntPoint},System.Drawing.Color)"/>
            method, this method does not connect the last point with the first one.
            </para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.Drawing.Polyline(AForge.Imaging.UnmanagedImage,System.Collections.Generic.List{AForge.IntPoint},System.Drawing.Color)">
            <summary>
            Draw a polyline on the specified image.
            </summary>
            
            <param name="image">Source image to draw on.</param>
            <param name="points">Points of the polyline to draw.</param>
            <param name="color">polyline's color.</param>
            
            <remarks><para>The method draws a polyline by connecting all points from the
            first one to the last one. Unlike <see cref="M:AForge.Imaging.Drawing.Polygon(AForge.Imaging.UnmanagedImage,System.Collections.Generic.List{AForge.IntPoint},System.Drawing.Color)"/>
            method, this method does not connect the last point with the first one.
            </para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.ColorReduction.ColorImageQuantizer">
             <summary>
             Color quantization tools.
             </summary>
            
             <remarks><para>The class contains methods aimed to simplify work with color quantization
             algorithms implementing <see cref="T:AForge.Imaging.ColorReduction.IColorQuantizer"/> interface. Using its methods it is possible
             to calculate reduced color palette for the specified image or reduce colors to the specified number.</para>
             
             <para>Sample usage:</para>
             <code>
             // instantiate the images' color quantization class
             ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
             // get 16 color palette for a given image
             Color[] colorTable = ciq.CalculatePalette( image, 16 );
             
             // ... or just reduce colors in the specified image
             Bitmap newImage = ciq.ReduceColors( image, 16 );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="img/imaging/sample1.jpg" width="480" height="361"/>
             <para><b>Result image:</b></para>
             <img src="img/imaging/reduced_colors.png" width="480" height="361"/>
             </remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.#ctor(AForge.Imaging.ColorReduction.IColorQuantizer)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.ColorReduction.ColorImageQuantizer"/> class.
            </summary>
            
            <param name="quantizer">Color quantization algorithm to use for processing images.</param>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.CalculatePalette(System.Drawing.Bitmap,System.Int32)">
            <summary>
            Calculate reduced color palette for the specified image.
            </summary>
            
            <param name="image">Image to calculate palette for.</param>
            <param name="paletteSize">Palette size to calculate.</param>
            
            <returns>Return reduced color palette for the specified image.</returns>
            
            <remarks><para>See <see cref="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.CalculatePalette(AForge.Imaging.UnmanagedImage,System.Int32)"/> for details.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.CalculatePalette(AForge.Imaging.UnmanagedImage,System.Int32)">
             <summary>
             Calculate reduced color palette for the specified image.
             </summary>
             
             <param name="image">Image to calculate palette for.</param>
             <param name="paletteSize">Palette size to calculate.</param>
             
             <returns>Return reduced color palette for the specified image.</returns>
             
             <remarks><para>The method processes the specified image and feeds color value of each pixel
             to the specified color quantization algorithm. Finally it returns color palette built by
             that algorithm.</para></remarks>
            
             <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported format of the source image - it must 24 or 32 bpp color image.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(System.Drawing.Bitmap,System.Int32)">
            <summary>
            Create an image with reduced number of colors.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="paletteSize">Number of colors to get in the output image, [2, 256].</param>
            
            <returns>Returns image with reduced number of colors.</returns>
            
            <remarks><para>See <see cref="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(AForge.Imaging.UnmanagedImage,System.Int32)"/> for details.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(AForge.Imaging.UnmanagedImage,System.Int32)">
            <summary>
            Create an image with reduced number of colors.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="paletteSize">Number of colors to get in the output image, [2, 256].</param>
            
            <returns>Returns image with reduced number of colors.</returns>
            
            <remarks><para>The method creates an image, which looks similar to the specified image, but contains
            reduced number of colors. First, target color palette is calculated using <see cref="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.CalculatePalette(AForge.Imaging.UnmanagedImage,System.Int32)"/>
            method and then a new image is created, where pixels from the given source image are substituted by
            best matching colors from calculated color table.</para>
            
            <para><note>The output image has 4 bpp or 8 bpp indexed pixel format depending on the target palette size -
            4 bpp for palette size 16 or less; 8 bpp otherwise.</note></para>
            </remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported format of the source image - it must 24 or 32 bpp color image.</exception>
            <exception cref="T:System.ArgumentException">Invalid size of the target color palette.</exception>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(System.Drawing.Bitmap,System.Drawing.Color[])">
            <summary>
            Create an image with reduced number of colors using the specified palette.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="palette">Target color palette. Must contatin 2-256 colors.</param>
            
            <returns>Returns image with reduced number of colors.</returns>
            
            <remarks><para>See <see cref="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(AForge.Imaging.UnmanagedImage,System.Drawing.Color[])"/> for details.</para></remarks>
            
        </member>
        <member name="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(AForge.Imaging.UnmanagedImage,System.Drawing.Color[])">
            <summary>
            Create an image with reduced number of colors using the specified palette.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="palette">Target color palette. Must contatin 2-256 colors.</param>
            
            <returns>Returns image with reduced number of colors.</returns>
            
            <remarks><para>The method creates an image, which looks similar to the specified image, but contains
            reduced number of colors. Is substitutes every pixel of the source image with the closest matching color
            in the specified paletter.</para>
            
            <para><note>The output image has 4 bpp or 8 bpp indexed pixel format depending on the target palette size -
            4 bpp for palette size 16 or less; 8 bpp otherwise.</note></para>
            </remarks>
            
            <exception cref="T:AForge.Imaging.UnsupportedImageFormatException">Unsupported format of the source image - it must 24 or 32 bpp color image.</exception>
            <exception cref="T:System.ArgumentException">Invalid size of the target color palette.</exception>
            
        </member>
        <member name="P:AForge.Imaging.ColorReduction.ColorImageQuantizer.Quantizer">
            <summary>
            Color quantization algorithm used by this class to build color palettes for the specified images.
            </summary>
            
        </member>
        <member name="P:AForge.Imaging.ColorReduction.ColorImageQuantizer.UseCaching">
            <summary>
            Use color caching during color reduction or not.
            </summary>
            
            <remarks><para>The property has effect only for methods like <see cref="M:AForge.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(System.Drawing.Bitmap,System.Int32)"/> and
            specifies if internal cache of already processed colors should be used or not. For each pixel in the original
            image the color reduction routine does search in target color palette to find the best matching color.
            To avoid doing the search again and again for already processed colors, the class may use internal dictionary
            which maps colors of original image to indexes in target color palette.
            </para>
            
            <para><note>The property provides a trade off. On one hand it may speedup color reduction routine, but on another
            hand it increases memory usage. Also cache usage may not be efficient for very small target color tables.</note></para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Pixellate">
            <summary>
            Pixellate filter.
            </summary>
            
            <remarks><para>The filter processes an image creating the effect of an image with larger
            pixels - pixellated image. The effect is achieved by filling image's rectangles of the
            specified size by the color, which is mean color value for the corresponding rectangle.
            The size of rectangles to process is set by <see cref="P:AForge.Imaging.Filters.Pixellate.PixelWidth"/> and <see cref="P:AForge.Imaging.Filters.Pixellate.PixelHeight"/>
            properties.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Pixellate filter = new Pixellate( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample1.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/pixellate.jpg" width="480" height="361"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Pixellate.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Pixellate"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Pixellate.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Pixellate"/> class.
            </summary>
            
            <param name="pixelSize">Pixel size.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Pixellate.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Pixellate"/> class.
            </summary>
            
            <param name="pixelWidth">Pixel width.</param>
            <param name="pixelHeight">Pixel height.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Pixellate.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Pixellate.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.Pixellate.PixelWidth">
            <summary>
            Pixel width, [2, 32].
            </summary>
            
            <remarks>Default value is set to <b>8</b>.</remarks>
            
            <seealso cref="P:AForge.Imaging.Filters.Pixellate.PixelSize"/>
            <seealso cref="P:AForge.Imaging.Filters.Pixellate.PixelHeight"/>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Pixellate.PixelHeight">
            <summary>
            Pixel height, [2, 32].
            </summary>
            
            <remarks>Default value is set to <b>8</b>.</remarks>
            
            <seealso cref="P:AForge.Imaging.Filters.Pixellate.PixelSize"/>
            <seealso cref="P:AForge.Imaging.Filters.Pixellate.PixelWidth"/>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Pixellate.PixelSize">
            <summary>
            Pixel size, [2, 32].
            </summary>
            
            <remarks>The property is used to set both <see cref="P:AForge.Imaging.Filters.Pixellate.PixelWidth"/> and
            <see cref="P:AForge.Imaging.Filters.Pixellate.PixelHeight"/> simultaneously.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ApplyMask">
            <summary>
            Apply mask to the specified image.
            </summary>
            
            <remarks><para>The filter applies mask to the specified image - keeps all pixels
            in the image if corresponding pixels/values of the mask are not equal to 0. For all
            0 pixels/values in mask, corresponding pixels in the source image are set to 0.</para>
            
            <para>Mask can be specified as <see cref="P:AForge.Imaging.Filters.ApplyMask.MaskImage">.NET's managed Bitmap</see>, as
            <see cref="P:AForge.Imaging.Filters.ApplyMask.UnmanagedMaskImage">UnmanagedImage</see> or as <see cref="P:AForge.Imaging.Filters.ApplyMask.Mask">byte array</see>.
            In the case if mask is specified as image, it must be 8 bpp grayscale image. In all case
            mask size must be the same as size of the image to process.</para>
            
            <para>The filter accepts 8/16 bpp grayscale and 24/32/48/64 bpp color images for processing.</para>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ApplyMask.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ApplyMask"/> class.
            </summary>
            
            <param name="maskImage"><see cref="P:AForge.Imaging.Filters.ApplyMask.MaskImage">Mask image</see> to use.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ApplyMask.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ApplyMask"/> class.
            </summary>
            
            <param name="unmanagedMaskImage"><see cref="P:AForge.Imaging.Filters.ApplyMask.UnmanagedMaskImage">Unmanaged mask image</see> to use.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ApplyMask.#ctor(System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ApplyMask"/> class.
            </summary>
            
            <param name="mask"><see cref="P:AForge.Imaging.Filters.ApplyMask.Mask"/> to use.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ApplyMask.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <exception cref="T:System.NullReferenceException">None of the possible mask properties were set. Need to provide mask before applying the filter.</exception>
             <exception cref="T:System.ArgumentException">Invalid size of provided mask. Its size must be the same as the size of the image to mask.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ApplyMask.MaskImage">
            <summary>
            Mask image to apply.
            </summary>
            
            <remarks><para>The property specifies mask image to use. The image must be grayscale
            (8 bpp format) and have the same size as the source image to process.</para>
            
            <para>When the property is set, both <see cref="P:AForge.Imaging.Filters.ApplyMask.UnmanagedMaskImage"/> and
            <see cref="P:AForge.Imaging.Filters.ApplyMask.Mask"/> properties are set to <see langword="null"/>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">The mask image must be 8 bpp grayscale image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ApplyMask.UnmanagedMaskImage">
            <summary>
            Unmanaged mask image to apply.
            </summary>
            
            <remarks><para>The property specifies unmanaged mask image to use. The image must be grayscale
            (8 bpp format) and have the same size as the source image to process.</para>
            
            <para>When the property is set, both <see cref="P:AForge.Imaging.Filters.ApplyMask.MaskImage"/> and
            <see cref="P:AForge.Imaging.Filters.ApplyMask.Mask"/> properties are set to <see langword="null"/>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">The mask image must be 8 bpp grayscale image.</exception>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ApplyMask.Mask">
            <summary>
            Mask to apply.
            </summary>
            
            <remarks><para>The property specifies mask array to use. Size of the array must
            be the same size as the size of the source image to process - its 0<sup>th</sup> dimension
            must be equal to image's height and its 1<sup>st</sup> dimension must be equal to width. For
            example, for 640x480 image, the mask array must be defined as:
            <code>
            byte[,] mask = new byte[480, 640];
            </code>
            </para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ApplyMask.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.CannyEdgeDetector">
            <summary>
            Canny edge detector.
            </summary>
            
            <remarks><para>The filter searches for objects' edges by applying Canny edge detector.
            The implementation follows
            <a href="http://www.pages.drexel.edu/~weg22/can_tut.html">Bill Green's Canny edge detection tutorial</a>.</para>
            
            <para><note>The implemented canny edge detector has one difference with the above linked algorithm.
            The difference is in hysteresis step, which is a bit simplified (getting faster as a result). On the
            hysteresis step each pixel is compared with two threshold values: <see cref="P:AForge.Imaging.Filters.CannyEdgeDetector.HighThreshold"/> and
            <see cref="P:AForge.Imaging.Filters.CannyEdgeDetector.LowThreshold"/>. If pixel's value is greater or equal to <see cref="P:AForge.Imaging.Filters.CannyEdgeDetector.HighThreshold"/>, then
            it is kept as edge pixel. If pixel's value is greater or equal to <see cref="P:AForge.Imaging.Filters.CannyEdgeDetector.LowThreshold"/>, then
            it is kept as edge pixel only if there is at least one neighbouring pixel (8 neighbours are checked) which
            has value greater or equal to <see cref="P:AForge.Imaging.Filters.CannyEdgeDetector.HighThreshold"/>; otherwise it is none edge pixel. In the case
            if pixel's value is less than <see cref="P:AForge.Imaging.Filters.CannyEdgeDetector.LowThreshold"/>, then it is marked as none edge immediately.
            </note></para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            CannyEdgeDetector filter = new CannyEdgeDetector( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/sample2.jpg" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/canny_edges.png" width="320" height="240"/>
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CannyEdgeDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CannyEdgeDetector"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CannyEdgeDetector.#ctor(System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CannyEdgeDetector"/> class.
            </summary>
            
            <param name="lowThreshold">Low threshold.</param>
            <param name="highThreshold">High threshold.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CannyEdgeDetector.#ctor(System.Byte,System.Byte,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.CannyEdgeDetector"/> class.
            </summary>
            
            <param name="lowThreshold">Low threshold.</param>
            <param name="highThreshold">High threshold.</param>
            <param name="sigma">Gaussian sigma.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.CannyEdgeDetector.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CannyEdgeDetector.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.CannyEdgeDetector.LowThreshold">
            <summary>
            Low threshold.
            </summary>
            
            <remarks><para>Low threshold value used for hysteresis
            (see  <a href="http://www.pages.drexel.edu/~weg22/can_tut.html">tutorial</a>
            for more information).</para>
            
            <para>Default value is set to <b>20</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CannyEdgeDetector.HighThreshold">
            <summary>
            High threshold.
            </summary>
            
            <remarks><para>High threshold value used for hysteresis
            (see  <a href="http://www.pages.drexel.edu/~weg22/can_tut.html">tutorial</a>
            for more information).</para>
            
            <para>Default value is set to <b>100</b>.</para>
            </remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CannyEdgeDetector.GaussianSigma">
            <summary>
            Gaussian sigma.
            </summary>
            
            <remarks>Sigma value for <see cref="P:AForge.Imaging.Filters.GaussianBlur.Sigma">Gaussian bluring</see>.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.CannyEdgeDetector.GaussianSize">
            <summary>
            Gaussian size.
            </summary>
            
            <remarks>Size of <see cref="P:AForge.Imaging.Filters.GaussianBlur.Size">Gaussian kernel</see>.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.LevelsLinear16bpp">
            <summary>
            Linear correction of RGB channels for images, which have 16 bpp planes (16 bit gray images or 48/64 bit colour images).
            </summary>
            
            <remarks><para>The filter performs linear correction of RGB channels by mapping specified
            channels' input ranges to output ranges. This version of the filter processes only images
            with 16 bpp colour planes. See <see cref="T:AForge.Imaging.Filters.LevelsLinear"/> for 8 bpp version.</para>
            
            <para>The filter accepts 16 bpp grayscale and 48/64 bpp colour images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            LevelsLinear16bpp filter = new LevelsLinear16bpp( );
            // set ranges
            filter.InRed   = new IntRange( 3000, 42000 );
            filter.InGreen = new IntRange( 5000, 37500 );
            filter.InBlue  = new IntRange( 1000, 60000 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.LevelsLinear"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.LevelsLinear16bpp.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.LevelsLinear"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.LevelsLinear16bpp.ProcessFilter(AForge.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.LevelsLinear16bpp.CalculateMap(AForge.IntRange,AForge.IntRange,System.UInt16[])">
            <summary>
            Calculate conversion map.
            </summary>
            
            <param name="inRange">Input range.</param>
            <param name="outRange">Output range.</param>
            <param name="map">Conversion map.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear16bpp.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear16bpp.InRed">
            <summary>
            Red component's input range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear16bpp.InGreen">
            <summary>
            Green component's input range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear16bpp.InBlue">
            <summary>
            Blue component's input range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear16bpp.InGray">
            <summary>
            Gray component's input range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear16bpp.Input">
            <summary>
            Input range for RGB components.
            </summary>
            
            <remarks>The property allows to set red, green and blue input ranges to the same value.</remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear16bpp.OutRed">
            <summary>
            Red component's output range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear16bpp.OutGreen">
            <summary>
            Green component's output range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear16bpp.OutBlue">
            <summary>
            Blue component's output range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear16bpp.OutGray">
            <summary>
            Gray component's output range.
            </summary>
        </member>
        <member name="P:AForge.Imaging.Filters.LevelsLinear16bpp.Output">
            <summary>
            Output range for RGB components.
            </summary>
            
            <remarks>The property allows to set red, green and blue output ranges to the same value.</remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.SierraDithering">
            <summary>
            Dithering using Sierra error diffusion.
            </summary>
            
            <remarks><para>The filter represents binarization filter, which is based on
            error diffusion dithering with Sierra coefficients. Error is diffused
            on 10 neighbor pixels with next coefficients:</para>
            <code lang="none">
                    | * | 5 | 3 |
            | 2 | 4 | 5 | 4 | 2 |
                | 2 | 3 | 2 |
            
            / 32
            </code>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SierraDithering filter = new SierraDithering( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/grayscale.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/sierra.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.BurkesDithering"/>
            <seealso cref="T:AForge.Imaging.Filters.FloydSteinbergDithering"/>
            <seealso cref="T:AForge.Imaging.Filters.JarvisJudiceNinkeDithering"/>
            <seealso cref="T:AForge.Imaging.Filters.StuckiDithering"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.SierraDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.SierraDithering"/> class.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Filters.BurkesDithering">
            <summary>
            Dithering using Burkes error diffusion.
            </summary>
            
            <remarks><para>The filter represents binarization filter, which is based on
            error diffusion dithering with Burkes coefficients. Error is diffused
            on 7 neighbor pixels with next coefficients:</para>
            <code lang="none">
                    | * | 8 | 4 |
            | 2 | 4 | 8 | 4 | 2 |
            
            / 32
            </code>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            BurkesDithering filter = new BurkesDithering( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="img/imaging/grayscale.jpg" width="480" height="361"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/burkes.jpg" width="480" height="361"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.FloydSteinbergDithering"/>
            <seealso cref="T:AForge.Imaging.Filters.JarvisJudiceNinkeDithering"/>
            <seealso cref="T:AForge.Imaging.Filters.SierraDithering"/>
            <seealso cref="T:AForge.Imaging.Filters.StuckiDithering"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.BurkesDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.BurkesDithering"/> class.
            </summary>
            
        </member>
        <member name="T:AForge.Imaging.Filters.ThresholdedDifference">
            <summary>
            Calculate difference between two images and threshold it.
            </summary>
            
            <remarks><para>The filter produces similar result as applying <see cref="T:AForge.Imaging.Filters.Difference"/> filter and
            then <see cref="P:AForge.Imaging.Filters.ThresholdedDifference.Threshold"/> filter - thresholded difference between two images. Result of this
            image processing routine may be useful in motion detection applications or finding areas of significant
            difference.</para>
            
            <para>The filter accepts 8 and 24/32color images for processing.
            In the case of color images, the image processing routine differences sum over 3 RGB channels (Manhattan distance), i.e.
            |diffR| + |diffG| + |diffB|.
            </para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ThresholdedDifference filter = new ThresholdedDifference( 60 );
            // apply the filter
            filter.OverlayImage = backgroundImage;
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="img/imaging/object.jpg" width="320" height="240"/>
            <para><b>Background image:</b></para>
            <img src="img/imaging/background.jpg" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/thresholded_difference.png" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.ThresholdedEuclideanDifference"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ThresholdedDifference.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ThresholdedDifference"/> class.
            </summary>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ThresholdedDifference.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.ThresholdedDifference"/> class.
            </summary>
            
            <param name="threshold">Difference threshold (see <see cref="P:AForge.Imaging.Filters.ThresholdedDifference.Threshold"/>).</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.ThresholdedDifference.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="overlay">Overlay image data.</param>
            <param name="destinationData">Destination image data</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ThresholdedDifference.Threshold">
            <summary>
            Difference threshold.
            </summary>
            
            <remarks><para>The property specifies difference threshold. If difference between pixels of processing image
            and overlay image is greater than this value, then corresponding pixel of result image is set to white; otherwise
            black.
            </para>
            
            <para>Default value is set to <b>15</b>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ThresholdedDifference.WhitePixelsCount">
             <summary>
             Number of pixels which were set to white in destination image during last image processing call.
             </summary>
            
             <remarks><para>The property may be useful to determine amount of difference between two images which,
             for example, may be treated as amount of motion in motion detection applications, etc.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.ThresholdedDifference.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="T:AForge.Imaging.Filters.Subtract">
            <summary>
            Subtract filter - subtract pixel values of two images.
            </summary>
            
            <remarks><para>The subtract filter takes two images (source and overlay images)
            of the same size and pixel format and produces an image, where each pixel equals
            to the difference value of corresponding pixels from provided images (if difference is less
            than minimum allowed value, 0, then it is truncated to that minimum value).</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Subtract filter = new Subtract( overlayImage );
            // apply the filter
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="img/imaging/sample6.png" width="320" height="240"/>
            <para><b>Overlay image:</b></para>
            <img src="img/imaging/sample7.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/subtract.png" width="320" height="240"/>
            </remarks>
            
            <seealso cref="T:AForge.Imaging.Filters.Merge"/>
            <seealso cref="T:AForge.Imaging.Filters.Intersect"/>
            <seealso cref="T:AForge.Imaging.Filters.Add"/>
            <seealso cref="T:AForge.Imaging.Filters.Difference"/>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Subtract.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Subtract"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.Subtract.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Subtract"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Subtract.#ctor(AForge.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.Subtract"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.Subtract.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.Subtract.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.StereoAnaglyph">
            <summary>
            Stereo anaglyph filter.
            </summary>
            
            <remarks><para>The image processing filter produces stereo anaglyph images which are
            aimed to be viewed through anaglyph glasses with red filter over the left eye and
            cyan over the right.</para>
            
            <img src="img/imaging/anaglyph_glasses.png" width="125" height="97"/>
            
            <para>The stereo image is produced by combining two images of the same scene taken
            from a bit different points. The right image must be provided to the filter using
            <see cref="P:AForge.Imaging.Filters.BaseInPlaceFilter2.OverlayImage"/> property, but the left image must be provided to
            <see cref="M:AForge.Imaging.Filters.IFilter.Apply(System.Drawing.Bitmap)"/> method, which creates the anaglyph image.</para>
            
            <para>The filter accepts 24 bpp color images for processing.</para>
            
            <para>See <see cref="T:AForge.Imaging.Filters.StereoAnaglyph.Algorithm"/> enumeration for the list of supported anaglyph algorithms.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            StereoAnaglyph filter = new StereoAnaglyph( );
            // set right image as overlay
            filter.Overlay = rightImage
            // apply the filter (providing left image)
            Bitmap resultImage = filter.Apply( leftImage );
            </code>
            
            <para><b>Source image (left):</b></para>
            <img src="img/imaging/sample16_left.png" width="320" height="240"/>
            <para><b>Overlay image (right):</b></para>
            <img src="img/imaging/sample16_right.png" width="320" height="240"/>
            <para><b>Result image:</b></para>
            <img src="img/imaging/anaglyph.png" width="320" height="240"/>
            
            </remarks>
            
        </member>
        <member name="M:AForge.Imaging.Filters.StereoAnaglyph.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.StereoAnaglyph"/> class.
            </summary>
        </member>
        <member name="M:AForge.Imaging.Filters.StereoAnaglyph.#ctor(AForge.Imaging.Filters.StereoAnaglyph.Algorithm)">
            <summary>
            Initializes a new instance of the <see cref="T:AForge.Imaging.Filters.StereoAnaglyph"/> class.
            </summary>
            
            <param name="anaglyphAlgorithm">Algorithm to use for creating anaglyph images.</param>
            
        </member>
        <member name="M:AForge.Imaging.Filters.StereoAnaglyph.ProcessFilter(AForge.Imaging.UnmanagedImage,AForge.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data (left image).</param>
             <param name="overlay">Overlay image data (right image).</param>
            
        </member>
        <member name="P:AForge.Imaging.Filters.StereoAnaglyph.AnaglyphAlgorithm">
            <summary>
            Algorithm to use for creating anaglyph images.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:AForge.Imaging.Filters.StereoAnaglyph.Algorithm.GrayAnaglyph"/>.</para></remarks>
            
        </member>
        <member name="P:AForge.Imaging.Filters.StereoAnaglyph.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="T:AForge.Imaging.Filters.StereoAnaglyph.Algorithm">
            <summary>
            Enumeration of algorithms for creating anaglyph images.
            </summary>
            
            <remarks><para>See <a href="http://www.3dtv.at/Knowhow/AnaglyphComparison_en.aspx">anaglyph methods comparison</a> for
            descipton of different algorithms.</para>
            </remarks>
            
        </member>
        <member name="F:AForge.Imaging.Filters.StereoAnaglyph.Algorithm.TrueAnaglyph">
            <summary>
            Creates anaglyph image using the below calculations:
            <list type="bullet">
            <item>R<sub>a</sub>=0.299*R<sub>l</sub>+0.587*G<sub>l</sub>+0.114*B<sub>l</sub>;</item>
            <item>G<sub>a</sub>=0;</item>
            <item>B<sub>a</sub>=0.299*R<sub>r</sub>+0.587*G<sub>r</sub>+0.114*B<sub>r</sub>.</item>
            </list>
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.StereoAnaglyph.Algorithm.GrayAnaglyph">
            <summary>
            Creates anaglyph image using the below calculations:
            <list type="bullet">
            <item>R<sub>a</sub>=0.299*R<sub>l</sub>+0.587*G<sub>l</sub>+0.114*B<sub>l</sub>;</item>
            <item>G<sub>a</sub>=0.299*R<sub>r</sub>+0.587*G<sub>r</sub>+0.114*B<sub>r</sub>;</item>
            <item>B<sub>a</sub>=0.299*R<sub>r</sub>+0.587*G<sub>r</sub>+0.114*B<sub>r</sub>.</item>
            </list>
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.StereoAnaglyph.Algorithm.ColorAnaglyph">
            <summary>
            Creates anaglyph image using the below calculations:
            <list type="bullet">
            <item>R<sub>a</sub>=R<sub>l</sub>;</item>
            <item>G<sub>a</sub>=G<sub>r</sub>;</item>
            <item>B<sub>a</sub>=B<sub>r</sub>.</item>
            </list>
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.StereoAnaglyph.Algorithm.HalfColorAnaglyph">
            <summary>
            Creates anaglyph image using the below calculations:
            <list type="bullet">
            <item>R<sub>a</sub>=0.299*R<sub>l</sub>+0.587*G<sub>l</sub>+0.114*B<sub>l</sub>;</item>
            <item>G<sub>a</sub>=G<sub>r</sub>;</item>
            <item>B<sub>a</sub>=B<sub>r</sub>.</item>
            </list>
            </summary>
        </member>
        <member name="F:AForge.Imaging.Filters.StereoAnaglyph.Algorithm.OptimizedAnaglyph">
            <summary>
            Creates anaglyph image using the below calculations:
            <list type="bullet">
            <item>R<sub>a</sub>=0.7*G<sub>l</sub>+0.3*B<sub>l</sub>;</item>
            <item>G<sub>a</sub>=G<sub>r</sub>;</item>
            <item>B<sub>a</sub>=B<sub>r</sub>.</item>
            </list>
            </summary>
        </member>
    </members>
</doc>
